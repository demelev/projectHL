// WARNING:Skipped nested type: System.Linq.Expressions.CompilationContext+ParameterReplacer
// WARNING:Skipped nested type: System.Linq.Expressions.CompilationContext+HoistedVariableDetector
// WARNING:Skipped nested type: System.Linq.Expressions.Expression+<TryGetMethod>c__AnonStorey22
// WARNING:Skipped nested type: System.Linq.Expressions.Expression+<CreateInitializers>c__AnonStorey23
// WARNING:Skipped nested type: System.Linq.Expressions.ConstantExpression+<EmitConstant>c__AnonStorey24
// WARNING:Skipped nested type: System.Linq.Expressions.MemberBinding+<EmitLoadMember>c__AnonStorey25
// WARNING:Skipped nested type: System.Linq.Expressions.MemberAssignment+<Emit>c__AnonStorey26
// WARNING:Skipped nested type: System.Linq.Expressions.MemberExpression+<Emit>c__AnonStorey27
// WARNING:Skipped nested type: System.TimeZoneInfo+AdjustmentRule
// WARNING:Skipped nested type: System.Collections.Generic.HashSet`1+PrimeHelper[T]
// WARNING:Skipped nested type: System.Linq.Enumerable+PredicateOf`1[T]
// WARNING:Skipped nested type: System.Linq.Enumerable+Function`1[T]
// WARNING:Skipped nested type: System.Linq.Enumerable+ReadOnlyCollectionOf`1[T]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateCastIterator>c__Iterator0`1[TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateConcatIterator>c__Iterator1`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateDefaultIfEmptyIterator>c__Iterator2`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateDistinctIterator>c__Iterator3`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateExceptIterator>c__Iterator4`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateGroupByIterator>c__Iterator5`2[TSource,TKey]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateGroupByIterator>c__Iterator6`3[TSource,TKey,TElement]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateGroupByIterator>c__Iterator7`4[TSource,TKey,TElement,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateGroupByIterator>c__Iterator8`3[TSource,TKey,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateGroupJoinIterator>c__Iterator9`4[TOuter,TInner,TKey,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateIntersectIterator>c__IteratorA`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateJoinIterator>c__IteratorB`4[TOuter,TInner,TKey,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateOfTypeIterator>c__IteratorC`1[TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateRangeIterator>c__IteratorD
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateRepeatIterator>c__IteratorE`1[TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateReverseIterator>c__IteratorF`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectIterator>c__Iterator10`2[TSource,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectIterator>c__Iterator11`2[TSource,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectManyIterator>c__Iterator12`2[TSource,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectManyIterator>c__Iterator13`2[TSource,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectManyIterator>c__Iterator14`3[TSource,TCollection,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSelectManyIterator>c__Iterator15`3[TSource,TCollection,TResult]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSkipIterator>c__Iterator16`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSkipWhileIterator>c__Iterator17`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateSkipWhileIterator>c__Iterator18`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateTakeIterator>c__Iterator19`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateTakeWhileIterator>c__Iterator1A`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateTakeWhileIterator>c__Iterator1B`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateUnionIterator>c__Iterator1C`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateWhereIterator>c__Iterator1D`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<CreateWhereIterator>c__Iterator1E`1[TSource]
// WARNING:Skipped nested type: System.Linq.Lookup`2+<ApplyResultSelector>c__Iterator1F`1[TKey,TElement,TResult]
// WARNING:Skipped nested type: System.Linq.Lookup`2+<GetEnumerator>c__Iterator20[TKey,TElement]
// WARNING:Skipped nested type: System.Linq.QuickSort`1+<Sort>c__Iterator21[TElement]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey28`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey29`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey2A`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey2B`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey2C`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Max>c__AnonStorey2D`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey2E`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey2F`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey30`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey31`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey32`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Min>c__AnonStorey33`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Sum>c__AnonStorey34`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Sum>c__AnonStorey35`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Sum>c__AnonStorey36`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Sum>c__AnonStorey37`1[TSource]
// WARNING:Skipped nested type: System.Linq.Enumerable+<Sum>c__AnonStorey38`1[TSource]
// WARNING:Skipped nested type: System.Threading.ReaderWriterLockSlim+LockDetails

// INFO:MMCSReflector::ImportedAssembly: System.Core, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e

namespace System.Runtime.CompilerServices {
	public sealed class	ExtensionAttribute: Attribute, _Attribute
	{
		public ExtensionAttribute(){}
	}

	public class	ExecutionScope: Object
	{
		public Delegate CreateDelegate(int indexLambda, Object[] locals){}
		public Object[] CreateHoistedLocals(){}
		public Expression IsolateExpression(Expression expression, Object[] locals){}
		private ExecutionScope(CompilationContext context, int compilation_unit){}
		internal ExecutionScope(CompilationContext context){}
		internal ExecutionScope(CompilationContext context, int compilation_unit, ExecutionScope parent, Object[] locals){}
		public Object[] Globals;
		public Object[] Locals;
		public ExecutionScope Parent;
		internal CompilationContext context;
		internal int compilation_unit;
	}

	public interface IStrongBox	{
		System.Object Value{ get; set; }
	}

	public class	StrongBox<T>: Object, IStrongBox
	{
		private sealed virtual System.Object System.Runtime.CompilerServices.IStrongBox.get_Value(){}
		private sealed virtual void System.Runtime.CompilerServices.IStrongBox.set_Value(System.Object value){}
		public StrongBox(T value){}
		System.Object System.Runtime.CompilerServices.IStrongBox.Value{ get	{} set	{} }
		public T Value;
	}

}

namespace System.Linq.Expressions {
	public sealed class	Expression<TDelegate>: LambdaExpression
	{
		public TDelegate Compile(){}
		internal Expression(Expression body, ReadOnlyCollection<ParameterExpression> parameters){}
	}

	public class	LambdaExpression: Expression
	{
		private void EmitPopIfNeeded(EmitContext ec){}
		internal virtual void Emit(EmitContext ec){}
		internal void EmitBody(EmitContext ec){}
		internal Type GetReturnType(){}
		public Delegate Compile(){}
		internal LambdaExpression(Type delegateType, Expression body, ReadOnlyCollection<ParameterExpression> parameters){}
		public Expression Body{ get	{} }
		public ReadOnlyCollection<ParameterExpression> Parameters{ get	{} }
		private Expression body;
		private ReadOnlyCollection<ParameterExpression> parameters;
	}

	public abstract	class	Expression: Object
	{
		private static void CheckForNull(ReadOnlyCollection<T> collection, string name){}
		public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable<ElementInit> initializers){}
		public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers){}
		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<ElementInit> initializers){}
		public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers){}
		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<Expression> initializers){}
		private static ReadOnlyCollection<ElementInit> CreateInitializers(MethodInfo add_method, ReadOnlyCollection<Expression> initializers){}
		private static MethodInfo GetAddMethod(Type type, Type arg){}
		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers){}
		private static ReadOnlyCollection<T> CheckListInit(NewExpression newExpression, IEnumerable<T> initializers){}
		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable<Expression> initializers){}
		public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member){}
		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type){}
		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method){}
		public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings){}
		public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable<MemberBinding> bindings){}
		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings){}
		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable<MemberBinding> bindings){}
		private static ReadOnlyCollection<MemberBinding> CheckMemberBindings(Type type, IEnumerable<MemberBinding> bindings){}
		public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings){}
		public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable<MemberBinding> bindings){}
		public static UnaryExpression Negate(Expression expression){}
		public static UnaryExpression Negate(Expression expression, MethodInfo method){}
		public static UnaryExpression NegateChecked(Expression expression){}
		public static UnaryExpression NegateChecked(Expression expression, MethodInfo method){}
		public static NewExpression New(ConstructorInfo constructor){}
		public static NewExpression New(Type type){}
		public static NewExpression New(ConstructorInfo constructor, Expression[] arguments){}
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments){}
		private static IList<Expression> CreateArgumentList(IEnumerable<Expression> arguments){}
		private static void CheckNonGenericMethod(MethodBase method){}
		private static ReadOnlyCollection<Expression> CheckMethodArguments(MethodBase method, IEnumerable<Expression> args){}
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, MemberInfo[] members){}
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, IEnumerable<MemberInfo> members){}
		public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds){}
		public static NewArrayExpression NewArrayBounds(Type type, IEnumerable<Expression> bounds){}
		public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers){}
		public static NewArrayExpression NewArrayInit(Type type, IEnumerable<Expression> initializers){}
		public static UnaryExpression Not(Expression expression){}
		public static UnaryExpression Not(Expression expression, MethodInfo method){}
		private static void CheckNotVoid(Type type){}
		public static ParameterExpression Parameter(Type type, string name){}
		public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor){}
		private static PropertyInfo GetAssociatedProperty(MethodInfo method){}
		public static MemberExpression Property(Expression expression, PropertyInfo property){}
		public static MemberExpression Property(Expression expression, string propertyName){}
		public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName){}
		public static UnaryExpression Quote(Expression expression){}
		public static UnaryExpression TypeAs(Expression expression, Type type){}
		public static TypeBinaryExpression TypeIs(Expression expression, Type type){}
		public static UnaryExpression UnaryPlus(Expression expression){}
		public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method){}
		private static bool IsInt(Type t){}
		private static bool IsIntOrBool(Type t){}
		private static bool IsNumber(Type t){}
		private static bool IsSignedNumber(Type t){}
		internal static bool IsUnsigned(Type t){}
		internal virtual void Emit(EmitContext ec){}
		private static Type <CollectTypes>m__0(Expression arg){}
		private static Type <GetDelegateType>m__2(ParameterExpression p){}
		private static void <ListBind>m__3(FieldInfo field){}
		private static void <ListBind>m__4(PropertyInfo prop){}
		private static Type <MemberBind>m__6(FieldInfo field){}
		private static Type <MemberBind>m__7(PropertyInfo prop){}
		private static bool <Negate>m__8(Type type){}
		private static bool <NegateChecked>m__9(Type type){}
		private static bool <Not>m__A(Type type){}
		private static bool <UnaryPlus>m__B(Type type){}
		public virtual string ToString(){}
		private static MethodInfo GetUnaryOperator(string oper_name, Type declaring, Type param){}
		private static MethodInfo GetUnaryOperator(string oper_name, Type declaring, Type param, Type ret){}
		internal static MethodInfo GetTrueOperator(Type self){}
		internal static MethodInfo GetFalseOperator(Type self){}
		private static MethodInfo GetBooleanOperator(string op, Type self){}
		private static bool IsAssignableToParameterType(Type type, ParameterInfo param){}
		private static MethodInfo CheckUnaryMethod(MethodInfo method, Type param){}
		private static MethodInfo UnaryCoreCheck(string oper_name, Expression expression, MethodInfo method, Func<Type, Boolean> validator){}
		private static MethodInfo GetBinaryOperator(string oper_name, Type on_type, Expression left, Expression right){}
		private static MethodInfo BinaryCoreCheck(string oper_name, Expression left, Expression right, MethodInfo method){}
		private static MethodInfo BinaryBitwiseCoreCheck(string oper_name, Expression left, Expression right, MethodInfo method){}
		private static BinaryExpression MakeSimpleBinary(ExpressionType et, Expression left, Expression right, MethodInfo method){}
		private static bool IsAssignableToOperatorParameter(Expression expression, ParameterInfo parameter){}
		private static UnaryExpression MakeSimpleUnary(ExpressionType et, Expression expression, MethodInfo method){}
		private static BinaryExpression MakeBoolBinary(ExpressionType et, Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression Add(Expression left, Expression right){}
		public static BinaryExpression Add(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression AddChecked(Expression left, Expression right){}
		public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Subtract(Expression left, Expression right){}
		public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression SubtractChecked(Expression left, Expression right){}
		public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Modulo(Expression left, Expression right){}
		public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Multiply(Expression left, Expression right){}
		public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression MultiplyChecked(Expression left, Expression right){}
		public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Divide(Expression left, Expression right){}
		public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Power(Expression left, Expression right){}
		public static BinaryExpression Power(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression And(Expression left, Expression right){}
		public static BinaryExpression And(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Or(Expression left, Expression right){}
		public static BinaryExpression Or(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression ExclusiveOr(Expression left, Expression right){}
		public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression LeftShift(Expression left, Expression right){}
		public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression RightShift(Expression left, Expression right){}
		public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression AndAlso(Expression left, Expression right){}
		public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method){}
		private static MethodInfo ConditionalBinaryCheck(string oper, Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression OrElse(Expression left, Expression right){}
		public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method){}
		public static BinaryExpression Equal(Expression left, Expression right){}
		public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression NotEqual(Expression left, Expression right){}
		public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression GreaterThan(Expression left, Expression right){}
		public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right){}
		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression LessThan(Expression left, Expression right){}
		public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression LessThanOrEqual(Expression left, Expression right){}
		public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method){}
		private static void CheckArray(Expression array){}
		public static BinaryExpression ArrayIndex(Expression array, Expression index){}
		public static BinaryExpression Coalesce(Expression left, Expression right){}
		private static BinaryExpression MakeCoalesce(Expression left, Expression right){}
		private static BinaryExpression MakeConvertedCoalesce(Expression left, Expression right, LambdaExpression conversion){}
		public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion){}
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right){}
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method){}
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion){}
		public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes){}
		public static MethodCallExpression ArrayIndex(Expression array, IEnumerable<Expression> indexes){}
		public static UnaryExpression ArrayLength(Expression array){}
		public static MemberAssignment Bind(MemberInfo member, Expression expression){}
		public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression){}
		public static MethodCallExpression Call(Expression instance, MethodInfo method){}
		public static MethodCallExpression Call(MethodInfo method, Expression[] arguments){}
		public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments){}
		public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable<Expression> arguments){}
		private static Type[] CollectTypes(IEnumerable<Expression> expressions){}
		private static MethodInfo TryMakeGeneric(MethodInfo method, Type[] args){}
		public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments){}
		private static bool MethodMatch(MethodInfo method, string name, Type[] parameterTypes, Type[] argumentTypes){}
		private static bool IsExpressionOfParameter(Type type, Type ptype){}
		private static MethodInfo TryGetMethod(Type type, string methodName, BindingFlags flags, Type[] parameterTypes, Type[] argumentTypes){}
		public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments){}
		public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse){}
		public static ConstantExpression Constant(System.Object value){}
		public static ConstantExpression Constant(System.Object value, Type type){}
		private static bool IsConvertiblePrimitive(Type type){}
		internal static bool IsPrimitiveConversion(Type type, Type target){}
		internal static bool IsReferenceConversion(Type type, Type target){}
		public static UnaryExpression Convert(Expression expression, Type type){}
		private static MethodInfo GetUserConversionMethod(Type type, Type target){}
		public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method){}
		private static bool IsConvertNodeLifted(MethodInfo method, Expression operand, Type target){}
		private static bool ParameterMatch(MethodInfo method, Type type){}
		private static bool ReturnTypeMatch(MethodInfo method, Type type){}
		public static UnaryExpression ConvertChecked(Expression expression, Type type){}
		public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method){}
		public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments){}
		public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable<Expression> arguments){}
		public static MemberExpression Field(Expression expression, FieldInfo field){}
		public static MemberExpression Field(Expression expression, string fieldName){}
		public static Type GetActionType(Type[] typeArgs){}
		public static Type GetFuncType(Type[] typeArgs){}
		public static InvocationExpression Invoke(Expression expression, Expression[] arguments){}
		private static Type GetInvokableType(Type t){}
		private static Type GetGenericType(Type t, Type def){}
		public static InvocationExpression Invoke(Expression expression, IEnumerable<Expression> arguments){}
		private static bool CanAssign(Type target, Type source){}
		private static Expression CheckLambda(Type delegateType, Expression body, ReadOnlyCollection<ParameterExpression> parameters){}
		public static Expression<TDelegate> Lambda(Expression body, ParameterExpression[] parameters){}
		public static Expression<TDelegate> Lambda(Expression body, IEnumerable<ParameterExpression> parameters){}
		public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters){}
		private static Type GetDelegateType(Type return_type, ParameterExpression[] parameters){}
		public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters){}
		private static LambdaExpression CreateExpressionOf(Type type, Expression body, ReadOnlyCollection<ParameterExpression> parameters){}
		public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable<ParameterExpression> parameters){}
		public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers){}
		private static void CheckIsAssignableToIEnumerable(Type t){}
		public static MemberListBinding ListBind(MemberInfo member, IEnumerable<ElementInit> initializers){}
		public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers){}
		protected Expression(ExpressionType node_type, Type type){}
		public ExpressionType NodeType{ get	{} }
		public Type Type{ get	{} }
		private ExpressionType node_type;
		private Type type;
		private static Func<Expression, Type> <>f__am$cache2;
		private static Func<ParameterExpression, Type> <>f__am$cache3;
		private static Action<FieldInfo> <>f__am$cache4;
		private static Action<PropertyInfo> <>f__am$cache5;
		private static Func<FieldInfo, Type> <>f__am$cache6;
		private static Func<PropertyInfo, Type> <>f__am$cache7;
		private static Func<Type, Boolean> <>f__am$cache8;
		private static Func<Type, Boolean> <>f__am$cache9;
		private static Func<Type, Boolean> <>f__am$cacheA;
		private static Func<Type, Boolean> <>f__am$cacheB;
		internal const BindingFlags PublicInstance = null;
		internal const BindingFlags NonPublicInstance = null;
		internal const BindingFlags PublicStatic = null;
		internal const BindingFlags AllInstance = null;
		internal const BindingFlags AllStatic = null;
		internal const BindingFlags All = null;
	}

	public sealed class	BinaryExpression: Expression
	{
		private void EmitArrayAccess(EmitContext ec){}
		private void EmitLogicalBinary(EmitContext ec){}
		private void EmitLogical(EmitContext ec){}
		private void EmitLiftedLogical(EmitContext ec){}
		private void EmitLogicalShortCircuit(EmitContext ec){}
		private MethodInfo GetFalseOperator(){}
		private MethodInfo GetTrueOperator(){}
		private void EmitUserDefinedLogicalShortCircuit(EmitContext ec){}
		private void EmitLiftedLogicalShortCircuit(EmitContext ec){}
		private void EmitCoalesce(EmitContext ec){}
		private void EmitConvertedCoalesce(EmitContext ec){}
		private static bool IsInt32OrInt64(Type type){}
		private static bool IsSingleOrDouble(Type type){}
		private void EmitBinaryOperator(EmitContext ec){}
		private bool IsLeftLiftedBinary(){}
		private void EmitLeftLiftedToNullBinary(EmitContext ec){}
		private void EmitLiftedArithmeticBinary(EmitContext ec){}
		private void EmitLiftedToNullBinary(EmitContext ec){}
		private void EmitLiftedRelationalBinary(EmitContext ec){}
		private void EmitArithmeticBinary(EmitContext ec){}
		private void EmitNonLiftedBinary(EmitContext ec){}
		private void EmitRelationalBinary(EmitContext ec){}
		private void EmitLiftedUserDefinedOperator(EmitContext ec){}
		private void EmitLiftedToNullUserDefinedOperator(EmitContext ec){}
		private void EmitUserDefinedLiftedLogicalShortCircuit(EmitContext ec){}
		private void EmitUserDefinedOperator(EmitContext ec){}
		internal virtual void Emit(EmitContext ec){}
		internal BinaryExpression(ExpressionType node_type, Type type, Expression left, Expression right){}
		internal BinaryExpression(ExpressionType node_type, Type type, Expression left, Expression right, MethodInfo method){}
		internal BinaryExpression(ExpressionType node_type, Type type, Expression left, Expression right, bool lift_to_null, bool is_lifted, MethodInfo method, LambdaExpression conversion){}
		public Expression Left{ get	{} }
		public Expression Right{ get	{} }
		public MethodInfo Method{ get	{} }
		public bool IsLifted{ get	{} }
		public bool IsLiftedToNull{ get	{} }
		public LambdaExpression Conversion{ get	{} }
		private Expression left;
		private Expression right;
		private LambdaExpression conversion;
		private MethodInfo method;
		private bool lift_to_null;
		private bool is_lifted;
	}

	public sealed class	ConditionalExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal ConditionalExpression(Expression test, Expression if_true, Expression if_false){}
		public Expression Test{ get	{} }
		public Expression IfTrue{ get	{} }
		public Expression IfFalse{ get	{} }
		private Expression test;
		private Expression if_true;
		private Expression if_false;
	}

	public sealed class	ConstantExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		private void EmitNullableConstant(EmitContext ec, Type type, System.Object value){}
		private void EmitConstant(EmitContext ec, Type type, System.Object value){}
		private void EmitIfNotNull(EmitContext ec, Action<EmitContext> emit){}
		internal ConstantExpression(System.Object value, Type type){}
		public System.Object Value{ get	{} }
		private System.Object value;
	}

	public sealed class	ElementInit: Object
	{
		public virtual string ToString(){}
		private void EmitPopIfNeeded(EmitContext ec){}
		internal void Emit(EmitContext ec, LocalBuilder local){}
		internal ElementInit(MethodInfo add_method, ReadOnlyCollection<Expression> arguments){}
		public MethodInfo AddMethod{ get	{} }
		public ReadOnlyCollection<Expression> Arguments{ get	{} }
		private MethodInfo add_method;
		private ReadOnlyCollection<Expression> arguments;
	}

	public sealed class	InvocationExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal InvocationExpression(Expression expression, Type type, ReadOnlyCollection<Expression> arguments){}
		public Expression Expression{ get	{} }
		public ReadOnlyCollection<Expression> Arguments{ get	{} }
		private Expression expression;
		private ReadOnlyCollection<Expression> arguments;
	}

	public sealed class	ListInitExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal ListInitExpression(NewExpression new_expression, ReadOnlyCollection<ElementInit> initializers){}
		public NewExpression NewExpression{ get	{} }
		public ReadOnlyCollection<ElementInit> Initializers{ get	{} }
		private NewExpression new_expression;
		private ReadOnlyCollection<ElementInit> initializers;
	}

	public sealed class	MemberAssignment: MemberBinding
	{
		internal virtual void Emit(EmitContext ec, LocalBuilder local){}
		private void EmitFieldAssignment(EmitContext ec, FieldInfo field, LocalBuilder local){}
		private void EmitPropertyAssignment(EmitContext ec, PropertyInfo property, LocalBuilder local){}
		internal MemberAssignment(MemberInfo member, Expression expression){}
		public Expression Expression{ get	{} }
		private Expression expression;
	}

	public abstract	class	MemberBinding: Object
	{
		public virtual string ToString(){}
		internal abstract virtual void Emit(EmitContext ec, LocalBuilder local);
		internal LocalBuilder EmitLoadMember(EmitContext ec, LocalBuilder local){}
		private LocalBuilder EmitLoadProperty(EmitContext ec, PropertyInfo property){}
		private LocalBuilder EmitLoadField(EmitContext ec, FieldInfo field){}
		protected MemberBinding(MemberBindingType binding_type, MemberInfo member){}
		public MemberBindingType BindingType{ get	{} }
		public MemberInfo Member{ get	{} }
		private MemberBindingType binding_type;
		private MemberInfo member;
	}

	public sealed class	MemberExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		private void EmitPropertyAccess(EmitContext ec, PropertyInfo property){}
		private void EmitFieldAccess(EmitContext ec, FieldInfo field){}
		internal MemberExpression(Expression expression, MemberInfo member, Type type){}
		public Expression Expression{ get	{} }
		public MemberInfo Member{ get	{} }
		private Expression expression;
		private MemberInfo member;
	}

	public sealed class	MemberInitExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal MemberInitExpression(NewExpression new_expression, ReadOnlyCollection<MemberBinding> bindings){}
		public NewExpression NewExpression{ get	{} }
		public ReadOnlyCollection<MemberBinding> Bindings{ get	{} }
		private NewExpression new_expression;
		private ReadOnlyCollection<MemberBinding> bindings;
	}

	public sealed class	MemberListBinding: MemberBinding
	{
		internal virtual void Emit(EmitContext ec, LocalBuilder local){}
		internal MemberListBinding(MemberInfo member, ReadOnlyCollection<ElementInit> initializers){}
		public ReadOnlyCollection<ElementInit> Initializers{ get	{} }
		private ReadOnlyCollection<ElementInit> initializers;
	}

	public sealed class	MemberMemberBinding: MemberBinding
	{
		internal virtual void Emit(EmitContext ec, LocalBuilder local){}
		internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection<MemberBinding> bindings){}
		public ReadOnlyCollection<MemberBinding> Bindings{ get	{} }
		private ReadOnlyCollection<MemberBinding> bindings;
	}

	public sealed class	MethodCallExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal MethodCallExpression(MethodInfo method, ReadOnlyCollection<Expression> arguments){}
		internal MethodCallExpression(Expression obj, MethodInfo method, ReadOnlyCollection<Expression> arguments){}
		public Expression Object{ get	{} }
		public MethodInfo Method{ get	{} }
		public ReadOnlyCollection<Expression> Arguments{ get	{} }
		private Expression obj;
		private MethodInfo method;
		private ReadOnlyCollection<Expression> arguments;
	}

	public sealed class	NewArrayExpression: Expression
	{
		private void EmitNewArrayInit(EmitContext ec, Type type){}
		private void EmitNewArrayBounds(EmitContext ec, Type type){}
		private static ConstructorInfo GetArrayConstructor(Type type, int rank){}
		private static Type[] CreateTypeParameters(int rank){}
		private static Type CreateArray(Type type, int rank){}
		internal virtual void Emit(EmitContext ec){}
		internal NewArrayExpression(ExpressionType et, Type type, ReadOnlyCollection<Expression> expressions){}
		public ReadOnlyCollection<Expression> Expressions{ get	{} }
		private ReadOnlyCollection<Expression> expressions;
	}

	public sealed class	NewExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		private static ConstructorInfo GetDefaultConstructor(Type type){}
		internal NewExpression(Type type, ReadOnlyCollection<Expression> arguments){}
		internal NewExpression(ConstructorInfo constructor, ReadOnlyCollection<Expression> arguments, ReadOnlyCollection<MemberInfo> members){}
		public ConstructorInfo Constructor{ get	{} }
		public ReadOnlyCollection<Expression> Arguments{ get	{} }
		public ReadOnlyCollection<MemberInfo> Members{ get	{} }
		private ConstructorInfo constructor;
		private ReadOnlyCollection<Expression> arguments;
		private ReadOnlyCollection<MemberInfo> members;
	}

	public sealed class	ParameterExpression: Expression
	{
		private void EmitLocalParameter(EmitContext ec, int position){}
		private void EmitHoistedLocal(EmitContext ec, int level, int position){}
		internal virtual void Emit(EmitContext ec){}
		internal ParameterExpression(Type type, string name){}
		public string Name{ get	{} }
		private string name;
	}

	public sealed class	TypeBinaryExpression: Expression
	{
		internal virtual void Emit(EmitContext ec){}
		internal TypeBinaryExpression(ExpressionType node_type, Expression expression, Type type_operand, Type type){}
		public Expression Expression{ get	{} }
		public Type TypeOperand{ get	{} }
		private Expression expression;
		private Type type_operand;
	}

	public sealed class	UnaryExpression: Expression
	{
		private void EmitArrayLength(EmitContext ec){}
		private void EmitTypeAs(EmitContext ec){}
		private void EmitLiftedUnary(EmitContext ec){}
		private void EmitUnaryOperator(EmitContext ec){}
		private void EmitConvert(EmitContext ec){}
		private void EmitConvertFromNullableToNullable(EmitContext ec){}
		private void EmitConvertToNullable(EmitContext ec){}
		private void EmitConvertFromNullable(EmitContext ec){}
		private bool IsBoxing(){}
		private void EmitBox(EmitContext ec){}
		private bool IsUnBoxing(){}
		private void EmitUnbox(EmitContext ec){}
		private void EmitCast(EmitContext ec){}
		private void EmitPrimitiveConversion(EmitContext ec, bool is_unsigned, OpCode signed, OpCode unsigned, OpCode signed_checked, OpCode unsigned_checked){}
		private void EmitPrimitiveConversion(EmitContext ec){}
		private void EmitPrimitiveConversion(EmitContext ec, Type from, Type to){}
		private void EmitArithmeticUnary(EmitContext ec){}
		private void EmitUserDefinedLiftedToNullOperator(EmitContext ec){}
		private void EmitUserDefinedLiftedOperator(EmitContext ec){}
		private void EmitUserDefinedOperator(EmitContext ec){}
		private void EmitQuote(EmitContext ec){}
		internal virtual void Emit(EmitContext ec){}
		internal UnaryExpression(ExpressionType node_type, Expression operand, Type type){}
		internal UnaryExpression(ExpressionType node_type, Expression operand, Type type, MethodInfo method, bool is_lifted){}
		public Expression Operand{ get	{} }
		public MethodInfo Method{ get	{} }
		public bool IsLifted{ get	{} }
		public bool IsLiftedToNull{ get	{} }
		private Expression operand;
		private MethodInfo method;
		private bool is_lifted;
	}

}

namespace System {
	public class	InvalidTimeZoneException: Exception, ISerializable, _Exception
	{
		public InvalidTimeZoneException(){}
		public InvalidTimeZoneException(string message){}
		public InvalidTimeZoneException(string message, Exception e){}
		protected InvalidTimeZoneException(SerializationInfo info, StreamingContext sc){}
	}

	public sealed class	TimeZoneInfo: Object, ISerializable, IDeserializationCallback, IEquatable<TimeZoneInfo>
	{
		public static void ClearCachedData(){}
		public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone){}
		public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone){}
		public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone){}
		public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId){}
		public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId){}
		public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId){}
		private DateTime ConvertTimeFromUtc(DateTime dateTime){}
		public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone){}
		public static DateTime ConvertTimeToUtc(DateTime dateTime){}
		public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone){}
		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName){}
		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules){}
		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime){}
		public sealed virtual bool Equals(TimeZoneInfo other){}
		public static TimeZoneInfo FindSystemTimeZoneById(string id){}
		private static TimeZoneInfo FindSystemTimeZoneByFileName(string id, string filepath){}
		public static TimeZoneInfo FromSerializedString(string source){}
		public AdjustmentRule[] GetAdjustmentRules(){}
		public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime){}
		public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset){}
		public virtual int GetHashCode(){}
		public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public static ReadOnlyCollection<TimeZoneInfo> GetSystemTimeZones(){}
		public TimeSpan GetUtcOffset(DateTime dateTime){}
		public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset){}
		public bool HasSameRules(TimeZoneInfo other){}
		public bool IsAmbiguousTime(DateTime dateTime){}
		public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset){}
		public bool IsDaylightSavingTime(DateTime dateTime){}
		public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset){}
		public bool IsInvalidTime(DateTime dateTime){}
		public sealed virtual void OnDeserialization(System.Object sender){}
		public string ToSerializedString(){}
		public virtual string ToString(){}
		private AdjustmentRule GetApplicableRule(DateTime dateTime){}
		private static DateTime TransitionPoint(TransitionTime transition, int year){}
		private static bool ValidTZFile(Byte[] buffer, int length){}
		private static int SwapInt32(int i){}
		private static int ReadBigEndianInt32(Byte[] buffer, int start){}
		private static TimeZoneInfo ParseTZBuffer(string id, Byte[] buffer, int length){}
		private static List<AdjustmentRule> ValidateRules(List<AdjustmentRule> adjustmentRules){}
		private static Dictionary<Int32, String> ParseAbbreviations(Byte[] buffer, int index, int count){}
		private static Dictionary<Int32, TimeType> ParseTimesTypes(Byte[] buffer, int index, int count, Dictionary<Int32, String> abbreviations){}
		private static List<KeyValuePair<DateTime, TimeType>> ParseTransitions(Byte[] buffer, int index, int count, Dictionary<Int32, TimeType> time_types){}
		private static DateTime DateTimeFromUnixTime(long unix_time){}
		private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime){}
		private static TimeZoneInfo(){}
		public TimeSpan BaseUtcOffset{ get	{} }
		public string DaylightName{ get	{} }
		public string DisplayName{ get	{} }
		public string Id{ get	{} }
		public static TimeZoneInfo Local{ get	{} }
		public string StandardName{ get	{} }
		public bool SupportsDaylightSavingTime{ get	{} }
		public static TimeZoneInfo Utc{ get	{} }
		string TimeZoneDirectory{ get	{} set	{} }
		private TimeSpan baseUtcOffset;
		private string daylightDisplayName;
		private string displayName;
		private string id;
		private string standardDisplayName;
		private bool disableDaylightSavingTime;
		private AdjustmentRule[] adjustmentRules;
		private static TimeZoneInfo local;
		private static TimeZoneInfo utc;
		private static string timeZoneDirectory;
		private static List<TimeZoneInfo> systemTimeZones;
		private const int BUFFER_SIZE = null;
	}

	public class	TimeZoneNotFoundException: Exception, ISerializable, _Exception
	{
		public TimeZoneNotFoundException(){}
		public TimeZoneNotFoundException(string message){}
		public TimeZoneNotFoundException(string message, Exception e){}
		protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext sc){}
	}

	delegate void Action();

	delegate void Action<T1, T2>(T1 arg1, T2 arg2);

	delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);

	delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);

	delegate TResult Func<TResult>();

	delegate TResult Func<T, TResult>(T arg1);

	delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);

	delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);

	delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);

}

namespace Mono.Security.Cryptography {
	public sealed class	KeyBuilder: Object
	{
		public static Byte[] Key(int size){}
		public static Byte[] IV(int size){}
		private KeyBuilder(){}
		RandomNumberGenerator Rng{ get	{} }
		private static RandomNumberGenerator rng;
	}

	public class	BlockProcessor: Object
	{
		protected virtual void Finalize(){}
		public void Initialize(){}
		public void Core(Byte[] rgb){}
		public void Core(Byte[] rgb, int ib, int cb){}
		public Byte[] Final(){}
		public BlockProcessor(ICryptoTransform transform){}
		public BlockProcessor(ICryptoTransform transform, int blockSize){}
		private ICryptoTransform transform;
		private Byte[] block;
		private int blockSize;
		private int blockCount;
	}

}

namespace System.Collections.Generic {
	public class	HashSet<T>: Object, ICollection<T>, IEnumerable<T>, IEnumerable, ISerializable, IDeserializationCallback
	{
		private sealed virtual IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator(){}
		private sealed virtual bool System.Collections.Generic.ICollection<T>.get_IsReadOnly(){}
		private sealed virtual void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int index){}
		private sealed virtual void System.Collections.Generic.ICollection<T>.Add(T item){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private void Init(int capacity, IEqualityComparer<T> comparer){}
		private void InitArrays(int size){}
		private bool SlotsContainsAt(int index, int hash, T item){}
		public void CopyTo(T[] array){}
		public sealed virtual void CopyTo(T[] array, int index){}
		public void CopyTo(T[] array, int index, int count){}
		private void Resize(){}
		private int GetLinkHashCode(int index){}
		private int GetItemHashCode(T item){}
		public bool Add(T item){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(T item){}
		public sealed virtual bool Remove(T item){}
		public int RemoveWhere(Predicate<T> predicate){}
		public void TrimExcess(){}
		public void IntersectWith(IEnumerable<T> other){}
		public void ExceptWith(IEnumerable<T> other){}
		public bool Overlaps(IEnumerable<T> other){}
		public bool SetEquals(IEnumerable<T> other){}
		public void SymmetricExceptWith(IEnumerable<T> other){}
		public void UnionWith(IEnumerable<T> other){}
		private bool CheckIsSubsetOf(IEnumerable<T> other){}
		public bool IsSubsetOf(IEnumerable<T> other){}
		public bool IsProperSubsetOf(IEnumerable<T> other){}
		private bool CheckIsSupersetOf(IEnumerable<T> other){}
		public bool IsSupersetOf(IEnumerable<T> other){}
		public bool IsProperSupersetOf(IEnumerable<T> other){}
		public static IEqualityComparer<HashSet<T>> CreateSetComparer(){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void OnDeserialization(System.Object sender){}
		public Enumerator<T> GetEnumerator(){}
		public HashSet(){}
		public HashSet(IEqualityComparer<T> comparer){}
		public HashSet(IEnumerable<T> collection){}
		public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer){}
		protected HashSet(SerializationInfo info, StreamingContext context){}
		bool System.Collections.Generic.ICollection<T>.IsReadOnly{ get	{} }
		public sealed virtual int Count{ get	{} }
		public IEqualityComparer<T> Comparer{ get	{} }
		private Int32[] table;
		private Link[] links;
		private T[] slots;
		private int touched;
		private int empty_slot;
		private int count;
		private int threshold;
		private IEqualityComparer<T> comparer;
		private SerializationInfo si;
		private int generation;
		private const int INITIAL_SIZE = null;
		private const float DEFAULT_LOAD_FACTOR = null;
		private const int NO_SLOT = null;
		private const int HASH_FLAG = null;
	}

}

namespace System.Linq {
	public sealed abstract	class	Enumerable: Object
	{
		public static IEnumerable<TSource> Union(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		private static IEnumerable<TSource> CreateUnionIterator(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		public static IEnumerable<TSource> Where(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		private static IEnumerable<TSource> CreateWhereIterator(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static IEnumerable<TSource> Where(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		private static IEnumerable<TSource> CreateWhereIterator(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		internal static ReadOnlyCollection<TSource> ToReadOnlyCollection(IEnumerable<TSource> source){}
		private static long <Average>m__14(long a, int b){}
		private static double <Average>m__15(long a, long b){}
		private static long <Average>m__16(long a, long b){}
		private static double <Average>m__17(long a, long b){}
		private static double <Average>m__18(double a, double b){}
		private static double <Average>m__19(double a, long b){}
		private static double <Average>m__1A(double a, float b){}
		private static float <Average>m__1B(double a, long b){}
		private static decimal <Average>m__1C(decimal a, decimal b){}
		private static decimal <Average>m__1D(decimal a, long b){}
		private static long <Average>m__1E(long a, int b){}
		private static double <Average>m__1F(long a, long b){}
		private static long <Average>m__20(long a, long b){}
		private static double <Average>m__21(long a, long b){}
		private static double <Average>m__22(double a, double b){}
		private static double <Average>m__23(double a, long b){}
		private static decimal <Average>m__24(decimal a, decimal b){}
		private static decimal <Average>m__25(decimal a, long b){}
		private static double <Average>m__26(double a, float b){}
		private static float <Average>m__27(double a, long b){}
		private static long <Average`1>m__28(long a, int b){}
		private static double <Average`1>m__29(long a, long b){}
		private static long <Average`1>m__2A(long a, int b){}
		private static double <Average`1>m__2B(long a, long b){}
		private static long <Average`1>m__2C(long a, long b){}
		private static double <Average`1>m__2D(long a, long b){}
		private static long <Average`1>m__2E(long a, long b){}
		private static double <Average`1>m__2F(long a, long b){}
		private static double <Average`1>m__30(double a, double b){}
		private static double <Average`1>m__31(double a, long b){}
		private static double <Average`1>m__32(double a, double b){}
		private static double <Average`1>m__33(double a, long b){}
		private static double <Average`1>m__34(double a, float b){}
		private static float <Average`1>m__35(double a, long b){}
		private static double <Average`1>m__36(double a, float b){}
		private static float <Average`1>m__37(double a, long b){}
		private static decimal <Average`1>m__38(decimal a, decimal b){}
		private static decimal <Average`1>m__39(decimal a, long b){}
		private static decimal <Average`1>m__3A(decimal a, decimal b){}
		private static decimal <Average`1>m__3B(decimal a, long b){}
		private static int <Max>m__3C(int a, int b){}
		private static long <Max>m__3D(long a, long b){}
		private static double <Max>m__3E(double a, double b){}
		private static float <Max>m__3F(float a, float b){}
		private static decimal <Max>m__40(decimal a, decimal b){}
		private static int <Max>m__41(int a, int b){}
		private static long <Max>m__42(long a, long b){}
		private static double <Max>m__43(double a, double b){}
		private static float <Max>m__44(float a, float b){}
		private static decimal <Max>m__45(decimal a, decimal b){}
		private static bool <Max`1>m__4C(Nullable<Int32> a, Nullable<Int32> b){}
		private static bool <Max`1>m__4D(Nullable<Int64> a, Nullable<Int64> b){}
		private static bool <Max`1>m__4E(Nullable<Double> a, Nullable<Double> b){}
		private static bool <Max`1>m__4F(Nullable<Single> a, Nullable<Single> b){}
		private static bool <Max`1>m__50(Nullable<Decimal> a, Nullable<Decimal> b){}
		private static int <Min>m__51(int a, int b){}
		private static long <Min>m__52(long a, long b){}
		private static double <Min>m__53(double a, double b){}
		private static float <Min>m__54(float a, float b){}
		private static decimal <Min>m__55(decimal a, decimal b){}
		private static int <Min>m__56(int a, int b){}
		private static long <Min>m__57(long a, long b){}
		private static double <Min>m__58(double a, double b){}
		private static float <Min>m__59(float a, float b){}
		private static decimal <Min>m__5A(decimal a, decimal b){}
		private static bool <Min`1>m__61(Nullable<Int32> a, Nullable<Int32> b){}
		private static bool <Min`1>m__62(Nullable<Int64> a, Nullable<Int64> b){}
		private static bool <Min`1>m__63(Nullable<Single> a, Nullable<Single> b){}
		private static bool <Min`1>m__64(Nullable<Double> a, Nullable<Double> b){}
		private static bool <Min`1>m__65(Nullable<Decimal> a, Nullable<Decimal> b){}
		private static int <Sum>m__66(int a, int b){}
		private static Nullable<Int32> <Sum>m__67(Nullable<Int32> total, Nullable<Int32> element){}
		private static long <Sum>m__69(long a, long b){}
		private static Nullable<Int64> <Sum>m__6A(Nullable<Int64> total, Nullable<Int64> element){}
		private static double <Sum>m__6C(double a, double b){}
		private static Nullable<Double> <Sum>m__6D(Nullable<Double> total, Nullable<Double> element){}
		private static float <Sum>m__6F(float a, float b){}
		private static Nullable<Single> <Sum>m__70(Nullable<Single> total, Nullable<Single> element){}
		private static decimal <Sum>m__72(decimal a, decimal b){}
		private static Nullable<Decimal> <Sum>m__73(Nullable<Decimal> total, Nullable<Decimal> element){}
		private static TSource <ToLookup`2>m__75(TSource element){}
		private static IEnumerable<TSource> CreateReverseIterator(IEnumerable<TSource> source){}
		public static IEnumerable<TResult> Select(IEnumerable<TSource> source, Func<TSource, TResult> selector){}
		private static IEnumerable<TResult> CreateSelectIterator(IEnumerable<TSource> source, Func<TSource, TResult> selector){}
		public static IEnumerable<TResult> Select(IEnumerable<TSource> source, Func<TSource, Int32, TResult> selector){}
		private static IEnumerable<TResult> CreateSelectIterator(IEnumerable<TSource> source, Func<TSource, Int32, TResult> selector){}
		public static IEnumerable<TResult> SelectMany(IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector){}
		private static IEnumerable<TResult> CreateSelectManyIterator(IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector){}
		public static IEnumerable<TResult> SelectMany(IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TResult>> selector){}
		private static IEnumerable<TResult> CreateSelectManyIterator(IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TResult>> selector){}
		public static IEnumerable<TResult> SelectMany(IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> selector){}
		private static IEnumerable<TResult> CreateSelectManyIterator(IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> selector){}
		public static IEnumerable<TResult> SelectMany(IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> selector){}
		private static IEnumerable<TResult> CreateSelectManyIterator(IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> selector){}
		private static TSource Single(IEnumerable<TSource> source, Func<TSource, Boolean> predicate, Fallback fallback){}
		public static TSource Single(IEnumerable<TSource> source){}
		public static TSource Single(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static TSource SingleOrDefault(IEnumerable<TSource> source){}
		public static TSource SingleOrDefault(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static IEnumerable<TSource> Skip(IEnumerable<TSource> source, int count){}
		private static IEnumerable<TSource> CreateSkipIterator(IEnumerable<TSource> source, int count){}
		public static IEnumerable<TSource> SkipWhile(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		private static IEnumerable<TSource> CreateSkipWhileIterator(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static IEnumerable<TSource> SkipWhile(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		private static IEnumerable<TSource> CreateSkipWhileIterator(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		public static int Sum(IEnumerable<Int32> source){}
		public static Nullable<Int32> Sum(IEnumerable<Nullable<Int32>> source){}
		public static int Sum(IEnumerable<TSource> source, Func<TSource, Int32> selector){}
		public static Nullable<Int32> Sum(IEnumerable<TSource> source, Func<TSource, Nullable<Int32>> selector){}
		public static long Sum(IEnumerable<Int64> source){}
		public static Nullable<Int64> Sum(IEnumerable<Nullable<Int64>> source){}
		public static long Sum(IEnumerable<TSource> source, Func<TSource, Int64> selector){}
		public static Nullable<Int64> Sum(IEnumerable<TSource> source, Func<TSource, Nullable<Int64>> selector){}
		public static double Sum(IEnumerable<Double> source){}
		public static Nullable<Double> Sum(IEnumerable<Nullable<Double>> source){}
		public static double Sum(IEnumerable<TSource> source, Func<TSource, Double> selector){}
		public static Nullable<Double> Sum(IEnumerable<TSource> source, Func<TSource, Nullable<Double>> selector){}
		public static float Sum(IEnumerable<Single> source){}
		public static Nullable<Single> Sum(IEnumerable<Nullable<Single>> source){}
		public static float Sum(IEnumerable<TSource> source, Func<TSource, Single> selector){}
		public static Nullable<Single> Sum(IEnumerable<TSource> source, Func<TSource, Nullable<Single>> selector){}
		public static decimal Sum(IEnumerable<Decimal> source){}
		public static Nullable<Decimal> Sum(IEnumerable<Nullable<Decimal>> source){}
		public static decimal Sum(IEnumerable<TSource> source, Func<TSource, Decimal> selector){}
		public static Nullable<Decimal> Sum(IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector){}
		private static TR Sum(IEnumerable<TA> source, Func<TR, TA, TR> selector){}
		private static TR SumNullable(IEnumerable<TA> source, TR zero, Func<TR, TA, TR> selector){}
		public static IEnumerable<TSource> Take(IEnumerable<TSource> source, int count){}
		private static IEnumerable<TSource> CreateTakeIterator(IEnumerable<TSource> source, int count){}
		public static IEnumerable<TSource> TakeWhile(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		private static IEnumerable<TSource> CreateTakeWhileIterator(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static IEnumerable<TSource> TakeWhile(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		private static IEnumerable<TSource> CreateTakeWhileIterator(IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate){}
		public static IOrderedEnumerable<TSource> ThenBy(IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static IOrderedEnumerable<TSource> ThenBy(IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer){}
		public static IOrderedEnumerable<TSource> ThenByDescending(IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static IOrderedEnumerable<TSource> ThenByDescending(IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer){}
		public static TSource[] ToArray(IEnumerable<TSource> source){}
		public static Dictionary<TKey, TElement> ToDictionary(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector){}
		public static Dictionary<TKey, TElement> ToDictionary(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer){}
		public static Dictionary<TKey, TSource> ToDictionary(IEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static Dictionary<TKey, TSource> ToDictionary(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer){}
		public static List<TSource> ToList(IEnumerable<TSource> source){}
		public static ILookup<TKey, TSource> ToLookup(IEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static ILookup<TKey, TSource> ToLookup(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer){}
		public static ILookup<TKey, TElement> ToLookup(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector){}
		public static ILookup<TKey, TElement> ToLookup(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer){}
		public static bool SequenceEqual(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		public static bool SequenceEqual(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		public static IEnumerable<TSource> Union(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		public static IEnumerable<TResult> GroupJoin(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<TResult> CreateGroupJoinIterator(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<TSource> Intersect(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		public static IEnumerable<TSource> Intersect(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		private static IEnumerable<TSource> CreateIntersectIterator(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		public static IEnumerable<TResult> Join(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<TResult> CreateJoinIterator(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<TResult> Join(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector){}
		private static TSource Last(IEnumerable<TSource> source, Func<TSource, Boolean> predicate, Fallback fallback){}
		public static TSource Last(IEnumerable<TSource> source){}
		public static TSource Last(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static TSource LastOrDefault(IEnumerable<TSource> source){}
		public static TSource LastOrDefault(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static long LongCount(IEnumerable<TSource> source){}
		public static long LongCount(IEnumerable<TSource> source, Func<TSource, Boolean> selector){}
		public static int Max(IEnumerable<Int32> source){}
		public static long Max(IEnumerable<Int64> source){}
		public static double Max(IEnumerable<Double> source){}
		public static float Max(IEnumerable<Single> source){}
		public static decimal Max(IEnumerable<Decimal> source){}
		public static Nullable<Int32> Max(IEnumerable<Nullable<Int32>> source){}
		public static Nullable<Int64> Max(IEnumerable<Nullable<Int64>> source){}
		public static Nullable<Double> Max(IEnumerable<Nullable<Double>> source){}
		public static Nullable<Single> Max(IEnumerable<Nullable<Single>> source){}
		public static Nullable<Decimal> Max(IEnumerable<Nullable<Decimal>> source){}
		private static Nullable<T> IterateNullable(IEnumerable<Nullable<T>> source, Func<T, T, T> selector){}
		private static Nullable<TRet> IterateNullable(IEnumerable<TSource> source, Func<TSource, Nullable<TRet>> source_selector, Func<Nullable<TRet>, Nullable<TRet>, Boolean> selector){}
		private static TSource IterateNullable(IEnumerable<TSource> source, Func<TSource, TSource, Boolean> selector){}
		private static TSource IterateNonNullable(IEnumerable<TSource> source, Func<TSource, TSource, Boolean> selector){}
		public static TSource Max(IEnumerable<TSource> source){}
		public static int Max(IEnumerable<TSource> source, Func<TSource, Int32> selector){}
		public static long Max(IEnumerable<TSource> source, Func<TSource, Int64> selector){}
		public static double Max(IEnumerable<TSource> source, Func<TSource, Double> selector){}
		public static float Max(IEnumerable<TSource> source, Func<TSource, Single> selector){}
		public static decimal Max(IEnumerable<TSource> source, Func<TSource, Decimal> selector){}
		private static U Iterate(IEnumerable<T> source, U initValue, Func<T, U, U> selector){}
		public static Nullable<Int32> Max(IEnumerable<TSource> source, Func<TSource, Nullable<Int32>> selector){}
		public static Nullable<Int64> Max(IEnumerable<TSource> source, Func<TSource, Nullable<Int64>> selector){}
		public static Nullable<Double> Max(IEnumerable<TSource> source, Func<TSource, Nullable<Double>> selector){}
		public static Nullable<Single> Max(IEnumerable<TSource> source, Func<TSource, Nullable<Single>> selector){}
		public static Nullable<Decimal> Max(IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector){}
		public static TResult Max(IEnumerable<TSource> source, Func<TSource, TResult> selector){}
		public static int Min(IEnumerable<Int32> source){}
		public static long Min(IEnumerable<Int64> source){}
		public static double Min(IEnumerable<Double> source){}
		public static float Min(IEnumerable<Single> source){}
		public static decimal Min(IEnumerable<Decimal> source){}
		public static Nullable<Int32> Min(IEnumerable<Nullable<Int32>> source){}
		public static Nullable<Int64> Min(IEnumerable<Nullable<Int64>> source){}
		public static Nullable<Double> Min(IEnumerable<Nullable<Double>> source){}
		public static Nullable<Single> Min(IEnumerable<Nullable<Single>> source){}
		public static Nullable<Decimal> Min(IEnumerable<Nullable<Decimal>> source){}
		public static TSource Min(IEnumerable<TSource> source){}
		public static int Min(IEnumerable<TSource> source, Func<TSource, Int32> selector){}
		public static long Min(IEnumerable<TSource> source, Func<TSource, Int64> selector){}
		public static double Min(IEnumerable<TSource> source, Func<TSource, Double> selector){}
		public static float Min(IEnumerable<TSource> source, Func<TSource, Single> selector){}
		public static decimal Min(IEnumerable<TSource> source, Func<TSource, Decimal> selector){}
		public static Nullable<Int32> Min(IEnumerable<TSource> source, Func<TSource, Nullable<Int32>> selector){}
		public static Nullable<Int64> Min(IEnumerable<TSource> source, Func<TSource, Nullable<Int64>> selector){}
		public static Nullable<Single> Min(IEnumerable<TSource> source, Func<TSource, Nullable<Single>> selector){}
		public static Nullable<Double> Min(IEnumerable<TSource> source, Func<TSource, Nullable<Double>> selector){}
		public static Nullable<Decimal> Min(IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector){}
		public static TResult Min(IEnumerable<TSource> source, Func<TSource, TResult> selector){}
		public static IEnumerable<TResult> OfType(IEnumerable source){}
		private static IEnumerable<TResult> CreateOfTypeIterator(IEnumerable source){}
		public static IOrderedEnumerable<TSource> OrderBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static IOrderedEnumerable<TSource> OrderBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer){}
		public static IOrderedEnumerable<TSource> OrderByDescending(IEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static IOrderedEnumerable<TSource> OrderByDescending(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer){}
		public static IEnumerable<Int32> Range(int start, int count){}
		private static IEnumerable<Int32> CreateRangeIterator(int start, int upto){}
		public static IEnumerable<TResult> Repeat(TResult element, int count){}
		private static IEnumerable<TResult> CreateRepeatIterator(TResult element, int count){}
		public static IEnumerable<TSource> Reverse(IEnumerable<TSource> source){}
		public static TSource Aggregate(IEnumerable<TSource> source, Func<TSource, TSource, TSource> func){}
		public static TAccumulate Aggregate(IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func){}
		public static TResult Aggregate(IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector){}
		public static bool All(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static bool Any(IEnumerable<TSource> source){}
		public static bool Any(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static IEnumerable<TSource> AsEnumerable(IEnumerable<TSource> source){}
		public static double Average(IEnumerable<Int32> source){}
		public static double Average(IEnumerable<Int64> source){}
		public static double Average(IEnumerable<Double> source){}
		public static float Average(IEnumerable<Single> source){}
		public static decimal Average(IEnumerable<Decimal> source){}
		private static TResult Average(IEnumerable<TElement> source, Func<TAggregate, TElement, TAggregate> func, Func<TAggregate, Int64, TResult> result){}
		private static Nullable<TResult> AverageNullable(IEnumerable<Nullable<TElement>> source, Func<TAggregate, TElement, TAggregate> func, Func<TAggregate, Int64, TResult> result){}
		public static Nullable<Double> Average(IEnumerable<Nullable<Int32>> source){}
		public static Nullable<Double> Average(IEnumerable<Nullable<Int64>> source){}
		public static Nullable<Double> Average(IEnumerable<Nullable<Double>> source){}
		public static Nullable<Decimal> Average(IEnumerable<Nullable<Decimal>> source){}
		public static Nullable<Single> Average(IEnumerable<Nullable<Single>> source){}
		public static double Average(IEnumerable<TSource> source, Func<TSource, Int32> selector){}
		public static Nullable<Double> Average(IEnumerable<TSource> source, Func<TSource, Nullable<Int32>> selector){}
		public static double Average(IEnumerable<TSource> source, Func<TSource, Int64> selector){}
		public static Nullable<Double> Average(IEnumerable<TSource> source, Func<TSource, Nullable<Int64>> selector){}
		public static double Average(IEnumerable<TSource> source, Func<TSource, Double> selector){}
		public static Nullable<Double> Average(IEnumerable<TSource> source, Func<TSource, Nullable<Double>> selector){}
		public static float Average(IEnumerable<TSource> source, Func<TSource, Single> selector){}
		public static Nullable<Single> Average(IEnumerable<TSource> source, Func<TSource, Nullable<Single>> selector){}
		public static decimal Average(IEnumerable<TSource> source, Func<TSource, Decimal> selector){}
		public static Nullable<Decimal> Average(IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector){}
		public static IEnumerable<TResult> Cast(IEnumerable source){}
		private static IEnumerable<TResult> CreateCastIterator(IEnumerable source){}
		public static IEnumerable<TSource> Concat(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		private static IEnumerable<TSource> CreateConcatIterator(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		public static bool Contains(IEnumerable<TSource> source, TSource value){}
		public static bool Contains(IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer){}
		public static int Count(IEnumerable<TSource> source){}
		public static int Count(IEnumerable<TSource> source, Func<TSource, Boolean> selector){}
		public static IEnumerable<TSource> DefaultIfEmpty(IEnumerable<TSource> source){}
		public static IEnumerable<TSource> DefaultIfEmpty(IEnumerable<TSource> source, TSource defaultValue){}
		private static IEnumerable<TSource> CreateDefaultIfEmptyIterator(IEnumerable<TSource> source, TSource defaultValue){}
		public static IEnumerable<TSource> Distinct(IEnumerable<TSource> source){}
		public static IEnumerable<TSource> Distinct(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer){}
		private static IEnumerable<TSource> CreateDistinctIterator(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer){}
		private static TSource ElementAt(IEnumerable<TSource> source, int index, Fallback fallback){}
		public static TSource ElementAt(IEnumerable<TSource> source, int index){}
		public static TSource ElementAtOrDefault(IEnumerable<TSource> source, int index){}
		public static IEnumerable<TResult> Empty(){}
		public static IEnumerable<TSource> Except(IEnumerable<TSource> first, IEnumerable<TSource> second){}
		public static IEnumerable<TSource> Except(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		private static IEnumerable<TSource> CreateExceptIterator(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer){}
		private static TSource First(IEnumerable<TSource> source, Func<TSource, Boolean> predicate, Fallback fallback){}
		public static TSource First(IEnumerable<TSource> source){}
		public static TSource First(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		public static TSource FirstOrDefault(IEnumerable<TSource> source){}
		public static TSource FirstOrDefault(IEnumerable<TSource> source, Func<TSource, Boolean> predicate){}
		private static List<T> ContainsGroup(Dictionary<K, List<T>> items, K key, IEqualityComparer<K> comparer){}
		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector){}
		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<IGrouping<TKey, TSource>> CreateGroupByIterator(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector){}
		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<IGrouping<TKey, TElement>> CreateGroupByIterator(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<TResult> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector){}
		public static IEnumerable<TResult> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<TResult> CreateGroupByIterator(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<TResult> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector){}
		public static IEnumerable<TResult> GroupBy(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		private static IEnumerable<TResult> CreateGroupByIterator(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IEnumerable<TResult> GroupJoin(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector){}
		private static Func<Int64, Int32, Int64> <>f__am$cache0;
		private static Func<Int64, Int64, Double> <>f__am$cache1;
		private static Func<Int64, Int64, Int64> <>f__am$cache2;
		private static Func<Int64, Int64, Double> <>f__am$cache3;
		private static Func<Double, Double, Double> <>f__am$cache4;
		private static Func<Double, Int64, Double> <>f__am$cache5;
		private static Func<Double, Single, Double> <>f__am$cache6;
		private static Func<Double, Int64, Single> <>f__am$cache7;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache8;
		private static Func<Decimal, Int64, Decimal> <>f__am$cache9;
		private static Func<Int64, Int32, Int64> <>f__am$cacheA;
		private static Func<Int64, Int64, Double> <>f__am$cacheB;
		private static Func<Int64, Int64, Int64> <>f__am$cacheC;
		private static Func<Int64, Int64, Double> <>f__am$cacheD;
		private static Func<Double, Double, Double> <>f__am$cacheE;
		private static Func<Double, Int64, Double> <>f__am$cacheF;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache10;
		private static Func<Decimal, Int64, Decimal> <>f__am$cache11;
		private static Func<Double, Single, Double> <>f__am$cache12;
		private static Func<Double, Int64, Single> <>f__am$cache13;
		private static Func<Int32, Int32, Int32> <>f__am$cache14;
		private static Func<Int64, Int64, Int64> <>f__am$cache15;
		private static Func<Double, Double, Double> <>f__am$cache16;
		private static Func<Single, Single, Single> <>f__am$cache17;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache18;
		private static Func<Int32, Int32, Int32> <>f__am$cache19;
		private static Func<Int64, Int64, Int64> <>f__am$cache1A;
		private static Func<Double, Double, Double> <>f__am$cache1B;
		private static Func<Single, Single, Single> <>f__am$cache1C;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache1D;
		private static Func<Int32, Int32, Int32> <>f__am$cache1E;
		private static Func<Int64, Int64, Int64> <>f__am$cache1F;
		private static Func<Double, Double, Double> <>f__am$cache20;
		private static Func<Single, Single, Single> <>f__am$cache21;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache22;
		private static Func<Int32, Int32, Int32> <>f__am$cache23;
		private static Func<Int64, Int64, Int64> <>f__am$cache24;
		private static Func<Double, Double, Double> <>f__am$cache25;
		private static Func<Single, Single, Single> <>f__am$cache26;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache27;
		private static Func<Int32, Int32, Int32> <>f__am$cache28;
		private static Func<Nullable<Int32>, Nullable<Int32>, Nullable<Int32>> <>f__am$cache29;
		private static Func<Int64, Int64, Int64> <>f__am$cache2A;
		private static Func<Nullable<Int64>, Nullable<Int64>, Nullable<Int64>> <>f__am$cache2B;
		private static Func<Double, Double, Double> <>f__am$cache2C;
		private static Func<Nullable<Double>, Nullable<Double>, Nullable<Double>> <>f__am$cache2D;
		private static Func<Single, Single, Single> <>f__am$cache2E;
		private static Func<Nullable<Single>, Nullable<Single>, Nullable<Single>> <>f__am$cache2F;
		private static Func<Decimal, Decimal, Decimal> <>f__am$cache30;
		private static Func<Nullable<Decimal>, Nullable<Decimal>, Nullable<Decimal>> <>f__am$cache31;
	}

	public interface IGrouping<TKey, TElement>: IEnumerable, IEnumerable<TElement>
	{
		TKey Key{ get; }
	}

	public interface ILookup<TKey, TElement>: IEnumerable, IEnumerable<IGrouping<TKey, TElement>>
	{
		bool Contains(TKey key);
		int Count{ get; }
		IEnumerable<TElement> this[TKey key] { get; }
	}

	public interface IOrderedEnumerable<TElement>: IEnumerable, IEnumerable<TElement>
	{
		IOrderedEnumerable<TElement> CreateOrderedEnumerable(Func<TElement, TKey> selector, IComparer<TKey> comparer, bool descending);
	}

	public interface IOrderedQueryable: IEnumerable, IQueryable
	{
	}

	public interface IOrderedQueryable<T>: IEnumerable, IOrderedQueryable, IQueryable, IQueryable<T>, IEnumerable<T>
	{
	}

	public interface IQueryProvider	{
		IQueryable CreateQuery(Expression expression);
		System.Object Execute(Expression expression);
		IQueryable<TElement> CreateQuery(Expression expression);
		TResult Execute(Expression expression);
	}

	public interface IQueryable: IEnumerable
	{
		Type ElementType{ get; }
		Expression Expression{ get; }
		IQueryProvider Provider{ get; }
	}

	public interface IQueryable<T>: IEnumerable, IQueryable, IEnumerable<T>
	{
	}

	public class	Lookup<TKey, TElement>: Object, IEnumerable, IEnumerable<IGrouping<TKey, TElement>>, ILookup<TKey, TElement>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public IEnumerable<TResult> ApplyResultSelector(Func<TKey, IEnumerable<TElement>, TResult> selector){}
		public sealed virtual bool Contains(TKey key){}
		public sealed virtual IEnumerator<IGrouping<TKey, TElement>> GetEnumerator(){}
		internal Lookup(Dictionary<TKey, List<TElement>> lookup, IEnumerable<TElement> nullKeyElements){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual IEnumerable<TElement> this[TKey key] { get	{} }
		private IGrouping<TKey, TElement> nullGrouping;
		private Dictionary<TKey, IGrouping<TKey, TElement>> groups;
	}

	public sealed abstract	class	Queryable: Object
	{
		public static TResult Max(IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector){}
		public static TSource Min(IQueryable<TSource> source){}
		public static TResult Min(IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector){}
		public static IQueryable<TResult> OfType(IQueryable source){}
		public static IOrderedQueryable<TSource> OrderBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector){}
		public static IOrderedQueryable<TSource> OrderBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer){}
		public static IOrderedQueryable<TSource> OrderByDescending(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector){}
		public static IOrderedQueryable<TSource> OrderByDescending(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer){}
		public static IQueryable<TSource> Reverse(IQueryable<TSource> source){}
		public static IQueryable<TResult> Select(IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector){}
		public static IQueryable<TResult> Select(IQueryable<TSource> source, Expression<Func<TSource, Int32, TResult>> selector){}
		public static IQueryable<TResult> SelectMany(IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector){}
		public static IQueryable<TResult> SelectMany(IQueryable<TSource> source, Expression<Func<TSource, Int32, IEnumerable<TResult>>> selector){}
		public static IQueryable<TResult> SelectMany(IQueryable<TSource> source, Expression<Func<TSource, Int32, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector){}
		public static IQueryable<TResult> SelectMany(IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector){}
		public static bool SequenceEqual(IQueryable<TSource> source1, IEnumerable<TSource> source2){}
		public static bool SequenceEqual(IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer){}
		public static TSource Single(IQueryable<TSource> source){}
		public static TSource Single(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static TSource SingleOrDefault(IQueryable<TSource> source){}
		public static TSource SingleOrDefault(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TSource> Skip(IQueryable<TSource> source, int count){}
		public static IQueryable<TSource> SkipWhile(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TSource> SkipWhile(IQueryable<TSource> source, Expression<Func<TSource, Int32, Boolean>> predicate){}
		public static int Sum(IQueryable<TSource> source, Expression<Func<TSource, Int32>> selector){}
		public static Nullable<Int32> Sum(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Int32>>> selector){}
		public static long Sum(IQueryable<TSource> source, Expression<Func<TSource, Int64>> selector){}
		public static Nullable<Int64> Sum(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Int64>>> selector){}
		public static float Sum(IQueryable<TSource> source, Expression<Func<TSource, Single>> selector){}
		public static Nullable<Single> Sum(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Single>>> selector){}
		public static double Sum(IQueryable<TSource> source, Expression<Func<TSource, Double>> selector){}
		public static Nullable<Double> Sum(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Double>>> selector){}
		public static decimal Sum(IQueryable<TSource> source, Expression<Func<TSource, Decimal>> selector){}
		public static Nullable<Decimal> Sum(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Decimal>>> selector){}
		public static int Sum(IQueryable<Int32> source){}
		public static Nullable<Int32> Sum(IQueryable<Nullable<Int32>> source){}
		public static long Sum(IQueryable<Int64> source){}
		public static Nullable<Int64> Sum(IQueryable<Nullable<Int64>> source){}
		public static float Sum(IQueryable<Single> source){}
		public static Nullable<Single> Sum(IQueryable<Nullable<Single>> source){}
		public static double Sum(IQueryable<Double> source){}
		public static Nullable<Double> Sum(IQueryable<Nullable<Double>> source){}
		public static decimal Sum(IQueryable<Decimal> source){}
		public static Nullable<Decimal> Sum(IQueryable<Nullable<Decimal>> source){}
		public static IQueryable<TSource> Take(IQueryable<TSource> source, int count){}
		public static IQueryable<TSource> TakeWhile(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TSource> TakeWhile(IQueryable<TSource> source, Expression<Func<TSource, Int32, Boolean>> predicate){}
		public static IOrderedQueryable<TSource> ThenBy(IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector){}
		public static IOrderedQueryable<TSource> ThenBy(IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer){}
		public static IOrderedQueryable<TSource> ThenByDescending(IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector){}
		public static IOrderedQueryable<TSource> ThenByDescending(IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer){}
		public static IQueryable<TSource> Union(IQueryable<TSource> source1, IEnumerable<TSource> source2){}
		public static IQueryable<TSource> Union(IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer){}
		public static IQueryable<TSource> Where(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TSource> Where(IQueryable<TSource> source, Expression<Func<TSource, Int32, Boolean>> predicate){}
		private static MethodInfo MakeGeneric(MethodBase method, Type[] parameters){}
		private static Expression StaticCall(MethodInfo method, Expression[] expressions){}
		private static TRet Execute(IQueryable<TSource> source, MethodBase current){}
		public static TSource Aggregate(IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func){}
		public static TAccumulate Aggregate(IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func){}
		public static TResult Aggregate(IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector){}
		public static bool All(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static bool Any(IQueryable<TSource> source){}
		public static bool Any(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TElement> AsQueryable(IEnumerable<TElement> source){}
		public static IQueryable AsQueryable(IEnumerable source){}
		public static double Average(IQueryable<Int32> source){}
		public static Nullable<Double> Average(IQueryable<Nullable<Int32>> source){}
		public static double Average(IQueryable<Int64> source){}
		public static Nullable<Double> Average(IQueryable<Nullable<Int64>> source){}
		public static float Average(IQueryable<Single> source){}
		public static Nullable<Single> Average(IQueryable<Nullable<Single>> source){}
		public static double Average(IQueryable<Double> source){}
		public static Nullable<Double> Average(IQueryable<Nullable<Double>> source){}
		public static decimal Average(IQueryable<Decimal> source){}
		public static Nullable<Decimal> Average(IQueryable<Nullable<Decimal>> source){}
		public static double Average(IQueryable<TSource> source, Expression<Func<TSource, Int32>> selector){}
		public static Nullable<Double> Average(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Int32>>> selector){}
		public static double Average(IQueryable<TSource> source, Expression<Func<TSource, Int64>> selector){}
		public static Nullable<Double> Average(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Int64>>> selector){}
		public static float Average(IQueryable<TSource> source, Expression<Func<TSource, Single>> selector){}
		public static Nullable<Single> Average(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Single>>> selector){}
		public static double Average(IQueryable<TSource> source, Expression<Func<TSource, Double>> selector){}
		public static Nullable<Double> Average(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Double>>> selector){}
		public static decimal Average(IQueryable<TSource> source, Expression<Func<TSource, Decimal>> selector){}
		public static Nullable<Decimal> Average(IQueryable<TSource> source, Expression<Func<TSource, Nullable<Decimal>>> selector){}
		public static IQueryable<TResult> Cast(IQueryable source){}
		public static IQueryable<TSource> Concat(IQueryable<TSource> source1, IEnumerable<TSource> source2){}
		public static bool Contains(IQueryable<TSource> source, TSource item){}
		public static bool Contains(IQueryable<TSource> source, TSource item, IEqualityComparer<TSource> comparer){}
		public static int Count(IQueryable<TSource> source){}
		public static int Count(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<TSource> DefaultIfEmpty(IQueryable<TSource> source){}
		public static IQueryable<TSource> DefaultIfEmpty(IQueryable<TSource> source, TSource defaultValue){}
		public static IQueryable<TSource> Distinct(IQueryable<TSource> source){}
		public static IQueryable<TSource> Distinct(IQueryable<TSource> source, IEqualityComparer<TSource> comparer){}
		public static TSource ElementAt(IQueryable<TSource> source, int index){}
		public static TSource ElementAtOrDefault(IQueryable<TSource> source, int index){}
		public static IQueryable<TSource> Except(IQueryable<TSource> source1, IEnumerable<TSource> source2){}
		public static IQueryable<TSource> Except(IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer){}
		public static TSource First(IQueryable<TSource> source){}
		public static TSource First(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static TSource FirstOrDefault(IQueryable<TSource> source){}
		public static TSource FirstOrDefault(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static IQueryable<IGrouping<TKey, TSource>> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector){}
		public static IQueryable<IGrouping<TKey, TSource>> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey> comparer){}
		public static IQueryable<IGrouping<TKey, TElement>> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector){}
		public static IQueryable<TResult> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector){}
		public static IQueryable<IGrouping<TKey, TElement>> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey> comparer){}
		public static IQueryable<TResult> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector){}
		public static IQueryable<TResult> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IQueryable<TResult> GroupBy(IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IQueryable<TResult> GroupJoin(IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector){}
		public static IQueryable<TResult> GroupJoin(IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey> comparer){}
		public static IQueryable<TSource> Intersect(IQueryable<TSource> source1, IEnumerable<TSource> source2){}
		public static IQueryable<TSource> Intersect(IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer){}
		public static IQueryable<TResult> Join(IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector){}
		public static IQueryable<TResult> Join(IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey> comparer){}
		public static TSource Last(IQueryable<TSource> source){}
		public static TSource Last(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static TSource LastOrDefault(IQueryable<TSource> source){}
		public static TSource LastOrDefault(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static long LongCount(IQueryable<TSource> source){}
		public static long LongCount(IQueryable<TSource> source, Expression<Func<TSource, Boolean>> predicate){}
		public static TSource Max(IQueryable<TSource> source){}
	}

}

namespace System.Security.Cryptography {
	public abstract	class	Aes: SymmetricAlgorithm, IDisposable
	{
		public static Aes Create(){}
		public static Aes Create(string algName){}
		protected Aes(){}
	}

	public sealed class	AesManaged: Aes, IDisposable
	{
		public virtual void GenerateIV(){}
		public virtual void GenerateKey(){}
		public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV){}
		public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV){}
		public virtual ICryptoTransform CreateDecryptor(){}
		public virtual ICryptoTransform CreateEncryptor(){}
		protected virtual void Dispose(bool disposing){}
		public AesManaged(){}
		public virtual Byte[] IV{ get	{} set	{} }
		public virtual Byte[] Key{ get	{} set	{} }
		public virtual int KeySize{ get	{} set	{} }
	}

}

namespace System.Threading {
	public class	LockRecursionException: Exception, ISerializable, _Exception
	{
		public LockRecursionException(){}
		public LockRecursionException(string message){}
		public LockRecursionException(string message, Exception e){}
		protected LockRecursionException(SerializationInfo info, StreamingContext sc){}
	}

	public class	ReaderWriterLockSlim: Object, IDisposable
	{
		public void EnterReadLock(){}
		public bool TryEnterReadLock(int millisecondsTimeout){}
		public bool TryEnterReadLock(TimeSpan timeout){}
		public void ExitReadLock(){}
		public void EnterWriteLock(){}
		public bool TryEnterWriteLock(int millisecondsTimeout){}
		public bool TryEnterWriteLock(TimeSpan timeout){}
		public void ExitWriteLock(){}
		public void EnterUpgradeableReadLock(){}
		public bool TryEnterUpgradeableReadLock(int millisecondsTimeout){}
		public bool TryEnterUpgradeableReadLock(TimeSpan timeout){}
		public void ExitUpgradeableReadLock(){}
		public sealed virtual void Dispose(){}
		private void EnterMyLock(){}
		private void EnterMyLockSpin(){}
		private void ExitMyLock(){}
		private void ExitAndWakeUpAppropriateWaiters(){}
		private void LazyCreateEvent(ref EventWaitHandle waitEvent, bool makeAutoResetEvent){}
		private bool WaitOnEvent(EventWaitHandle waitEvent, ref uint numWaiters, int millisecondsTimeout){}
		private static int CheckTimeout(TimeSpan timeout){}
		private LockDetails GetReadLockDetails(int threadId, bool create){}
		public ReaderWriterLockSlim(){}
		public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy){}
		private static ReaderWriterLockSlim(){}
		public bool IsReadLockHeld{ get	{} }
		public bool IsWriteLockHeld{ get	{} }
		public bool IsUpgradeableReadLockHeld{ get	{} }
		public int CurrentReadCount{ get	{} }
		public int RecursiveReadCount{ get	{} }
		public int RecursiveUpgradeCount{ get	{} }
		public int RecursiveWriteCount{ get	{} }
		public int WaitingReadCount{ get	{} }
		public int WaitingUpgradeCount{ get	{} }
		public int WaitingWriteCount{ get	{} }
		public LockRecursionPolicy RecursionPolicy{ get	{} }
		bool MyLockHeld{ get	{} }
		private int myLock;
		private int owners;
		private Thread upgradable_thread;
		private Thread write_thread;
		private uint numWriteWaiters;
		private uint numReadWaiters;
		private uint numUpgradeWaiters;
		private EventWaitHandle writeEvent;
		private EventWaitHandle readEvent;
		private EventWaitHandle upgradeEvent;
		private readonly LockRecursionPolicy recursionPolicy;
		private LockDetails[] read_locks;
		private readonly static bool smp;
	}

}

