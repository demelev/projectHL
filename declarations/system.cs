// WARNING:Skipped nested type: System.Collections.Generic.RBTree+INodeHelper`1[T]
// WARNING:Skipped nested type: System.Collections.Generic.RBTree+Node
// WARNING:Skipped nested type: System.Collections.Generic.SortedDictionary`2+Node[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedDictionary`2+NodeHelper[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedDictionary`2+ValueCollection[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedDictionary`2+KeyCollection[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+Enumerator[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+ListKeys[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+ListValues[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+<IEnumerable.GetEnumerator>c__Iterator0[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+<GetEnumerator>c__Iterator1[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+ListKeys+<IEnumerable.GetEnumerator>c__Iterator2[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Generic.SortedList`2+ListValues+<IEnumerable.GetEnumerator>c__Iterator3[TKey,TValue]
// WARNING:Skipped nested type: System.Collections.Specialized.ListDictionary+DictionaryNode
// WARNING:Skipped nested type: System.Collections.Specialized.ListDictionary+DictionaryNodeEnumerator
// WARNING:Skipped nested type: System.Collections.Specialized.ListDictionary+DictionaryNodeCollection
// WARNING:Skipped nested type: System.Collections.Specialized.ListDictionary+DictionaryNodeCollection+DictionaryNodeCollectionEnumerator
// WARNING:Skipped nested type: System.Collections.Specialized.NameObjectCollectionBase+_Item
// WARNING:Skipped nested type: System.Collections.Specialized.NameObjectCollectionBase+_KeysEnumerator
// WARNING:Skipped nested type: System.Collections.Specialized.NameObjectCollectionBase+KeysCollection
// WARNING:Skipped nested type: System.Collections.Specialized.OrderedDictionary+OrderedEntryCollectionEnumerator
// WARNING:Skipped nested type: System.Collections.Specialized.OrderedDictionary+OrderedCollection
// WARNING:Skipped nested type: System.Collections.Specialized.OrderedDictionary+OrderedCollection+OrderedCollectionEnumerator
// WARNING:Skipped nested type: System.ComponentModel.ArrayConverter+ArrayPropertyDescriptor
// WARNING:Skipped nested type: System.ComponentModel.CultureInfoConverter+CultureInfoComparer
// WARNING:Skipped nested type: System.ComponentModel.EnumConverter+EnumComparer
// WARNING:Skipped nested type: System.ComponentModel.MemberDescriptor+MemberDescriptorComparer
// WARNING:Skipped nested type: System.ComponentModel.TypeConverter+StandardValuesCollection
// WARNING:Skipped nested type: System.ComponentModel.TypeConverter+SimplePropertyDescriptor
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptionProvider+EmptyCustomTypeDescriptor
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptor+AttributeProvider
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptor+AttributeProvider+AttributeTypeDescriptor
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptor+WrappedTypeDescriptionProvider
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptor+DefaultTypeDescriptor
// WARNING:Skipped nested type: System.ComponentModel.TypeDescriptor+DefaultTypeDescriptionProvider
// WARNING:Skipped nested type: System.Diagnostics.Process+ProcessAsyncReader
// WARNING:Skipped nested type: System.Diagnostics.Process+ProcessWaitHandle
// WARNING:Skipped nested type: System.IO.SearchPattern2+Op
// WARNING:Skipped nested type: System.IO.InotifyWatcher+<GetEnumerator>c__Iterator4
// WARNING:Skipped nested type: System.Net.Mail.AttachmentBase+MimeTypes
// WARNING:Skipped nested type: System.Net.Mail.SmtpClient+CancellationException
// WARNING:Skipped nested type: System.Net.Mail.SmtpClient+<SendAsync>c__AnonStorey5
// WARNING:Skipped nested type: System.Net.Mime.MediaTypeNames+Application
// WARNING:Skipped nested type: System.Net.Mime.MediaTypeNames+Image
// WARNING:Skipped nested type: System.Net.Mime.MediaTypeNames+Text
// WARNING:Skipped nested type: System.Net.NetworkInformation.Win32IPGlobalProperties+Win32_MIB_TCPROW
// WARNING:Skipped nested type: System.Net.NetworkInformation.Win32IPGlobalProperties+Win32_MIB_TCP6ROW
// WARNING:Skipped nested type: System.Net.NetworkInformation.Win32IPGlobalProperties+Win32_MIB_UDPROW
// WARNING:Skipped nested type: System.Net.NetworkInformation.Win32IPGlobalProperties+Win32_MIB_UDP6ROW
// WARNING:Skipped nested type: System.Net.NetworkInformation.Ping+IcmpMessage
// WARNING:Skipped nested type: System.Net.NetworkInformation.Ping+<SendAsync>c__AnonStorey6
// WARNING:Skipped nested type: System.Net.Security.SslStream+<BeginAuthenticateAsClient>c__AnonStorey7
// WARNING:Skipped nested type: System.Net.Security.SslStream+<BeginAuthenticateAsServer>c__AnonStorey8
// WARNING:Skipped nested type: System.Net.Sockets.NetworkStream+Timeout
// WARNING:Skipped nested type: System.Net.Sockets.Socket+SocketAsyncResult
// WARNING:Skipped nested type: System.Net.Sockets.Socket+Worker
// WARNING:Skipped nested type: System.Net.Sockets.Socket+SendFileAsyncResult
// WARNING:Skipped nested type: System.Net.ChunkStream+Chunk
// WARNING:Skipped nested type: System.Net.ChunkedInputStream+ReadBufferState
// WARNING:Skipped nested type: System.Net.CookieCollection+CookieCollectionComparer
// WARNING:Skipped nested type: System.Net.CredentialCache+CredentialCacheKey
// WARNING:Skipped nested type: System.Net.CredentialCache+CredentialCacheForHostKey
// WARNING:Skipped nested type: System.Net.FileWebRequest+FileWebStream
// WARNING:Skipped nested type: System.Net.GlobalProxySelection+EmptyWebProxy
// WARNING:Skipped nested type: System.Net.ServicePointManager+SPKey
// WARNING:Skipped nested type: System.Net.ServicePointManager+ChainValidationHelper
// WARNING:Skipped nested type: System.Net.WebConnection+AbortHelper
// WARNING:Skipped nested type: System.Net.WebRequestMethods+File
// WARNING:Skipped nested type: System.Net.WebRequestMethods+Ftp
// WARNING:Skipped nested type: System.Net.WebRequestMethods+Http
// WARNING:Skipped nested type: System.Security.Cryptography.X509Certificates.X509CertificateCollection+X509CertificateEnumerator
// WARNING:Skipped nested type: System.Text.RegularExpressions.MatchCollection+Enumerator
// WARNING:Skipped nested type: System.Text.RegularExpressions.Regex+Adapter
// WARNING:Skipped nested type: System.Text.RegularExpressions.RxInterpreter+RepeatContext
// WARNING:Skipped nested type: System.Text.RegularExpressions.FactoryCache+Key
// WARNING:Skipped nested type: System.Text.RegularExpressions.MRUList+Node
// WARNING:Skipped nested type: System.Text.RegularExpressions.PatternCompiler+PatternLinkStack
// WARNING:Skipped nested type: System.Text.RegularExpressions.Interpreter+RepeatContext
// WARNING:Skipped nested type: System.Text.RegularExpressions.IntervalCollection+Enumerator

// INFO:MMCSReflector::ImportedAssembly: System, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e

namespace System {
	public class	FileStyleUriParser: UriParser
	{
		public FileStyleUriParser(){}
	}

	public class	FtpStyleUriParser: UriParser
	{
		public FtpStyleUriParser(){}
	}

	public class	GenericUriParser: UriParser
	{
		public GenericUriParser(GenericUriParserOptions options){}
	}

	public class	HttpStyleUriParser: UriParser
	{
		public HttpStyleUriParser(){}
	}

	public class	NetPipeStyleUriParser: UriParser
	{
		public NetPipeStyleUriParser(){}
	}

	public class	NetTcpStyleUriParser: UriParser
	{
		public NetTcpStyleUriParser(){}
	}

	public class	NewsStyleUriParser: UriParser
	{
		public NewsStyleUriParser(){}
	}

	public class	Uri: Object, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		private void Merge(Uri baseUri, string relativeUri){}
		public static UriHostNameType CheckHostName(string name){}
		internal static bool IsIPv4Address(string name){}
		internal static bool IsDomainAddress(string name){}
		public static bool CheckSchemeName(string schemeName){}
		private static bool IsAlpha(char c){}
		public virtual bool Equals(System.Object comparant){}
		private bool InternalEquals(Uri uri){}
		public virtual int GetHashCode(){}
		public string GetLeftPart(UriPartial part){}
		public static int FromHex(char digit){}
		public static string HexEscape(char character){}
		public static char HexUnescape(string pattern, ref int index){}
		public static bool IsHexDigit(char digit){}
		public static bool IsHexEncoding(string pattern, int index){}
		public Uri MakeRelativeUri(Uri uri){}
		public string MakeRelative(Uri toUri){}
		private void AppendQueryAndFragment(ref string result){}
		public virtual string ToString(){}
		protected void GetObjectData(SerializationInfo info, StreamingContext context){}
		protected virtual void Escape(){}
		protected static string EscapeString(string str){}
		internal static string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets){}
		protected virtual void Parse(){}
		private void ParseUri(UriKind kind){}
		protected virtual string Unescape(string str){}
		internal static string Unescape(string str, bool excludeSpecial){}
		private void ParseAsWindowsUNC(string uriString){}
		private string ParseAsWindowsAbsoluteFilePath(string uriString){}
		private void ParseAsUnixAbsoluteFilePath(string uriString){}
		private void Parse(UriKind kind, string uriString){}
		private string ParseNoExceptions(UriKind kind, string uriString){}
		private static bool CompactEscaped(string scheme){}
		private static string Reduce(string path, bool compact_escaped){}
		private static char HexUnescapeMultiByte(string pattern, ref int index, out char surrogate){}
		internal static string GetSchemeDelimiter(string scheme){}
		internal static int GetDefaultPort(string scheme){}
		private string GetOpaqueWiseSchemeDelimiter(){}
		protected virtual bool IsBadFileSystemCharacter(char ch){}
		protected static bool IsExcludedCharacter(char ch){}
		internal static bool MaybeUri(string s){}
		private static bool IsPredefinedScheme(string scheme){}
		protected virtual bool IsReservedCharacter(char ch){}
		public string GetComponents(UriComponents components, UriFormat format){}
		public bool IsBaseOf(Uri uri){}
		public bool IsWellFormedOriginalString(){}
		public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType){}
		private static bool NeedToEscapeDataChar(char b){}
		public static string EscapeDataString(string stringToEscape){}
		private static bool NeedToEscapeUriChar(char b){}
		public static string EscapeUriString(string stringToEscape){}
		public static bool IsWellFormedUriString(string uriString, UriKind uriKind){}
		public static bool TryCreate(string uriString, UriKind uriKind, out Uri result){}
		public static bool TryCreate(Uri baseUri, string relativeUri, out Uri result){}
		public static bool TryCreate(Uri baseUri, Uri relativeUri, out Uri result){}
		public static string UnescapeDataString(string stringToUnescape){}
		private static int GetInt(byte b){}
		private static int GetChar(string str, int offset, int length){}
		private static Char[] GetChars(MemoryStream b, Encoding e){}
		private void EnsureAbsoluteUri(){}
		public Uri(string uriString){}
		protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public Uri(string uriString, UriKind uriKind){}
		private Uri(string uriString, UriKind uriKind, out bool success){}
		public Uri(Uri baseUri, Uri relativeUri){}
		public Uri(string uriString, bool dontEscape){}
		public Uri(Uri baseUri, string relativeUri){}
		public Uri(Uri baseUri, string relativeUri, bool dontEscape){}
		private static Uri(){}
		public string AbsolutePath{ get	{} }
		public string AbsoluteUri{ get	{} }
		public string Authority{ get	{} }
		public string Fragment{ get	{} }
		public string Host{ get	{} }
		public UriHostNameType HostNameType{ get	{} }
		public bool IsDefaultPort{ get	{} }
		public bool IsFile{ get	{} }
		public bool IsLoopback{ get	{} }
		public bool IsUnc{ get	{} }
		public string LocalPath{ get	{} }
		public string PathAndQuery{ get	{} }
		public int Port{ get	{} }
		public string Query{ get	{} }
		public string Scheme{ get	{} }
		public String[] Segments{ get	{} }
		public bool UserEscaped{ get	{} }
		public string UserInfo{ get	{} }
		public string DnsSafeHost{ get	{} }
		public bool IsAbsoluteUri{ get	{} }
		public string OriginalString{ get	{} }
		UriParser Parser{ get	{} set	{} }
		private bool isUnixFilePath;
		private string source;
		private string scheme;
		private string host;
		private int port;
		private string path;
		private string query;
		private string fragment;
		private string userinfo;
		private bool isUnc;
		private bool isOpaquePart;
		private bool isAbsoluteUri;
		private String[] segments;
		private bool userEscaped;
		private string cachedAbsoluteUri;
		private string cachedToString;
		private string cachedLocalPath;
		private int cachedHashCode;
		private UriParser parser;
		private readonly static string hexUpperChars;
		public readonly static string SchemeDelimiter;
		public readonly static string UriSchemeFile;
		public readonly static string UriSchemeFtp;
		public readonly static string UriSchemeGopher;
		public readonly static string UriSchemeHttp;
		public readonly static string UriSchemeHttps;
		public readonly static string UriSchemeMailto;
		public readonly static string UriSchemeNews;
		public readonly static string UriSchemeNntp;
		public readonly static string UriSchemeNetPipe;
		public readonly static string UriSchemeNetTcp;
		private static UriScheme[] schemes;
		private static Dictionary<String, Int32> <>f__switch$map12;
		private static Dictionary<String, Int32> <>f__switch$map13;
		private static Dictionary<String, Int32> <>f__switch$map14;
		private static Dictionary<String, Int32> <>f__switch$map15;
		private static Dictionary<String, Int32> <>f__switch$map16;
		private const int MaxUriLength = null;
	}

	public class	UriBuilder: Object
	{
		public virtual bool Equals(System.Object rparam){}
		public virtual int GetHashCode(){}
		public virtual string ToString(){}
		public UriBuilder(){}
		public UriBuilder(string uri){}
		public UriBuilder(Uri uri){}
		public UriBuilder(string schemeName, string hostName){}
		public UriBuilder(string scheme, string host, int portNumber){}
		public UriBuilder(string scheme, string host, int port, string pathValue){}
		public UriBuilder(string scheme, string host, int port, string pathValue, string extraValue){}
		public string Fragment{ get	{} set	{} }
		public string Host{ get	{} set	{} }
		public string Password{ get	{} set	{} }
		public string Path{ get	{} set	{} }
		public int Port{ get	{} set	{} }
		public string Query{ get	{} set	{} }
		public string Scheme{ get	{} set	{} }
		public Uri Uri{ get	{} }
		public string UserName{ get	{} set	{} }
		private string scheme;
		private string host;
		private int port;
		private string path;
		private string query;
		private string fragment;
		private string username;
		private string password;
		private Uri uri;
		private bool modified;
	}

	public class	UriFormatException: FormatException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public UriFormatException(){}
		public UriFormatException(string message){}
		public UriFormatException(string message, Exception exception){}
		protected UriFormatException(SerializationInfo info, StreamingContext context){}
	}

	public abstract	class	UriParser: Object
	{
		private static Match ParseAuthority(Group g){}
		protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format){}
		protected virtual void InitializeAndValidate(Uri uri, out UriFormatException parsingError){}
		protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri){}
		protected virtual bool IsWellFormedOriginalString(Uri uri){}
		protected virtual UriParser OnNewUri(){}
		protected virtual void OnRegister(string schemeName, int defaultPort){}
		protected virtual string Resolve(Uri baseUri, Uri relativeUri, out UriFormatException parsingError){}
		private string IgnoreFirstCharIf(string s, char c){}
		private string Format(string s, UriFormat format){}
		private static void CreateDefaults(){}
		public static bool IsKnownScheme(string schemeName){}
		private static void InternalRegister(Hashtable table, UriParser uriParser, string schemeName, int defaultPort){}
		public static void Register(UriParser uriParser, string schemeName, int defaultPort){}
		internal static UriParser GetParser(string schemeName){}
		protected UriParser(){}
		private static UriParser(){}
		string SchemeName{ get	{} set	{} }
		int DefaultPort{ get	{} set	{} }
		internal string scheme_name;
		private int default_port;
		private static System.Object lock_object;
		private static Hashtable table;
		private readonly static Regex uri_regex;
		private readonly static Regex auth_regex;
	}

	public class	UriTypeConverter: TypeConverter
	{
		private bool CanConvert(Type type){}
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public UriTypeConverter(){}
	}

}

namespace System.CodeDom.Compiler {
	public sealed class	GeneratedCodeAttribute: Attribute, _Attribute
	{
		public GeneratedCodeAttribute(string tool, string version){}
		public string Tool{ get	{} }
		public string Version{ get	{} }
		private string tool;
		private string version;
	}

}

namespace System.Collections.Generic {
	public class	LinkedList<T>: Object, IEnumerable<T>, IEnumerable, ICollection, IDeserializationCallback, ICollection<T>, ISerializable
	{
		private sealed virtual void System.Collections.Generic.ICollection<T>.Add(T value){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual bool System.Collections.Generic.ICollection<T>.get_IsReadOnly(){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private void VerifyReferencedNode(LinkedListNode<T> node){}
		private static void VerifyBlankNode(LinkedListNode<T> newNode){}
		public LinkedListNode<T> AddAfter(LinkedListNode<T> node, T value){}
		public void AddAfter(LinkedListNode<T> node, LinkedListNode<T> newNode){}
		public LinkedListNode<T> AddBefore(LinkedListNode<T> node, T value){}
		public void AddBefore(LinkedListNode<T> node, LinkedListNode<T> newNode){}
		public void AddFirst(LinkedListNode<T> node){}
		public LinkedListNode<T> AddFirst(T value){}
		public LinkedListNode<T> AddLast(T value){}
		public void AddLast(LinkedListNode<T> node){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(T value){}
		public sealed virtual void CopyTo(T[] array, int index){}
		public LinkedListNode<T> Find(T value){}
		public LinkedListNode<T> FindLast(T value){}
		public Enumerator<T> GetEnumerator(){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void OnDeserialization(System.Object sender){}
		public sealed virtual bool Remove(T value){}
		public void Remove(LinkedListNode<T> node){}
		public void RemoveFirst(){}
		public void RemoveLast(){}
		public LinkedList(){}
		public LinkedList(IEnumerable<T> collection){}
		protected LinkedList(SerializationInfo info, StreamingContext context){}
		bool System.Collections.Generic.ICollection<T>.IsReadOnly{ get	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		public sealed virtual int Count{ get	{} }
		public LinkedListNode<T> First{ get	{} }
		public LinkedListNode<T> Last{ get	{} }
		private uint count;
		private uint version;
		private System.Object syncRoot;
		internal LinkedListNode<T> first;
		internal SerializationInfo si;
		private const string DataArrayKey = null;
		private const string VersionKey = null;
	}

	public sealed class	LinkedListNode<T>: Object
	{
		internal void Detach(){}
		internal void SelfReference(LinkedList<T> list){}
		internal void InsertBetween(LinkedListNode<T> previousNode, LinkedListNode<T> nextNode, LinkedList<T> list){}
		public LinkedListNode(T value){}
		internal LinkedListNode(LinkedList<T> list, T value){}
		internal LinkedListNode(LinkedList<T> list, T value, LinkedListNode<T> previousNode, LinkedListNode<T> nextNode){}
		public LinkedList<T> List{ get	{} }
		public LinkedListNode<T> Next{ get	{} }
		public LinkedListNode<T> Previous{ get	{} }
		public T Value{ get	{} set	{} }
		private T item;
		private LinkedList<T> container;
		internal LinkedListNode<T> forward;
		internal LinkedListNode<T> back;
	}

	public class	Queue<T>: Object, IEnumerable<T>, IEnumerable, ICollection
	{
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int idx){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public void Clear(){}
		public bool Contains(T item){}
		public void CopyTo(T[] array, int idx){}
		public T Dequeue(){}
		public T Peek(){}
		public void Enqueue(T item){}
		public T[] ToArray(){}
		public void TrimExcess(){}
		private void SetCapacity(int new_size){}
		public Enumerator<T> GetEnumerator(){}
		public Queue(){}
		public Queue(int count){}
		public Queue(IEnumerable<T> collection){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		public sealed virtual int Count{ get	{} }
		private T[] _array;
		private int _head;
		private int _tail;
		private int _size;
		private int _version;
	}

	public class	SortedDictionary<TKey, TValue>: Object, ICollection, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>
	{
		private sealed virtual ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys(){}
		private sealed virtual ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values(){}
		private sealed virtual void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> item){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> item){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly(){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> item){}
		private sealed virtual void System.Collections.IDictionary.Add(System.Object key, System.Object value){}
		private sealed virtual bool System.Collections.IDictionary.Contains(System.Object key){}
		private sealed virtual IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsReadOnly(){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Keys(){}
		private sealed virtual void System.Collections.IDictionary.Remove(System.Object key){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Values(){}
		private sealed virtual System.Object System.Collections.IDictionary.get_Item(System.Object key){}
		private sealed virtual void System.Collections.IDictionary.set_Item(System.Object key, System.Object value){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator(){}
		public sealed virtual void Add(TKey key, TValue value){}
		public sealed virtual void Clear(){}
		public sealed virtual bool ContainsKey(TKey key){}
		public bool ContainsValue(TValue value){}
		public sealed virtual void CopyTo(KeyValuePair array, int arrayIndex){}
		public Enumerator<TKey, TValue> GetEnumerator(){}
		public sealed virtual bool Remove(TKey key){}
		public sealed virtual bool TryGetValue(TKey key, out TValue value){}
		private TKey ToKey(System.Object key){}
		private TValue ToValue(System.Object value){}
		public SortedDictionary(){}
		public SortedDictionary(IComparer<TKey> comparer){}
		public SortedDictionary(IDictionary<TKey, TValue> dic){}
		public SortedDictionary(IDictionary<TKey, TValue> dic, IComparer<TKey> comparer){}
		ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys{ get	{} }
		ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values{ get	{} }
		bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly{ get	{} }
		bool System.Collections.IDictionary.IsFixedSize{ get	{} }
		bool System.Collections.IDictionary.IsReadOnly{ get	{} }
		ICollection System.Collections.IDictionary.Keys{ get	{} }
		ICollection System.Collections.IDictionary.Values{ get	{} }
		System.Object this[System.Object key] { get	{} set	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		public IComparer<TKey> Comparer{ get	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual TValue this[TKey key] { get	{} set	{} }
		public KeyCollection<TKey, TValue> Keys{ get	{} }
		public ValueCollection<TKey, TValue> Values{ get	{} }
		private RBTree tree;
		private NodeHelper<TKey, TValue> hlp;
	}

	public class	SortedList<TKey, TValue>: Object, ICollection, IEnumerable, IDictionary, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary<TKey, TValue>
	{
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsReadOnly(){}
		private sealed virtual System.Object System.Collections.IDictionary.get_Item(System.Object key){}
		private sealed virtual void System.Collections.IDictionary.set_Item(System.Object key, System.Object value){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Keys(){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Values(){}
		private sealed virtual ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys(){}
		private sealed virtual ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values(){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly(){}
		private sealed virtual void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear(){}
		private sealed virtual void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair array, int arrayIndex){}
		private sealed virtual void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair){}
		private sealed virtual bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair){}
		private sealed virtual IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual void System.Collections.IDictionary.Add(System.Object key, System.Object value){}
		private sealed virtual bool System.Collections.IDictionary.Contains(System.Object key){}
		private sealed virtual IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator(){}
		private sealed virtual void System.Collections.IDictionary.Remove(System.Object key){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int arrayIndex){}
		public sealed virtual void Add(TKey key, TValue value){}
		public sealed virtual bool ContainsKey(TKey key){}
		public sealed virtual IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator(){}
		public sealed virtual bool Remove(TKey key){}
		public sealed virtual void Clear(){}
		public void RemoveAt(int index){}
		public int IndexOfKey(TKey key){}
		public int IndexOfValue(TValue value){}
		public bool ContainsValue(TValue value){}
		public void TrimExcess(){}
		public sealed virtual bool TryGetValue(TKey key, out TValue value){}
		private void EnsureCapacity(int n, int free){}
		private void PutImpl(TKey key, TValue value, bool overwrite){}
		private void Init(IComparer<TKey> comparer, int capacity, bool forceSize){}
		private void CopyToArray(Array arr, int i, EnumeratorMode<TKey, TValue> mode){}
		private int Find(TKey key){}
		private TKey ToKey(System.Object key){}
		private TValue ToValue(System.Object value){}
		internal TKey KeyAt(int index){}
		internal TValue ValueAt(int index){}
		public SortedList(){}
		public SortedList(int capacity){}
		public SortedList(int capacity, IComparer<TKey> comparer){}
		public SortedList(IComparer<TKey> comparer){}
		public SortedList(IDictionary<TKey, TValue> dictionary){}
		public SortedList(IDictionary<TKey, TValue> dictionary, IComparer<TKey> comparer){}
		private static SortedList(){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		bool System.Collections.IDictionary.IsFixedSize{ get	{} }
		bool System.Collections.IDictionary.IsReadOnly{ get	{} }
		System.Object this[System.Object key] { get	{} set	{} }
		ICollection System.Collections.IDictionary.Keys{ get	{} }
		ICollection System.Collections.IDictionary.Values{ get	{} }
		ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys{ get	{} }
		ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values{ get	{} }
		bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly{ get	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual TValue this[TKey key] { get	{} set	{} }
		public int Capacity{ get	{} set	{} }
		public IList<TKey> Keys{ get	{} }
		public IList<TValue> Values{ get	{} }
		public IComparer<TKey> Comparer{ get	{} }
		private int inUse;
		private int modificationCount;
		private KeyValuePair table;
		private IComparer<TKey> comparer;
		private int defaultCapacity;
		private readonly static int INITIAL_SIZE;
	}

	public class	Stack<T>: Object, ICollection, IEnumerable, IEnumerable<T>
	{
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array dest, int idx){}
		private sealed virtual IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public void Clear(){}
		public bool Contains(T t){}
		public void CopyTo(T[] dest, int idx){}
		public T Peek(){}
		public T Pop(){}
		public void Push(T t){}
		public T[] ToArray(){}
		public void TrimExcess(){}
		public Enumerator<T> GetEnumerator(){}
		public Stack(){}
		public Stack(int count){}
		public Stack(IEnumerable<T> collection){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		public sealed virtual int Count{ get	{} }
		private T[] _array;
		private int _size;
		private int _version;
		private const int INITIAL_SIZE = null;
	}

}

namespace System.Collections.Specialized {
	public class	HybridDictionary: Object, ICollection, IEnumerable, IDictionary
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public sealed virtual void Add(System.Object key, System.Object value){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(System.Object key){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual IDictionaryEnumerator GetEnumerator(){}
		public sealed virtual void Remove(System.Object key){}
		private void Switch(){}
		public HybridDictionary(){}
		public HybridDictionary(bool caseInsensitive){}
		public HybridDictionary(int initialSize){}
		public HybridDictionary(int initialSize, bool caseInsensitive){}
		IDictionary inner{ get	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsFixedSize{ get	{} }
		public sealed virtual bool IsReadOnly{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public sealed virtual System.Object this[System.Object key] { get	{} set	{} }
		public sealed virtual ICollection Keys{ get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		public sealed virtual ICollection Values{ get	{} }
		private bool caseInsensitive;
		private Hashtable hashtable;
		private ListDictionary list;
		private const int switchAfter = null;
	}

	public interface IOrderedDictionary: ICollection, IEnumerable, IDictionary
	{
		IDictionaryEnumerator GetEnumerator();
		void Insert(int idx, System.Object key, System.Object value);
		void RemoveAt(int idx);
		System.Object this[int idx] { get; set; }
	}

	public class	ListDictionary: Object, ICollection, IEnumerable, IDictionary
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private DictionaryNode FindEntry(System.Object key){}
		private DictionaryNode FindEntry(System.Object key, out DictionaryNode prev){}
		private void AddImpl(System.Object key, System.Object value, DictionaryNode prev){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual void Add(System.Object key, System.Object value){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(System.Object key){}
		public sealed virtual IDictionaryEnumerator GetEnumerator(){}
		public sealed virtual void Remove(System.Object key){}
		public ListDictionary(){}
		public ListDictionary(IComparer comparer){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		public sealed virtual bool IsFixedSize{ get	{} }
		public sealed virtual bool IsReadOnly{ get	{} }
		public sealed virtual System.Object this[System.Object key] { get	{} set	{} }
		public sealed virtual ICollection Keys{ get	{} }
		public sealed virtual ICollection Values{ get	{} }
		private int count;
		private int version;
		private DictionaryNode head;
		private IComparer comparer;
	}

	public abstract	class	NameObjectCollectionBase: Object, ICollection, IEnumerable, IDeserializationCallback, ISerializable
	{
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private void Init(){}
		public virtual IEnumerator GetEnumerator(){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void OnDeserialization(System.Object sender){}
		protected void BaseAdd(string name, System.Object value){}
		protected void BaseClear(){}
		protected System.Object BaseGet(int index){}
		protected System.Object BaseGet(string name){}
		protected String[] BaseGetAllKeys(){}
		protected Object[] BaseGetAllValues(){}
		protected Object[] BaseGetAllValues(Type type){}
		protected string BaseGetKey(int index){}
		protected bool BaseHasKeys(){}
		protected void BaseRemove(string name){}
		protected void BaseRemoveAt(int index){}
		protected void BaseSet(int index, System.Object value){}
		protected void BaseSet(string name, System.Object value){}
		private _Item FindFirstMatchedItem(string name){}
		internal bool Equals(string s1, string s2){}
		protected NameObjectCollectionBase(){}
		protected NameObjectCollectionBase(int capacity){}
		internal NameObjectCollectionBase(IEqualityComparer equalityComparer, IComparer comparer, IHashCodeProvider hcp){}
		protected NameObjectCollectionBase(IEqualityComparer equalityComparer){}
		protected NameObjectCollectionBase(IHashCodeProvider hashProvider, IComparer comparer){}
		protected NameObjectCollectionBase(SerializationInfo info, StreamingContext context){}
		protected NameObjectCollectionBase(int capacity, IEqualityComparer equalityComparer){}
		protected NameObjectCollectionBase(int capacity, IHashCodeProvider hashProvider, IComparer comparer){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		IEqualityComparer EqualityComparer{ get	{} }
		IComparer Comparer{ get	{} }
		IHashCodeProvider HashCodeProvider{ get	{} }
		public virtual KeysCollection Keys{ get	{} }
		public virtual int Count{ get	{} }
		bool IsReadOnly{ get	{} set	{} }
		private Hashtable m_ItemsContainer;
		private _Item m_NullKeyItem;
		private ArrayList m_ItemsArray;
		private IHashCodeProvider m_hashprovider;
		private IComparer m_comparer;
		private int m_defCapacity;
		private bool m_readonly;
		private SerializationInfo infoCopy;
		private KeysCollection keyscoll;
		private IEqualityComparer equality_comparer;
	}

	public class	NameValueCollection: NameObjectCollectionBase, ICollection, IEnumerable, IDeserializationCallback, ISerializable
	{
		public void Add(NameValueCollection c){}
		public virtual void Add(string name, string val){}
		public virtual void Clear(){}
		public void CopyTo(Array dest, int index){}
		private void RefreshCachedAll(){}
		public virtual string Get(int index){}
		public virtual string Get(string name){}
		private static string AsSingleString(ArrayList values){}
		public virtual string GetKey(int index){}
		public virtual String[] GetValues(int index){}
		public virtual String[] GetValues(string name){}
		private static String[] AsStringArray(ArrayList values){}
		public bool HasKeys(){}
		public virtual void Remove(string name){}
		public virtual void Set(string name, string value){}
		protected void InvalidateCachedArrays(){}
		public NameValueCollection(){}
		public NameValueCollection(int capacity){}
		public NameValueCollection(NameValueCollection col){}
		public NameValueCollection(IHashCodeProvider hashProvider, IComparer comparer){}
		public NameValueCollection(int capacity, NameValueCollection col){}
		protected NameValueCollection(SerializationInfo info, StreamingContext context){}
		public NameValueCollection(int capacity, IHashCodeProvider hashProvider, IComparer comparer){}
		public NameValueCollection(IEqualityComparer equalityComparer){}
		public NameValueCollection(int capacity, IEqualityComparer equalityComparer){}
		public virtual String[] AllKeys{ get	{} }
		public string this[int index] { get	{} }
		public string this[string name] { get	{} set	{} }
		private String[] cachedAllKeys;
		private String[] cachedAll;
	}

	public class	OrderedDictionary: Object, ICollection, IEnumerable, IOrderedDictionary, IDictionary, IDeserializationCallback, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object sender){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsFixedSize(){}
		protected virtual void OnDeserialization(System.Object sender){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual void Add(System.Object key, System.Object value){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(System.Object key){}
		public virtual IDictionaryEnumerator GetEnumerator(){}
		public sealed virtual void Remove(System.Object key){}
		private int FindListEntry(System.Object key){}
		private void WriteCheck(){}
		public OrderedDictionary AsReadOnly(){}
		public sealed virtual void Insert(int index, System.Object key, System.Object value){}
		public sealed virtual void RemoveAt(int index){}
		public OrderedDictionary(){}
		public OrderedDictionary(int capacity){}
		public OrderedDictionary(IEqualityComparer equalityComparer){}
		public OrderedDictionary(int capacity, IEqualityComparer equalityComparer){}
		protected OrderedDictionary(SerializationInfo info, StreamingContext context){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		bool System.Collections.IDictionary.IsFixedSize{ get	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsReadOnly{ get	{} }
		public sealed virtual System.Object this[System.Object key] { get	{} set	{} }
		public sealed virtual System.Object this[int index] { get	{} set	{} }
		public sealed virtual ICollection Keys{ get	{} }
		public sealed virtual ICollection Values{ get	{} }
		private ArrayList list;
		private Hashtable hash;
		private bool readOnly;
		private int initialCapacity;
		private SerializationInfo serializationInfo;
		private IEqualityComparer comparer;
	}

	public class	StringCollection: Object, ICollection, IEnumerable, IList
	{
		private sealed virtual bool System.Collections.IList.get_IsReadOnly(){}
		private sealed virtual bool System.Collections.IList.get_IsFixedSize(){}
		private sealed virtual System.Object System.Collections.IList.get_Item(int index){}
		private sealed virtual void System.Collections.IList.set_Item(int index, System.Object value){}
		private sealed virtual int System.Collections.IList.Add(System.Object value){}
		private sealed virtual bool System.Collections.IList.Contains(System.Object value){}
		private sealed virtual int System.Collections.IList.IndexOf(System.Object value){}
		private sealed virtual void System.Collections.IList.Insert(int index, System.Object value){}
		private sealed virtual void System.Collections.IList.Remove(System.Object value){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public int Add(string value){}
		public void AddRange(String[] value){}
		public sealed virtual void Clear(){}
		public bool Contains(string value){}
		public void CopyTo(String[] array, int index){}
		public StringEnumerator GetEnumerator(){}
		public int IndexOf(string value){}
		public void Insert(int index, string value){}
		public void Remove(string value){}
		public sealed virtual void RemoveAt(int index){}
		public StringCollection(){}
		bool System.Collections.IList.IsReadOnly{ get	{} }
		bool System.Collections.IList.IsFixedSize{ get	{} }
		System.Object this[int index] { get	{} set	{} }
		public string this[int index] { get	{} set	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsReadOnly{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		private ArrayList data;
	}

	public class	StringDictionary: Object, IEnumerable
	{
		public virtual void Add(string key, string value){}
		public virtual void Clear(){}
		public virtual bool ContainsKey(string key){}
		public virtual bool ContainsValue(string value){}
		public virtual void CopyTo(Array array, int index){}
		public virtual IEnumerator GetEnumerator(){}
		public virtual void Remove(string key){}
		public StringDictionary(){}
		public virtual int Count{ get	{} }
		public virtual bool IsSynchronized{ get	{} }
		public virtual string this[string key] { get	{} set	{} }
		public virtual ICollection Keys{ get	{} }
		public virtual ICollection Values{ get	{} }
		public virtual System.Object SyncRoot{ get	{} }
		private Hashtable contents;
	}

	public class	StringEnumerator: Object
	{
		public bool MoveNext(){}
		public void Reset(){}
		internal StringEnumerator(StringCollection coll){}
		public string Current{ get	{} }
		private IEnumerator enumerable;
	}

}

namespace System.ComponentModel.Design.Serialization {
	public sealed class	InstanceDescriptor: Object
	{
		private void ValidateMember(MemberInfo member, ICollection arguments){}
		public System.Object Invoke(){}
		public InstanceDescriptor(MemberInfo member, ICollection arguments){}
		public InstanceDescriptor(MemberInfo member, ICollection arguments, bool isComplete){}
		public ICollection Arguments{ get	{} }
		public bool IsComplete{ get	{} }
		public MemberInfo MemberInfo{ get	{} }
		private MemberInfo member;
		private ICollection arguments;
		private bool isComplete;
	}

}

namespace System.ComponentModel.Design {
	public class	CommandID: Object
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual string ToString(){}
		public CommandID(Guid menuGroup, int commandID){}
		public virtual Guid Guid{ get	{} }
		public virtual int ID{ get	{} }
		private int cID;
		private Guid guid;
	}

	public sealed class	ComponentChangedEventArgs: EventArgs
	{
		public ComponentChangedEventArgs(System.Object component, MemberDescriptor member, System.Object oldValue, System.Object newValue){}
		public System.Object Component{ get	{} }
		public MemberDescriptor Member{ get	{} }
		public System.Object NewValue{ get	{} }
		public System.Object OldValue{ get	{} }
		private System.Object component;
		private MemberDescriptor member;
		private System.Object oldValue;
		private System.Object newValue;
	}

	public sealed class	ComponentChangingEventArgs: EventArgs
	{
		public ComponentChangingEventArgs(System.Object component, MemberDescriptor member){}
		public System.Object Component{ get	{} }
		public MemberDescriptor Member{ get	{} }
		private System.Object component;
		private MemberDescriptor member;
	}

	public class	ComponentEventArgs: EventArgs
	{
		public ComponentEventArgs(IComponent component){}
		public virtual IComponent Component{ get	{} }
		private IComponent icomp;
	}

	public class	ComponentRenameEventArgs: EventArgs
	{
		public ComponentRenameEventArgs(System.Object component, string oldName, string newName){}
		public System.Object Component{ get	{} }
		public virtual string NewName{ get	{} }
		public virtual string OldName{ get	{} }
		private System.Object component;
		private string oldName;
		private string newName;
	}

	public abstract	class	DesignerTransaction: Object, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		protected virtual void Dispose(bool disposing){}
		protected abstract virtual void OnCancel();
		protected abstract virtual void OnCommit();
		public void Cancel(){}
		public void Commit(){}
		protected virtual void Finalize(){}
		protected DesignerTransaction(){}
		protected DesignerTransaction(string description){}
		public bool Canceled{ get	{} }
		public bool Committed{ get	{} }
		public string Description{ get	{} }
		private string description;
		private bool committed;
		private bool canceled;
	}

	public class	DesignerTransactionCloseEventArgs: EventArgs
	{
		public DesignerTransactionCloseEventArgs(bool commit, bool lastTransaction){}
		public DesignerTransactionCloseEventArgs(bool commit){}
		public bool LastTransaction{ get	{} }
		public bool TransactionCommitted{ get	{} }
		private bool commit;
		private bool last_transaction;
	}

	public class	DesignerVerb: MenuCommand
	{
		public virtual string ToString(){}
		public DesignerVerb(string text, EventHandler handler){}
		public DesignerVerb(string text, EventHandler handler, CommandID startCommandID){}
		public string Text{ get	{} }
		public string Description{ get	{} set	{} }
		private string text;
		private string description;
	}

	public class	DesignerVerbCollection: CollectionBase, IList, ICollection, IEnumerable
	{
		public int Add(DesignerVerb value){}
		public void AddRange(DesignerVerb[] value){}
		public void AddRange(DesignerVerbCollection value){}
		public bool Contains(DesignerVerb value){}
		public void CopyTo(DesignerVerb[] array, int index){}
		public int IndexOf(DesignerVerb value){}
		public void Insert(int index, DesignerVerb value){}
		protected virtual void OnClear(){}
		protected virtual void OnInsert(int index, System.Object value){}
		protected virtual void OnRemove(int index, System.Object value){}
		protected virtual void OnSet(int index, System.Object oldValue, System.Object newValue){}
		protected virtual void OnValidate(System.Object value){}
		public void Remove(DesignerVerb value){}
		public DesignerVerbCollection(){}
		public DesignerVerbCollection(DesignerVerb[] value){}
		public DesignerVerb this[int index] { get	{} set	{} }
	}

	public interface IComponentChangeService	{
		void OnComponentChanged(System.Object component, MemberDescriptor member, System.Object oldValue, System.Object newValue);
		void OnComponentChanging(System.Object component, MemberDescriptor member);
		event	ComponentEventHandler ComponentAdded;
		event	ComponentEventHandler ComponentAdding;
		event	ComponentChangedEventHandler ComponentChanged;
		event	ComponentChangingEventHandler ComponentChanging;
		event	ComponentEventHandler ComponentRemoved;
		event	ComponentEventHandler ComponentRemoving;
		event	ComponentRenameEventHandler ComponentRename;
	}

	public interface IDesigner: IDisposable
	{
		void DoDefaultAction();
		void Initialize(IComponent component);
		IComponent Component{ get; }
		DesignerVerbCollection Verbs{ get; }
	}

	public interface IDesignerHost: IServiceContainer, IServiceProvider
	{
		void Activate();
		IComponent CreateComponent(Type componentClass);
		IComponent CreateComponent(Type componentClass, string name);
		DesignerTransaction CreateTransaction();
		DesignerTransaction CreateTransaction(string description);
		void DestroyComponent(IComponent component);
		IDesigner GetDesigner(IComponent component);
		Type GetType(string typeName);
		IContainer Container{ get; }
		bool InTransaction{ get; }
		bool Loading{ get; }
		IComponent RootComponent{ get; }
		string RootComponentClassName{ get; }
		string TransactionDescription{ get; }
		event	EventHandler Activated;
		event	EventHandler Deactivated;
		event	EventHandler LoadComplete;
		event	DesignerTransactionCloseEventHandler TransactionClosed;
		event	DesignerTransactionCloseEventHandler TransactionClosing;
		event	EventHandler TransactionOpened;
		event	EventHandler TransactionOpening;
	}

	public interface IReferenceService	{
		IComponent GetComponent(System.Object reference);
		string GetName(System.Object reference);
		System.Object GetReference(string name);
		Object[] GetReferences();
		Object[] GetReferences(Type baseType);
	}

	public interface IRootDesigner: IDisposable, IDesigner
	{
		System.Object GetView(ViewTechnology technology);
		ViewTechnology[] SupportedTechnologies{ get; }
	}

	public interface IServiceContainer: IServiceProvider
	{
		void AddService(Type serviceType, System.Object serviceInstance);
		void AddService(Type serviceType, ServiceCreatorCallback callback);
		void AddService(Type serviceType, System.Object serviceInstance, bool promote);
		void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
		void RemoveService(Type serviceType);
		void RemoveService(Type serviceType, bool promote);
	}

	public interface ITypeDescriptorFilterService	{
		bool FilterAttributes(IComponent component, IDictionary attributes);
		bool FilterEvents(IComponent component, IDictionary events);
		bool FilterProperties(IComponent component, IDictionary properties);
	}

	public interface ITypeResolutionService	{
		Assembly GetAssembly(AssemblyName name);
		Assembly GetAssembly(AssemblyName name, bool throwOnError);
		string GetPathOfAssembly(AssemblyName name);
		Type GetType(string name);
		Type GetType(string name, bool throwOnError);
		Type GetType(string name, bool throwOnError, bool ignoreCase);
		void ReferenceAssembly(AssemblyName name);
	}

	public class	MenuCommand: Object
	{
		public virtual void Invoke(){}
		public virtual void Invoke(System.Object arg){}
		protected virtual void OnCommandChanged(EventArgs e){}
		public virtual string ToString(){}
		public MenuCommand(EventHandler handler, CommandID command){}
		public virtual bool Checked{ get	{} set	{} }
		public virtual CommandID CommandID{ get	{} }
		public virtual bool Enabled{ get	{} set	{} }
		public virtual int OleStatus{ get	{} }
		public virtual IDictionary Properties{ get	{} }
		public virtual bool Supported{ get	{} set	{} }
		public virtual bool Visible{ get	{} set	{} }
		public event	EventHandler CommandChanged;
		private EventHandler handler;
		private CommandID command;
		private bool ischecked;
		private bool enabled;
		private bool issupported;
		private bool visible;
		private Hashtable properties;
	}

	public class	StandardCommands: Object
	{
		public StandardCommands(){}
		private static StandardCommands(){}
		public readonly static CommandID AlignBottom;
		public readonly static CommandID AlignHorizontalCenters;
		public readonly static CommandID AlignLeft;
		public readonly static CommandID AlignRight;
		public readonly static CommandID AlignToGrid;
		public readonly static CommandID AlignTop;
		public readonly static CommandID AlignVerticalCenters;
		public readonly static CommandID ArrangeBottom;
		public readonly static CommandID ArrangeIcons;
		public readonly static CommandID ArrangeRight;
		public readonly static CommandID BringForward;
		public readonly static CommandID BringToFront;
		public readonly static CommandID CenterHorizontally;
		public readonly static CommandID CenterVertically;
		public readonly static CommandID Copy;
		public readonly static CommandID Cut;
		public readonly static CommandID Delete;
		public readonly static CommandID F1Help;
		public readonly static CommandID Group;
		public readonly static CommandID HorizSpaceConcatenate;
		public readonly static CommandID HorizSpaceDecrease;
		public readonly static CommandID HorizSpaceIncrease;
		public readonly static CommandID HorizSpaceMakeEqual;
		public readonly static CommandID LineupIcons;
		public readonly static CommandID LockControls;
		public readonly static CommandID MultiLevelRedo;
		public readonly static CommandID MultiLevelUndo;
		public readonly static CommandID Paste;
		public readonly static CommandID Properties;
		public readonly static CommandID PropertiesWindow;
		public readonly static CommandID Redo;
		public readonly static CommandID Replace;
		public readonly static CommandID SelectAll;
		public readonly static CommandID SendBackward;
		public readonly static CommandID SendToBack;
		public readonly static CommandID ShowGrid;
		public readonly static CommandID ShowLargeIcons;
		public readonly static CommandID SizeToControl;
		public readonly static CommandID SizeToControlHeight;
		public readonly static CommandID SizeToControlWidth;
		public readonly static CommandID SizeToFit;
		public readonly static CommandID SizeToGrid;
		public readonly static CommandID SnapToGrid;
		public readonly static CommandID TabOrder;
		public readonly static CommandID Undo;
		public readonly static CommandID Ungroup;
		public readonly static CommandID VerbFirst;
		public readonly static CommandID VerbLast;
		public readonly static CommandID VertSpaceConcatenate;
		public readonly static CommandID VertSpaceDecrease;
		public readonly static CommandID VertSpaceIncrease;
		public readonly static CommandID VertSpaceMakeEqual;
		public readonly static CommandID ViewGrid;
		public readonly static CommandID DocumentOutline;
		public readonly static CommandID ViewCode;
	}

	delegate void ComponentChangedEventHandler(System.Object sender, ComponentChangedEventArgs e);

	delegate void ComponentChangingEventHandler(System.Object sender, ComponentChangingEventArgs e);

	delegate void ComponentEventHandler(System.Object sender, ComponentEventArgs e);

	delegate void ComponentRenameEventHandler(System.Object sender, ComponentRenameEventArgs e);

	delegate void DesignerTransactionCloseEventHandler(System.Object sender, DesignerTransactionCloseEventArgs e);

	delegate System.Object ServiceCreatorCallback(IServiceContainer container, Type serviceType);

}

namespace System.ComponentModel {
	public class	ArrayConverter: CollectionConverter
	{
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public ArrayConverter(){}
	}

	public class	AsyncCompletedEventArgs: EventArgs
	{
		protected void RaiseExceptionIfNecessary(){}
		public AsyncCompletedEventArgs(Exception error, bool cancelled, System.Object userState){}
		public bool Cancelled{ get	{} }
		public Exception Error{ get	{} }
		public System.Object UserState{ get	{} }
		private Exception _error;
		private bool _cancelled;
		private System.Object _userState;
	}

	public sealed class	AsyncOperation: Object
	{
		protected virtual void Finalize(){}
		public void OperationCompleted(){}
		public void Post(SendOrPostCallback d, System.Object arg){}
		public void PostOperationCompleted(SendOrPostCallback d, System.Object arg){}
		internal AsyncOperation(SynchronizationContext ctx, System.Object state){}
		public SynchronizationContext SynchronizationContext{ get	{} }
		public System.Object UserSuppliedState{ get	{} }
		private SynchronizationContext ctx;
		private System.Object state;
		private bool done;
	}

	public sealed abstract	class	AsyncOperationManager: Object
	{
		public static AsyncOperation CreateOperation(System.Object userSuppliedState){}
		private static AsyncOperationManager(){}
		public static SynchronizationContext SynchronizationContext{ get	{} set	{} }
	}

	public class	AttributeCollection: Object, ICollection, IEnumerable
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual int System.Collections.ICollection.get_Count(){}
		public static AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes){}
		public bool Contains(Attribute attr){}
		public bool Contains(Attribute[] attributes){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		public bool Matches(Attribute attr){}
		public bool Matches(Attribute[] attributes){}
		protected Attribute GetDefaultAttribute(Type attributeType){}
		internal AttributeCollection(ArrayList attributes){}
		public AttributeCollection(Attribute[] attributes){}
		private static AttributeCollection(){}
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		int System.Collections.ICollection.Count{ get	{} }
		public sealed virtual int Count{ get	{} }
		public virtual Attribute this[Type type] { get	{} }
		public virtual Attribute this[int index] { get	{} }
		private ArrayList attrList;
		public readonly static AttributeCollection Empty;
	}

	public class	BackgroundWorker: Object
	{
		public void CancelAsync(){}
		public void ReportProgress(int percentProgress){}
		public void ReportProgress(int percentProgress, System.Object userState){}
		public void RunWorkerAsync(){}
		private void ProcessWorker(System.Object argument, AsyncOperation async, SendOrPostCallback callback){}
		private void CompleteWorker(System.Object state){}
		public void RunWorkerAsync(System.Object argument){}
		protected virtual void OnDoWork(DoWorkEventArgs e){}
		protected virtual void OnProgressChanged(ProgressChangedEventArgs e){}
		protected virtual void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e){}
		private void <ReportProgress>m__0(System.Object o){}
		private void <CompleteWorker>m__1(System.Object darg){}
		public BackgroundWorker(){}
		public bool CancellationPending{ get	{} }
		public bool IsBusy{ get	{} }
		public bool WorkerReportsProgress{ get	{} set	{} }
		public bool WorkerSupportsCancellation{ get	{} set	{} }
		public event	DoWorkEventHandler DoWork;
		public event	ProgressChangedEventHandler ProgressChanged;
		public event	RunWorkerCompletedEventHandler RunWorkerCompleted;
		private AsyncOperation async;
		private bool cancel_pending;
		private bool report_progress;
		private bool support_cancel;
	}

	public abstract	class	BaseNumberConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type t){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		internal abstract virtual string ConvertToString(System.Object value, NumberFormatInfo format);
		internal abstract virtual System.Object ConvertFromString(string value, NumberFormatInfo format);
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		protected BaseNumberConverter(){}
		bool SupportHex{ get	{} }
		internal Type InnerType;
	}

	public class	BooleanConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		public BooleanConverter(){}
	}

	public sealed class	BrowsableAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public BrowsableAttribute(bool browsable){}
		private static BrowsableAttribute(){}
		public bool Browsable{ get	{} }
		private bool browsable;
		public readonly static BrowsableAttribute Default;
		public readonly static BrowsableAttribute No;
		public readonly static BrowsableAttribute Yes;
	}

	public class	ByteConverter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public ByteConverter(){}
		bool SupportHex{ get	{} }
	}

	public class	CancelEventArgs: EventArgs
	{
		public CancelEventArgs(){}
		public CancelEventArgs(bool cancel){}
		public bool Cancel{ get	{} set	{} }
		private bool cancel;
	}

	public class	CategoryAttribute: Attribute, _Attribute
	{
		protected virtual string GetLocalizedString(string value){}
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public CategoryAttribute(){}
		public CategoryAttribute(string category){}
		private static CategoryAttribute(){}
		public static CategoryAttribute Action{ get	{} }
		public static CategoryAttribute Appearance{ get	{} }
		public static CategoryAttribute Asynchronous{ get	{} }
		public static CategoryAttribute Behavior{ get	{} }
		public static CategoryAttribute Data{ get	{} }
		public static CategoryAttribute Default{ get	{} }
		public static CategoryAttribute Design{ get	{} }
		public static CategoryAttribute DragDrop{ get	{} }
		public static CategoryAttribute Focus{ get	{} }
		public static CategoryAttribute Format{ get	{} }
		public static CategoryAttribute Key{ get	{} }
		public static CategoryAttribute Layout{ get	{} }
		public static CategoryAttribute Mouse{ get	{} }
		public static CategoryAttribute WindowStyle{ get	{} }
		public string Category{ get	{} }
		private string category;
		private bool IsLocalized;
		private static CategoryAttribute action;
		private static CategoryAttribute appearance;
		private static CategoryAttribute behaviour;
		private static CategoryAttribute data;
		private static CategoryAttribute def;
		private static CategoryAttribute design;
		private static CategoryAttribute drag_drop;
		private static CategoryAttribute focus;
		private static CategoryAttribute format;
		private static CategoryAttribute key;
		private static CategoryAttribute layout;
		private static CategoryAttribute mouse;
		private static CategoryAttribute window_style;
		private static CategoryAttribute async;
		private static System.Object lockobj;
	}

	public class	CharConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public CharConverter(){}
	}

	public class	CollectionChangeEventArgs: EventArgs
	{
		public CollectionChangeEventArgs(CollectionChangeAction action, System.Object element){}
		public virtual CollectionChangeAction Action{ get	{} }
		public virtual System.Object Element{ get	{} }
		private CollectionChangeAction changeAction;
		private System.Object theElement;
	}

	public class	CollectionConverter: TypeConverter
	{
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public CollectionConverter(){}
	}

	public class	Component: MarshalByRefObject, IDisposable, IComponent
	{
		protected virtual void Finalize(){}
		public sealed virtual void Dispose(){}
		protected virtual void Dispose(bool release_all){}
		protected virtual System.Object GetService(Type service){}
		public virtual string ToString(){}
		public Component(){}
		bool CanRaiseEvents{ get	{} }
		public virtual ISite Site{ get	{} set	{} }
		public IContainer Container{ get	{} }
		bool DesignMode{ get	{} }
		EventHandlerList Events{ get	{} }
		public sealed virtual event	EventHandler Disposed;
		private EventHandlerList event_handlers;
		private ISite mySite;
		private System.Object disposedEvent;
	}

	public class	ComponentCollection: ReadOnlyCollectionBase, ICollection, IEnumerable
	{
		public void CopyTo(IComponent[] array, int index){}
		public ComponentCollection(IComponent[] components){}
		public virtual IComponent this[int index] { get	{} }
		public virtual IComponent this[string name] { get	{} }
	}

	public class	ComponentConverter: ReferenceConverter
	{
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public ComponentConverter(Type type){}
	}

	public class	CultureInfoConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		public CultureInfoConverter(){}
		private StandardValuesCollection _standardValues;
	}

	public abstract	class	CustomTypeDescriptor: Object, ICustomTypeDescriptor
	{
		public virtual AttributeCollection GetAttributes(){}
		public virtual string GetClassName(){}
		public virtual string GetComponentName(){}
		public virtual TypeConverter GetConverter(){}
		public virtual EventDescriptor GetDefaultEvent(){}
		public virtual PropertyDescriptor GetDefaultProperty(){}
		public virtual System.Object GetEditor(Type editorBaseType){}
		public virtual EventDescriptorCollection GetEvents(){}
		public virtual EventDescriptorCollection GetEvents(Attribute[] attributes){}
		public virtual PropertyDescriptorCollection GetProperties(){}
		public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes){}
		public virtual System.Object GetPropertyOwner(PropertyDescriptor pd){}
		protected CustomTypeDescriptor(){}
		protected CustomTypeDescriptor(ICustomTypeDescriptor parent){}
		private ICustomTypeDescriptor _parent;
	}

	public class	DateTimeConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public DateTimeConverter(){}
	}

	public class	DecimalConverter: BaseNumberConverter
	{
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		public DecimalConverter(){}
		bool SupportHex{ get	{} }
	}

	public sealed class	DefaultEventAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object o){}
		public virtual int GetHashCode(){}
		public DefaultEventAttribute(string name){}
		private static DefaultEventAttribute(){}
		public string Name{ get	{} }
		private string eventName;
		public readonly static DefaultEventAttribute Default;
	}

	public sealed class	DefaultPropertyAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object o){}
		public virtual int GetHashCode(){}
		public DefaultPropertyAttribute(string name){}
		private static DefaultPropertyAttribute(){}
		public string Name{ get	{} }
		private string property_name;
		public readonly static DefaultPropertyAttribute Default;
	}

	public class	DefaultValueAttribute: Attribute, _Attribute
	{
		protected void SetValue(System.Object value){}
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public DefaultValueAttribute(bool value){}
		public DefaultValueAttribute(byte value){}
		public DefaultValueAttribute(char value){}
		public DefaultValueAttribute(double value){}
		public DefaultValueAttribute(short value){}
		public DefaultValueAttribute(int value){}
		public DefaultValueAttribute(long value){}
		public DefaultValueAttribute(System.Object value){}
		public DefaultValueAttribute(float value){}
		public DefaultValueAttribute(string value){}
		public DefaultValueAttribute(Type type, string value){}
		public virtual System.Object Value{ get	{} }
		private System.Object DefaultValue;
	}

	public class	DescriptionAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public DescriptionAttribute(){}
		public DescriptionAttribute(string name){}
		private static DescriptionAttribute(){}
		public virtual string Description{ get	{} }
		string DescriptionValue{ get	{} set	{} }
		private string desc;
		public readonly static DescriptionAttribute Default;
	}

	public sealed class	DesignOnlyAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public DesignOnlyAttribute(bool design_only){}
		private static DesignOnlyAttribute(){}
		public bool IsDesignOnly{ get	{} }
		private bool design_only;
		public readonly static DesignOnlyAttribute Default;
		public readonly static DesignOnlyAttribute No;
		public readonly static DesignOnlyAttribute Yes;
	}

	public sealed class	DesignTimeVisibleAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public DesignTimeVisibleAttribute(){}
		public DesignTimeVisibleAttribute(bool visible){}
		private static DesignTimeVisibleAttribute(){}
		public bool Visible{ get	{} }
		private bool visible;
		public readonly static DesignTimeVisibleAttribute Default;
		public readonly static DesignTimeVisibleAttribute No;
		public readonly static DesignTimeVisibleAttribute Yes;
	}

	public sealed class	DesignerAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public DesignerAttribute(string designerTypeName){}
		public DesignerAttribute(Type designerType){}
		public DesignerAttribute(string designerTypeName, Type designerBaseType){}
		public DesignerAttribute(Type designerType, Type designerBaseType){}
		public DesignerAttribute(string designerTypeName, string designerBaseTypeName){}
		public string DesignerBaseTypeName{ get	{} }
		public string DesignerTypeName{ get	{} }
		public virtual System.Object TypeId{ get	{} }
		private string name;
		private string basetypename;
	}

	public sealed class	DesignerCategoryAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public DesignerCategoryAttribute(){}
		public DesignerCategoryAttribute(string category){}
		private static DesignerCategoryAttribute(){}
		public virtual System.Object TypeId{ get	{} }
		public string Category{ get	{} }
		private string category;
		public readonly static DesignerCategoryAttribute Component;
		public readonly static DesignerCategoryAttribute Form;
		public readonly static DesignerCategoryAttribute Generic;
		public readonly static DesignerCategoryAttribute Default;
	}

	public sealed class	DesignerSerializationVisibilityAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility vis){}
		private static DesignerSerializationVisibilityAttribute(){}
		public DesignerSerializationVisibility Visibility{ get	{} }
		private DesignerSerializationVisibility visibility;
		public readonly static DesignerSerializationVisibilityAttribute Default;
		public readonly static DesignerSerializationVisibilityAttribute Content;
		public readonly static DesignerSerializationVisibilityAttribute Hidden;
		public readonly static DesignerSerializationVisibilityAttribute Visible;
	}

	public class	DisplayNameAttribute: Attribute, _Attribute
	{
		public virtual bool IsDefaultAttribute(){}
		public virtual int GetHashCode(){}
		public virtual bool Equals(System.Object obj){}
		public DisplayNameAttribute(){}
		public DisplayNameAttribute(string displayName){}
		private static DisplayNameAttribute(){}
		public virtual string DisplayName{ get	{} }
		string DisplayNameValue{ get	{} set	{} }
		private string attributeDisplayName;
		public readonly static DisplayNameAttribute Default;
	}

	public class	DoWorkEventArgs: EventArgs
	{
		public DoWorkEventArgs(System.Object argument){}
		public System.Object Argument{ get	{} }
		public System.Object Result{ get	{} set	{} }
		public bool Cancel{ get	{} set	{} }
		private System.Object arg;
		private System.Object result;
		private bool cancel;
	}

	public class	DoubleConverter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		public DoubleConverter(){}
		bool SupportHex{ get	{} }
	}

	public sealed class	EditorAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public EditorAttribute(){}
		public EditorAttribute(string typeName, string baseTypeName){}
		public EditorAttribute(string typeName, Type baseType){}
		public EditorAttribute(Type type, Type baseType){}
		public string EditorBaseTypeName{ get	{} }
		public string EditorTypeName{ get	{} }
		public virtual System.Object TypeId{ get	{} }
		private string name;
		private string basename;
	}

	public sealed class	EditorBrowsableAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public EditorBrowsableAttribute(){}
		public EditorBrowsableAttribute(EditorBrowsableState state){}
		public EditorBrowsableState State{ get	{} }
		private EditorBrowsableState state;
	}

	public class	EnumConverter: TypeConverter
	{
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual bool IsValid(ITypeDescriptorContext context, System.Object value){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		private ArgumentException CreateValueNotValidException(System.Object value){}
		public EnumConverter(Type type){}
		IComparer Comparer{ get	{} }
		Type EnumType{ get	{} }
		StandardValuesCollection Values{ get	{} set	{} }
		bool IsFlags{ get	{} }
		private Type type;
		private StandardValuesCollection stdValues;
	}

	public abstract	class	EventDescriptor: MemberDescriptor
	{
		public abstract virtual void AddEventHandler(System.Object component, Delegate value);
		public abstract virtual void RemoveEventHandler(System.Object component, Delegate value);
		protected EventDescriptor(MemberDescriptor desc){}
		protected EventDescriptor(MemberDescriptor desc, Attribute[] attrs){}
		protected EventDescriptor(string str, Attribute[] attrs){}
		public abstract virtual Type ComponentType{ get	{} }
		public abstract virtual Type EventType{ get	{} }
		public abstract virtual bool IsMulticast{ get	{} }
	}

	public class	EventDescriptorCollection: Object, ICollection, IEnumerable, IList
	{
		private sealed virtual void System.Collections.IList.Clear(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual void System.Collections.IList.RemoveAt(int index){}
		private sealed virtual int System.Collections.ICollection.get_Count(){}
		private sealed virtual int System.Collections.IList.Add(System.Object value){}
		private sealed virtual bool System.Collections.IList.Contains(System.Object value){}
		private sealed virtual int System.Collections.IList.IndexOf(System.Object value){}
		private sealed virtual void System.Collections.IList.Insert(int index, System.Object value){}
		private sealed virtual void System.Collections.IList.Remove(System.Object value){}
		private sealed virtual bool System.Collections.IList.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IList.get_IsReadOnly(){}
		private sealed virtual System.Object System.Collections.IList.get_Item(int index){}
		private sealed virtual void System.Collections.IList.set_Item(int index, System.Object value){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		public int Add(EventDescriptor value){}
		public sealed virtual void Clear(){}
		public bool Contains(EventDescriptor value){}
		public virtual EventDescriptor Find(string name, bool ignoreCase){}
		public sealed virtual IEnumerator GetEnumerator(){}
		public int IndexOf(EventDescriptor value){}
		public void Insert(int index, EventDescriptor value){}
		public void Remove(EventDescriptor value){}
		public sealed virtual void RemoveAt(int index){}
		public virtual EventDescriptorCollection Sort(){}
		public virtual EventDescriptorCollection Sort(IComparer comparer){}
		public virtual EventDescriptorCollection Sort(String[] order){}
		public virtual EventDescriptorCollection Sort(String[] order, IComparer comparer){}
		protected void InternalSort(IComparer comparer){}
		protected void InternalSort(String[] order){}
		private ArrayList ExtractItems(String[] names){}
		private EventDescriptorCollection CloneCollection(){}
		internal EventDescriptorCollection Filter(Attribute[] attributes){}
		private EventDescriptorCollection(){}
		internal EventDescriptorCollection(ArrayList list){}
		public EventDescriptorCollection(EventDescriptor[] events){}
		public EventDescriptorCollection(EventDescriptor[] events, bool readOnly){}
		private static EventDescriptorCollection(){}
		int System.Collections.ICollection.Count{ get	{} }
		bool System.Collections.IList.IsFixedSize{ get	{} }
		bool System.Collections.IList.IsReadOnly{ get	{} }
		System.Object this[int index] { get	{} set	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		public sealed virtual int Count{ get	{} }
		public virtual EventDescriptor this[string name] { get	{} }
		public virtual EventDescriptor this[int index] { get	{} }
		private ArrayList eventList;
		private bool isReadOnly;
		public readonly static EventDescriptorCollection Empty;
	}

	public sealed class	EventHandlerList: Object, IDisposable
	{
		public void AddHandler(System.Object key, Delegate value){}
		public void AddHandlers(EventHandlerList listToAddFrom){}
		public void RemoveHandler(System.Object key, Delegate value){}
		public sealed virtual void Dispose(){}
		private ListEntry FindEntry(System.Object key){}
		public EventHandlerList(){}
		public Delegate this[System.Object key] { get	{} set	{} }
		private ListEntry entries;
		private Delegate null_entry;
	}

	public class	ExpandableObjectConverter: TypeConverter
	{
		public ExpandableObjectConverter(){}
	}

	public class	GuidConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public GuidConverter(){}
	}

	public interface IBindingList: ICollection, IEnumerable, IList
	{
		void AddIndex(PropertyDescriptor property);
		System.Object AddNew();
		void ApplySort(PropertyDescriptor property, ListSortDirection direction);
		int Find(PropertyDescriptor property, System.Object key);
		void RemoveIndex(PropertyDescriptor property);
		void RemoveSort();
		bool AllowEdit{ get; }
		bool AllowNew{ get; }
		bool AllowRemove{ get; }
		bool IsSorted{ get; }
		ListSortDirection SortDirection{ get; }
		PropertyDescriptor SortProperty{ get; }
		bool SupportsChangeNotification{ get; }
		bool SupportsSearching{ get; }
		bool SupportsSorting{ get; }
		event	ListChangedEventHandler ListChanged;
	}

	public interface IBindingListView: ICollection, IEnumerable, IList, IBindingList
	{
		void ApplySort(ListSortDescriptionCollection sorts);
		void RemoveFilter();
		string Filter{ get; set; }
		ListSortDescriptionCollection SortDescriptions{ get; }
		bool SupportsAdvancedSorting{ get; }
		bool SupportsFiltering{ get; }
	}

	public interface IChangeTracking	{
		void AcceptChanges();
		bool IsChanged{ get; }
	}

	public interface IComNativeDescriptorHandler	{
		AttributeCollection GetAttributes(System.Object component);
		string GetClassName(System.Object component);
		TypeConverter GetConverter(System.Object component);
		EventDescriptor GetDefaultEvent(System.Object component);
		PropertyDescriptor GetDefaultProperty(System.Object component);
		System.Object GetEditor(System.Object component, Type baseEditorType);
		EventDescriptorCollection GetEvents(System.Object component);
		EventDescriptorCollection GetEvents(System.Object component, Attribute[] attributes);
		string GetName(System.Object component);
		PropertyDescriptorCollection GetProperties(System.Object component, Attribute[] attributes);
		System.Object GetPropertyValue(System.Object component, int dispid, ref bool success);
		System.Object GetPropertyValue(System.Object component, string propertyName, ref bool success);
	}

	public interface IComponent: IDisposable
	{
		ISite Site{ get; set; }
		event	EventHandler Disposed;
	}

	public interface IContainer: IDisposable
	{
		void Add(IComponent component);
		void Add(IComponent component, string name);
		void Remove(IComponent component);
		ComponentCollection Components{ get; }
	}

	public interface ICustomTypeDescriptor	{
		AttributeCollection GetAttributes();
		string GetClassName();
		string GetComponentName();
		TypeConverter GetConverter();
		EventDescriptor GetDefaultEvent();
		PropertyDescriptor GetDefaultProperty();
		System.Object GetEditor(Type editorBaseType);
		EventDescriptorCollection GetEvents();
		EventDescriptorCollection GetEvents(Attribute[] arr);
		PropertyDescriptorCollection GetProperties();
		PropertyDescriptorCollection GetProperties(Attribute[] arr);
		System.Object GetPropertyOwner(PropertyDescriptor pd);
	}

	public interface IDataErrorInfo	{
		string Error{ get; }
		string this[string columnName] { get; }
	}

	public interface IEditableObject	{
		void BeginEdit();
		void CancelEdit();
		void EndEdit();
	}

	public interface IListSource	{
		IList GetList();
		bool ContainsListCollection{ get; }
	}

	public interface INotifyPropertyChanged	{
		event	PropertyChangedEventHandler PropertyChanged;
	}

	public interface IRevertibleChangeTracking: IChangeTracking
	{
		void RejectChanges();
	}

	public interface ISite: IServiceProvider
	{
		IComponent Component{ get; }
		IContainer Container{ get; }
		bool DesignMode{ get; }
		string Name{ get; set; }
	}

	public interface ISupportInitialize	{
		void BeginInit();
		void EndInit();
	}

	public interface ISupportInitializeNotification: ISupportInitialize
	{
		bool IsInitialized{ get; }
		event	EventHandler Initialized;
	}

	public interface ISynchronizeInvoke	{
		IAsyncResult BeginInvoke(Delegate method, Object[] args);
		System.Object EndInvoke(IAsyncResult result);
		System.Object Invoke(Delegate method, Object[] args);
		bool InvokeRequired{ get; }
	}

	public interface ITypeDescriptorContext: IServiceProvider
	{
		void OnComponentChanged();
		bool OnComponentChanging();
		IContainer Container{ get; }
		System.Object Instance{ get; }
		PropertyDescriptor PropertyDescriptor{ get; }
	}

	public interface ITypedList	{
		PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
		string GetListName(PropertyDescriptor[] listAccessors);
	}

	public sealed class	ImmutableObjectAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public ImmutableObjectAttribute(bool immutable){}
		private static ImmutableObjectAttribute(){}
		public bool Immutable{ get	{} }
		private bool immutable;
		public readonly static ImmutableObjectAttribute Default;
		public readonly static ImmutableObjectAttribute No;
		public readonly static ImmutableObjectAttribute Yes;
	}

	public class	Int16Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public Int16Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	Int32Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public Int32Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	Int64Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public Int64Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	InvalidEnumArgumentException: ArgumentException, ISerializable, _Exception
	{
		public InvalidEnumArgumentException(){}
		public InvalidEnumArgumentException(string message){}
		public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass){}
		public InvalidEnumArgumentException(string message, Exception innerException){}
		protected InvalidEnumArgumentException(SerializationInfo info, StreamingContext context){}
	}

	public class	LicFileLicenseProvider: LicenseProvider
	{
		public virtual License GetLicense(LicenseContext context, Type type, System.Object instance, bool allowExceptions){}
		protected virtual string GetKey(Type type){}
		protected virtual bool IsKeyValid(string key, Type type){}
		public LicFileLicenseProvider(){}
	}

	public abstract	class	License: Object, IDisposable
	{
		public abstract virtual void Dispose();
		protected License(){}
		public abstract virtual string LicenseKey{ get	{} }
	}

	public class	LicenseContext: Object, IServiceProvider
	{
		public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly){}
		public virtual System.Object GetService(Type type){}
		public virtual void SetSavedLicenseKey(Type type, string key){}
		public LicenseContext(){}
		public virtual LicenseUsageMode UsageMode{ get	{} }
	}

	public class	LicenseException: SystemException, ISerializable, _Exception
	{
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public LicenseException(Type type){}
		public LicenseException(Type type, System.Object instance){}
		public LicenseException(Type type, System.Object instance, string message){}
		public LicenseException(Type type, System.Object instance, string message, Exception innerException){}
		protected LicenseException(SerializationInfo info, StreamingContext context){}
		public Type LicensedType{ get	{} }
		private Type type;
	}

	public sealed class	LicenseManager: Object
	{
		public static System.Object CreateWithContext(Type type, LicenseContext creationContext){}
		public static System.Object CreateWithContext(Type type, LicenseContext creationContext, Object[] args){}
		public static bool IsLicensed(Type type){}
		public static bool IsValid(Type type){}
		public static bool IsValid(Type type, System.Object instance, out License license){}
		public static void LockContext(System.Object contextUser){}
		public static void UnlockContext(System.Object contextUser){}
		public static void Validate(Type type){}
		public static License Validate(Type type, System.Object instance){}
		private static bool privateGetLicense(Type type, System.Object instance, bool allowExceptions, out License license){}
		private LicenseManager(){}
		private static LicenseManager(){}
		public static LicenseContext CurrentContext{ get	{} set	{} }
		public static LicenseUsageMode UsageMode{ get	{} }
		private static LicenseContext mycontext;
		private static System.Object contextLockUser;
		private static System.Object lockObject;
	}

	public abstract	class	LicenseProvider: Object
	{
		public abstract virtual License GetLicense(LicenseContext context, Type type, System.Object instance, bool allowExceptions);
		protected LicenseProvider(){}
	}

	public sealed class	LicenseProviderAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public LicenseProviderAttribute(){}
		public LicenseProviderAttribute(string typeName){}
		public LicenseProviderAttribute(Type type){}
		private static LicenseProviderAttribute(){}
		public Type LicenseProvider{ get	{} }
		public virtual System.Object TypeId{ get	{} }
		private Type Provider;
		public readonly static LicenseProviderAttribute Default;
	}

	public sealed class	ListBindableAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public ListBindableAttribute(bool listBindable){}
		public ListBindableAttribute(BindableSupport flags){}
		private static ListBindableAttribute(){}
		public bool ListBindable{ get	{} }
		private bool bindable;
		public readonly static ListBindableAttribute Default;
		public readonly static ListBindableAttribute No;
		public readonly static ListBindableAttribute Yes;
	}

	public class	ListChangedEventArgs: EventArgs
	{
		public ListChangedEventArgs(ListChangedType listChangedType, int newIndex){}
		public ListChangedEventArgs(ListChangedType listChangedType, PropertyDescriptor propDesc){}
		public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, int oldIndex){}
		public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc){}
		public ListChangedType ListChangedType{ get	{} }
		public int OldIndex{ get	{} }
		public int NewIndex{ get	{} }
		public PropertyDescriptor PropertyDescriptor{ get	{} }
		private ListChangedType changedType;
		private int oldIndex;
		private int newIndex;
		private PropertyDescriptor propDesc;
	}

	public class	ListSortDescription: Object
	{
		public ListSortDescription(PropertyDescriptor propertyDescriptor, ListSortDirection sortDirection){}
		public PropertyDescriptor PropertyDescriptor{ get	{} set	{} }
		public ListSortDirection SortDirection{ get	{} set	{} }
		private PropertyDescriptor propertyDescriptor;
		private ListSortDirection sortDirection;
	}

	public class	ListSortDescriptionCollection: Object, ICollection, IEnumerable, IList
	{
		private sealed virtual System.Object System.Collections.IList.get_Item(int index){}
		private sealed virtual void System.Collections.IList.set_Item(int index, System.Object value){}
		private sealed virtual bool System.Collections.IList.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual bool System.Collections.IList.get_IsReadOnly(){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual int System.Collections.IList.Add(System.Object value){}
		private sealed virtual void System.Collections.IList.Clear(){}
		private sealed virtual void System.Collections.IList.Insert(int index, System.Object value){}
		private sealed virtual void System.Collections.IList.Remove(System.Object value){}
		private sealed virtual void System.Collections.IList.RemoveAt(int index){}
		public sealed virtual bool Contains(System.Object value){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual int IndexOf(System.Object value){}
		public ListSortDescriptionCollection(){}
		public ListSortDescriptionCollection(ListSortDescription[] sorts){}
		System.Object this[int index] { get	{} set	{} }
		bool System.Collections.IList.IsFixedSize{ get	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		bool System.Collections.IList.IsReadOnly{ get	{} }
		public sealed virtual int Count{ get	{} }
		public ListSortDescription this[int index] { get	{} set	{} }
		private ArrayList list;
	}

	public sealed class	LocalizableAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public LocalizableAttribute(bool localizable){}
		private static LocalizableAttribute(){}
		public bool IsLocalizable{ get	{} }
		private bool localizable;
		public readonly static LocalizableAttribute Default;
		public readonly static LocalizableAttribute No;
		public readonly static LocalizableAttribute Yes;
	}

	public class	MarshalByValueComponent: Object, IDisposable, IServiceProvider, IComponent
	{
		public sealed virtual void Dispose(){}
		protected virtual void Dispose(bool disposing){}
		protected virtual void Finalize(){}
		public virtual System.Object GetService(Type service){}
		public virtual string ToString(){}
		public MarshalByValueComponent(){}
		public virtual IContainer Container{ get	{} }
		public virtual bool DesignMode{ get	{} }
		public virtual ISite Site{ get	{} set	{} }
		EventHandlerList Events{ get	{} }
		public sealed virtual event	EventHandler Disposed;
		private EventHandlerList eventList;
		private ISite mySite;
		private System.Object disposedEvent;
	}

	public abstract	class	MemberDescriptor: Object
	{
		protected virtual void FillAttributes(IList attributeList){}
		protected virtual AttributeCollection CreateAttributeCollection(){}
		public virtual int GetHashCode(){}
		public virtual bool Equals(System.Object obj){}
		protected static ISite GetSite(System.Object component){}
		protected static System.Object GetInvokee(Type componentClass, System.Object component){}
		protected virtual System.Object GetInvocationTarget(Type type, System.Object instance){}
		protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType){}
		protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly){}
		protected MemberDescriptor(string name, Attribute[] attrs){}
		protected MemberDescriptor(MemberDescriptor reference, Attribute[] attrs){}
		protected MemberDescriptor(string name){}
		protected MemberDescriptor(MemberDescriptor reference){}
		Attribute[] AttributeArray{ get	{} set	{} }
		public virtual AttributeCollection Attributes{ get	{} }
		public virtual string Category{ get	{} }
		public virtual string Description{ get	{} }
		public virtual bool DesignTimeOnly{ get	{} }
		public virtual string DisplayName{ get	{} }
		public virtual string Name{ get	{} }
		public virtual bool IsBrowsable{ get	{} }
		int NameHashCode{ get	{} }
		IComparer DefaultComparer{ get	{} }
		private string name;
		private Attribute[] attrs;
		private AttributeCollection attrCollection;
		private static IComparer default_comparer;
	}

	public sealed class	MergablePropertyAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public MergablePropertyAttribute(bool allowMerge){}
		private static MergablePropertyAttribute(){}
		public bool AllowMerge{ get	{} }
		private bool mergable;
		public readonly static MergablePropertyAttribute Default;
		public readonly static MergablePropertyAttribute No;
		public readonly static MergablePropertyAttribute Yes;
	}

	public class	MultilineStringConverter: TypeConverter
	{
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public MultilineStringConverter(){}
	}

	public sealed class	NotifyParentPropertyAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public NotifyParentPropertyAttribute(bool notifyParent){}
		private static NotifyParentPropertyAttribute(){}
		public bool NotifyParent{ get	{} }
		private bool notifyParent;
		public readonly static NotifyParentPropertyAttribute Default;
		public readonly static NotifyParentPropertyAttribute No;
		public readonly static NotifyParentPropertyAttribute Yes;
	}

	public class	NullableConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual System.Object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues){}
		public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context){}
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		public virtual bool IsValid(ITypeDescriptorContext context, System.Object value){}
		public NullableConverter(Type nullableType){}
		public Type NullableType{ get	{} }
		public Type UnderlyingType{ get	{} }
		public TypeConverter UnderlyingTypeConverter{ get	{} }
		private Type nullableType;
		private Type underlyingType;
		private TypeConverter underlyingTypeConverter;
	}

	public sealed class	PasswordPropertyTextAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object o){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public PasswordPropertyTextAttribute(){}
		public PasswordPropertyTextAttribute(bool password){}
		private static PasswordPropertyTextAttribute(){}
		public bool Password{ get	{} }
		private bool _password;
		public readonly static PasswordPropertyTextAttribute Default;
		public readonly static PasswordPropertyTextAttribute No;
		public readonly static PasswordPropertyTextAttribute Yes;
	}

	public class	ProgressChangedEventArgs: EventArgs
	{
		public ProgressChangedEventArgs(int progressPercentage, System.Object userState){}
		public int ProgressPercentage{ get	{} }
		public System.Object UserState{ get	{} }
		private int progress;
		private System.Object state;
	}

	public class	PropertyChangedEventArgs: EventArgs
	{
		public PropertyChangedEventArgs(string name){}
		public string PropertyName{ get	{} }
		private string propertyName;
	}

	public abstract	class	PropertyDescriptor: MemberDescriptor
	{
		public virtual void AddValueChanged(System.Object component, EventHandler handler){}
		public virtual void RemoveValueChanged(System.Object component, EventHandler handler){}
		protected virtual void FillAttributes(IList attributeList){}
		protected virtual System.Object GetInvocationTarget(Type type, System.Object instance){}
		protected EventHandler GetValueChangedHandler(System.Object component){}
		protected virtual void OnValueChanged(System.Object component, EventArgs e){}
		public abstract virtual System.Object GetValue(System.Object component);
		public abstract virtual void SetValue(System.Object component, System.Object value);
		public abstract virtual void ResetValue(System.Object component);
		public abstract virtual bool CanResetValue(System.Object component);
		public abstract virtual bool ShouldSerializeValue(System.Object component);
		protected System.Object CreateInstance(Type type){}
		public virtual bool Equals(System.Object obj){}
		public PropertyDescriptorCollection GetChildProperties(){}
		public PropertyDescriptorCollection GetChildProperties(System.Object instance){}
		public PropertyDescriptorCollection GetChildProperties(Attribute[] filter){}
		public virtual int GetHashCode(){}
		public virtual PropertyDescriptorCollection GetChildProperties(System.Object instance, Attribute[] filter){}
		public virtual System.Object GetEditor(Type editorBaseType){}
		protected Type GetTypeFromName(string typeName){}
		protected PropertyDescriptor(MemberDescriptor reference){}
		protected PropertyDescriptor(MemberDescriptor reference, Attribute[] attrs){}
		protected PropertyDescriptor(string name, Attribute[] attrs){}
		public abstract virtual Type ComponentType{ get	{} }
		public virtual TypeConverter Converter{ get	{} }
		public virtual bool IsLocalizable{ get	{} }
		public abstract virtual bool IsReadOnly{ get	{} }
		public abstract virtual Type PropertyType{ get	{} }
		public virtual bool SupportsChangeEvents{ get	{} }
		public DesignerSerializationVisibility SerializationVisibility{ get	{} }
		private TypeConverter converter;
		private Hashtable notifiers;
	}

	public class	PropertyDescriptorCollection: Object, ICollection, IEnumerable, IDictionary, IList
	{
		private sealed virtual int System.Collections.IList.Add(System.Object value){}
		private sealed virtual void System.Collections.IDictionary.Add(System.Object key, System.Object value){}
		private sealed virtual void System.Collections.IList.Clear(){}
		private sealed virtual void System.Collections.IDictionary.Clear(){}
		private sealed virtual bool System.Collections.IList.Contains(System.Object value){}
		private sealed virtual bool System.Collections.IDictionary.Contains(System.Object value){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		private sealed virtual IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator(){}
		private sealed virtual int System.Collections.IList.IndexOf(System.Object value){}
		private sealed virtual void System.Collections.IList.Insert(int index, System.Object value){}
		private sealed virtual void System.Collections.IDictionary.Remove(System.Object value){}
		private sealed virtual void System.Collections.IList.Remove(System.Object value){}
		private sealed virtual void System.Collections.IList.RemoveAt(int index){}
		private sealed virtual bool System.Collections.IDictionary.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IList.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IDictionary.get_IsReadOnly(){}
		private sealed virtual bool System.Collections.IList.get_IsReadOnly(){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual int System.Collections.ICollection.get_Count(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Keys(){}
		private sealed virtual ICollection System.Collections.IDictionary.get_Values(){}
		private sealed virtual System.Object System.Collections.IDictionary.get_Item(System.Object key){}
		private sealed virtual void System.Collections.IDictionary.set_Item(System.Object key, System.Object value){}
		private sealed virtual System.Object System.Collections.IList.get_Item(int index){}
		private sealed virtual void System.Collections.IList.set_Item(int index, System.Object value){}
		public int Add(PropertyDescriptor value){}
		public sealed virtual void Clear(){}
		public bool Contains(PropertyDescriptor value){}
		public sealed virtual void CopyTo(Array array, int index){}
		public virtual PropertyDescriptor Find(string name, bool ignoreCase){}
		public virtual IEnumerator GetEnumerator(){}
		public int IndexOf(PropertyDescriptor value){}
		public void Insert(int index, PropertyDescriptor value){}
		public void Remove(PropertyDescriptor value){}
		public sealed virtual void RemoveAt(int index){}
		private PropertyDescriptorCollection CloneCollection(){}
		public virtual PropertyDescriptorCollection Sort(){}
		public virtual PropertyDescriptorCollection Sort(IComparer comparer){}
		public virtual PropertyDescriptorCollection Sort(String[] order){}
		public virtual PropertyDescriptorCollection Sort(String[] order, IComparer comparer){}
		protected void InternalSort(IComparer ic){}
		protected void InternalSort(String[] order){}
		private ArrayList ExtractItems(String[] names){}
		internal PropertyDescriptorCollection Filter(Attribute[] attributes){}
		public PropertyDescriptorCollection(PropertyDescriptor[] properties){}
		public PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly){}
		private PropertyDescriptorCollection(){}
		private static PropertyDescriptorCollection(){}
		bool System.Collections.IDictionary.IsFixedSize{ get	{} }
		bool System.Collections.IList.IsFixedSize{ get	{} }
		bool System.Collections.IDictionary.IsReadOnly{ get	{} }
		bool System.Collections.IList.IsReadOnly{ get	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		int System.Collections.ICollection.Count{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		ICollection System.Collections.IDictionary.Keys{ get	{} }
		ICollection System.Collections.IDictionary.Values{ get	{} }
		System.Object this[System.Object key] { get	{} set	{} }
		System.Object this[int index] { get	{} set	{} }
		public sealed virtual int Count{ get	{} }
		public virtual PropertyDescriptor this[string s] { get	{} }
		public virtual PropertyDescriptor this[int index] { get	{} }
		private ArrayList properties;
		private bool readOnly;
		public readonly static PropertyDescriptorCollection Empty;
	}

	public sealed class	ReadOnlyAttribute: Attribute, _Attribute
	{
		public virtual int GetHashCode(){}
		public virtual bool Equals(System.Object o){}
		public virtual bool IsDefaultAttribute(){}
		public ReadOnlyAttribute(bool read_only){}
		private static ReadOnlyAttribute(){}
		public bool IsReadOnly{ get	{} }
		private bool read_only;
		public readonly static ReadOnlyAttribute No;
		public readonly static ReadOnlyAttribute Yes;
		public readonly static ReadOnlyAttribute Default;
	}

	public class	RecommendedAsConfigurableAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public RecommendedAsConfigurableAttribute(bool recommendedAsConfigurable){}
		private static RecommendedAsConfigurableAttribute(){}
		public bool RecommendedAsConfigurable{ get	{} }
		private bool recommendedAsConfigurable;
		public readonly static RecommendedAsConfigurableAttribute Default;
		public readonly static RecommendedAsConfigurableAttribute No;
		public readonly static RecommendedAsConfigurableAttribute Yes;
	}

	public class	ReferenceConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		protected virtual bool IsValueAllowed(ITypeDescriptorContext context, System.Object value){}
		public ReferenceConverter(Type type){}
		private Type reference_type;
	}

	public class	RefreshEventArgs: EventArgs
	{
		public RefreshEventArgs(System.Object componentChanged){}
		public RefreshEventArgs(Type typeChanged){}
		public System.Object ComponentChanged{ get	{} }
		public Type TypeChanged{ get	{} }
		private System.Object component;
		private Type type;
	}

	public sealed class	RefreshPropertiesAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public RefreshPropertiesAttribute(RefreshProperties refresh){}
		private static RefreshPropertiesAttribute(){}
		public RefreshProperties RefreshProperties{ get	{} }
		private RefreshProperties refresh;
		public readonly static RefreshPropertiesAttribute All;
		public readonly static RefreshPropertiesAttribute Default;
		public readonly static RefreshPropertiesAttribute Repaint;
	}

	public class	RunWorkerCompletedEventArgs: AsyncCompletedEventArgs
	{
		public RunWorkerCompletedEventArgs(System.Object result, Exception error, bool cancelled){}
		public System.Object Result{ get	{} }
		public System.Object UserState{ get	{} }
		private System.Object result;
	}

	public class	SByteConverter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public SByteConverter(){}
		bool SupportHex{ get	{} }
	}

	public class	SingleConverter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		public SingleConverter(){}
		bool SupportHex{ get	{} }
	}

	public class	StringConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public StringConverter(){}
	}

	public class	TimeSpanConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public TimeSpanConverter(){}
	}

	public class	ToolboxItemAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object o){}
		public virtual int GetHashCode(){}
		public virtual bool IsDefaultAttribute(){}
		public ToolboxItemAttribute(bool defaultType){}
		public ToolboxItemAttribute(string toolboxItemName){}
		public ToolboxItemAttribute(Type toolboxItemType){}
		private static ToolboxItemAttribute(){}
		public Type ToolboxItemType{ get	{} }
		public string ToolboxItemTypeName{ get	{} }
		private Type itemType;
		private string itemTypeName;
		public readonly static ToolboxItemAttribute Default;
		public readonly static ToolboxItemAttribute None;
		private const string defaultItemType = null;
	}

	public sealed class	ToolboxItemFilterAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public virtual bool Match(System.Object obj){}
		public virtual string ToString(){}
		public ToolboxItemFilterAttribute(string filterString){}
		public ToolboxItemFilterAttribute(string filterString, ToolboxItemFilterType filterType){}
		public string FilterString{ get	{} }
		public ToolboxItemFilterType FilterType{ get	{} }
		public virtual System.Object TypeId{ get	{} }
		private string Filter;
		private ToolboxItemFilterType ItemFilterType;
	}

	public class	TypeConverter: Object
	{
		public bool CanConvertFrom(Type sourceType){}
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public bool CanConvertTo(Type destinationType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public System.Object ConvertFrom(System.Object o){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public System.Object ConvertFromInvariantString(string text){}
		public System.Object ConvertFromInvariantString(ITypeDescriptorContext context, string text){}
		public System.Object ConvertFromString(string text){}
		public System.Object ConvertFromString(ITypeDescriptorContext context, string text){}
		public System.Object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text){}
		public System.Object ConvertTo(System.Object value, Type destinationType){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public string ConvertToInvariantString(System.Object value){}
		public string ConvertToInvariantString(ITypeDescriptorContext context, System.Object value){}
		public string ConvertToString(System.Object value){}
		public string ConvertToString(ITypeDescriptorContext context, System.Object value){}
		public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		protected Exception GetConvertFromException(System.Object value){}
		protected Exception GetConvertToException(System.Object value, Type destinationType){}
		public System.Object CreateInstance(IDictionary propertyValues){}
		public virtual System.Object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues){}
		public bool GetCreateInstanceSupported(){}
		public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context){}
		public PropertyDescriptorCollection GetProperties(System.Object value){}
		public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value){}
		public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, System.Object value, Attribute[] attributes){}
		public bool GetPropertiesSupported(){}
		public virtual bool GetPropertiesSupported(ITypeDescriptorContext context){}
		public ICollection GetStandardValues(){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public bool GetStandardValuesExclusive(){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public bool GetStandardValuesSupported(){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		public bool IsValid(System.Object value){}
		public virtual bool IsValid(ITypeDescriptorContext context, System.Object value){}
		protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names){}
		public TypeConverter(){}
	}

	public sealed class	TypeConverterAttribute: Attribute, _Attribute
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public TypeConverterAttribute(){}
		public TypeConverterAttribute(string typeName){}
		public TypeConverterAttribute(Type type){}
		private static TypeConverterAttribute(){}
		public string ConverterTypeName{ get	{} }
		private string converter_type;
		public readonly static TypeConverterAttribute Default;
	}

	public abstract	class	TypeDescriptionProvider: Object
	{
		public virtual System.Object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args){}
		public virtual IDictionary GetCache(System.Object instance){}
		public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(System.Object instance){}
		public virtual string GetFullComponentName(System.Object component){}
		public Type GetReflectionType(System.Object instance){}
		public Type GetReflectionType(Type objectType){}
		public virtual Type GetReflectionType(Type objectType, System.Object instance){}
		public ICustomTypeDescriptor GetTypeDescriptor(System.Object instance){}
		public ICustomTypeDescriptor GetTypeDescriptor(Type objectType){}
		public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, System.Object instance){}
		protected TypeDescriptionProvider(){}
		protected TypeDescriptionProvider(TypeDescriptionProvider parent){}
		private EmptyCustomTypeDescriptor _emptyCustomTypeDescriptor;
		private TypeDescriptionProvider _parent;
	}

	public sealed class	TypeDescriptor: Object
	{
		public static TypeDescriptionProvider AddAttributes(System.Object instance, Attribute[] attributes){}
		public static TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes){}
		public static void AddProvider(TypeDescriptionProvider provider, System.Object instance){}
		public static void AddProvider(TypeDescriptionProvider provider, Type type){}
		public static System.Object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args){}
		internal static void AddEditorTable(Type editorBaseType, Hashtable table){}
		public static IDesigner CreateDesigner(IComponent component, Type designerBaseType){}
		public static EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes){}
		public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes){}
		public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes){}
		public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes){}
		public static AttributeCollection GetAttributes(Type componentType){}
		public static AttributeCollection GetAttributes(System.Object component){}
		public static AttributeCollection GetAttributes(System.Object component, bool noCustomTypeDesc){}
		public static string GetClassName(System.Object component){}
		public static string GetClassName(System.Object component, bool noCustomTypeDesc){}
		public static string GetComponentName(System.Object component){}
		public static string GetComponentName(System.Object component, bool noCustomTypeDesc){}
		public static string GetFullComponentName(System.Object component){}
		public static string GetClassName(Type componentType){}
		public static TypeConverter GetConverter(System.Object component){}
		public static TypeConverter GetConverter(System.Object component, bool noCustomTypeDesc){}
		public static TypeConverter GetConverter(Type type){}
		private static Type FindDefaultConverterType(Type type){}
		public static EventDescriptor GetDefaultEvent(Type componentType){}
		public static EventDescriptor GetDefaultEvent(System.Object component){}
		public static EventDescriptor GetDefaultEvent(System.Object component, bool noCustomTypeDesc){}
		public static PropertyDescriptor GetDefaultProperty(Type componentType){}
		public static PropertyDescriptor GetDefaultProperty(System.Object component){}
		public static PropertyDescriptor GetDefaultProperty(System.Object component, bool noCustomTypeDesc){}
		internal static System.Object CreateEditor(Type t, Type componentType){}
		private static System.Object FindEditorInTable(Type componentType, Type editorBaseType, Hashtable table){}
		public static System.Object GetEditor(Type componentType, Type editorBaseType){}
		public static System.Object GetEditor(System.Object component, Type editorBaseType){}
		public static System.Object GetEditor(System.Object component, Type editorBaseType, bool noCustomTypeDesc){}
		public static EventDescriptorCollection GetEvents(System.Object component){}
		public static EventDescriptorCollection GetEvents(Type componentType){}
		public static EventDescriptorCollection GetEvents(System.Object component, Attribute[] attributes){}
		public static EventDescriptorCollection GetEvents(System.Object component, bool noCustomTypeDesc){}
		public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes){}
		public static EventDescriptorCollection GetEvents(System.Object component, Attribute[] attributes, bool noCustomTypeDesc){}
		public static PropertyDescriptorCollection GetProperties(System.Object component){}
		public static PropertyDescriptorCollection GetProperties(Type componentType){}
		public static PropertyDescriptorCollection GetProperties(System.Object component, Attribute[] attributes){}
		public static PropertyDescriptorCollection GetProperties(System.Object component, Attribute[] attributes, bool noCustomTypeDesc){}
		public static PropertyDescriptorCollection GetProperties(System.Object component, bool noCustomTypeDesc){}
		public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes){}
		public static TypeDescriptionProvider GetProvider(System.Object instance){}
		public static TypeDescriptionProvider GetProvider(Type type){}
		public static Type GetReflectionType(System.Object instance){}
		public static Type GetReflectionType(Type type){}
		public static void CreateAssociation(System.Object primary, System.Object secondary){}
		public static System.Object GetAssociation(Type type, System.Object primary){}
		public static void RemoveAssociation(System.Object primary, System.Object secondary){}
		public static void RemoveAssociations(System.Object primary){}
		public static void RemoveProvider(TypeDescriptionProvider provider, System.Object instance){}
		public static void RemoveProvider(TypeDescriptionProvider provider, Type type){}
		private static void RemoveProvider(TypeDescriptionProvider provider, LinkedList<TypeDescriptionProvider> plist){}
		public static void SortDescriptorArray(IList infos){}
		public static void Refresh(Assembly assembly){}
		public static void Refresh(Module module){}
		public static void Refresh(System.Object component){}
		public static void Refresh(Type type){}
		private static void OnComponentDisposed(System.Object sender, EventArgs args){}
		internal static ComponentInfo GetComponentInfo(IComponent com){}
		internal static TypeInfo GetTypeInfo(Type type){}
		private static Type GetTypeFromName(IComponent component, string typeName){}
		private TypeDescriptor(){}
		private static TypeDescriptor(){}
		public static Type ComObjectType{ get	{} }
		ArrayList DefaultConverters{ get	{} }
		public static IComNativeDescriptorHandler ComNativeDescriptorHandler{ get	{} set	{} }
		public static event	RefreshEventHandler Refreshed;
		private readonly static System.Object creatingDefaultConverters;
		private static ArrayList defaultConverters;
		private static IComNativeDescriptorHandler descriptorHandler;
		private static Hashtable componentTable;
		private static Hashtable typeTable;
		private static Hashtable editors;
		private static System.Object typeDescriptionProvidersLock;
		private static Dictionary<Type, LinkedList<TypeDescriptionProvider>> typeDescriptionProviders;
		private static System.Object componentDescriptionProvidersLock;
		private static Dictionary<WeakObjectWrapper, LinkedList<TypeDescriptionProvider>> componentDescriptionProviders;
		private static EventHandler onDispose;
	}

	public abstract	class	TypeListConverter: TypeConverter
	{
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType){}
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType){}
		public virtual System.Object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, System.Object value){}
		public virtual System.Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, System.Object value, Type destinationType){}
		public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context){}
		public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context){}
		protected TypeListConverter(Type[] types){}
		private Type[] types;
	}

	public class	UInt16Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public UInt16Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	UInt32Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public UInt32Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	UInt64Converter: BaseNumberConverter
	{
		internal virtual string ConvertToString(System.Object value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, NumberFormatInfo format){}
		internal virtual System.Object ConvertFromString(string value, int fromBase){}
		public UInt64Converter(){}
		bool SupportHex{ get	{} }
	}

	public class	Win32Exception: ExternalException, ISerializable, _Exception
	{
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		internal static string W32ErrorMessage(int error_code){}
		public Win32Exception(){}
		public Win32Exception(int error){}
		public Win32Exception(int error, string message){}
		public Win32Exception(string message){}
		public Win32Exception(string message, Exception innerException){}
		protected Win32Exception(SerializationInfo info, StreamingContext context){}
		public int NativeErrorCode{ get	{} }
		private int native_error_code;
	}

	delegate void ProcessWorkerEventHandler(System.Object argument, AsyncOperation async, SendOrPostCallback callback);

	delegate void AsyncCompletedEventHandler(System.Object sender, AsyncCompletedEventArgs e);

	delegate void CollectionChangeEventHandler(System.Object sender, CollectionChangeEventArgs e);

	delegate void DoWorkEventHandler(System.Object sender, DoWorkEventArgs e);

	delegate void ListChangedEventHandler(System.Object sender, ListChangedEventArgs e);

	delegate void ProgressChangedEventHandler(System.Object sender, ProgressChangedEventArgs e);

	delegate void PropertyChangedEventHandler(System.Object sender, PropertyChangedEventArgs e);

	delegate void RefreshEventHandler(RefreshEventArgs e);

	delegate void RunWorkerCompletedEventHandler(System.Object sender, RunWorkerCompletedEventArgs e);

}

namespace System.Diagnostics {
	public class	ConsoleTraceListener: TextWriterTraceListener, IDisposable
	{
		public ConsoleTraceListener(){}
		public ConsoleTraceListener(bool useErrorStream){}
		internal ConsoleTraceListener(string data){}
	}

	public class	CorrelationManager: Object
	{
		public void StartLogicalOperation(){}
		public void StartLogicalOperation(System.Object operationId){}
		public void StopLogicalOperation(){}
		internal CorrelationManager(){}
		public Guid ActivityId{ get	{} set	{} }
		public Stack LogicalOperationStack{ get	{} }
		private Guid activity;
		private Stack op_stack;
	}

	public class	DataReceivedEventArgs: EventArgs
	{
		internal DataReceivedEventArgs(string data){}
		public string Data{ get	{} }
		private string data;
	}

	public sealed class	Debug: Object
	{
		public static void Assert(bool condition){}
		public static void Assert(bool condition, string message){}
		public static void Assert(bool condition, string message, string details){}
		public static void Assert(bool condition, string message, string details, Object[] args){}
		public static void WriteLine(System.Object obj){}
		public static void WriteLine(string message){}
		public static void WriteLine(string format, Object[] args){}
		private Debug(){}
	}

	public class	DefaultTraceListener: TraceListener, IDisposable
	{
		private static string GetPrefix(string var, string target){}
		public virtual void Fail(string message){}
		public virtual void Fail(string message, string detailMessage){}
		private DialogResult ProcessUI(string message, string detailMessage){}
		private static void WriteWindowsDebugString(string message){}
		private void WriteDebugString(string message){}
		private void WriteMonoTrace(string message){}
		private void WritePrefix(){}
		private void WriteImpl(string message){}
		private void WriteLogFile(string message, string logFile){}
		private void WriteLogFileImpl(string message, string logFile){}
		public virtual void Write(string message){}
		public virtual void WriteLine(string message){}
		public DefaultTraceListener(){}
		private static DefaultTraceListener(){}
		public bool AssertUiEnabled{ get	{} set	{} }
		public string LogFileName{ get	{} set	{} }
		private string logFileName;
		private bool assertUiEnabled;
		private readonly static bool OnWin32;
		private readonly static string MonoTracePrefix;
		private readonly static string MonoTraceFile;
		private static Dictionary<String, Int32> <>f__switch$map0;
		private static Dictionary<String, Int32> <>f__switch$map1;
		private const string ConsoleOutTrace = null;
		private const string ConsoleErrorTrace = null;
	}

	public sealed class	FileVersionInfo: Object
	{
		private void GetVersionInfo_internal(string fileName){}
		public static FileVersionInfo GetVersionInfo(string fileName){}
		private static void AppendFormat(StringBuilder sb, string format, Object[] args){}
		public virtual string ToString(){}
		private FileVersionInfo(){}
		public string Comments{ get	{} }
		public string CompanyName{ get	{} }
		public int FileBuildPart{ get	{} }
		public string FileDescription{ get	{} }
		public int FileMajorPart{ get	{} }
		public int FileMinorPart{ get	{} }
		public string FileName{ get	{} }
		public int FilePrivatePart{ get	{} }
		public string FileVersion{ get	{} }
		public string InternalName{ get	{} }
		public bool IsDebug{ get	{} }
		public bool IsPatched{ get	{} }
		public bool IsPreRelease{ get	{} }
		public bool IsPrivateBuild{ get	{} }
		public bool IsSpecialBuild{ get	{} }
		public string Language{ get	{} }
		public string LegalCopyright{ get	{} }
		public string LegalTrademarks{ get	{} }
		public string OriginalFilename{ get	{} }
		public string PrivateBuild{ get	{} }
		public int ProductBuildPart{ get	{} }
		public int ProductMajorPart{ get	{} }
		public int ProductMinorPart{ get	{} }
		public string ProductName{ get	{} }
		public int ProductPrivatePart{ get	{} }
		public string ProductVersion{ get	{} }
		public string SpecialBuild{ get	{} }
		private string comments;
		private string companyname;
		private string filedescription;
		private string filename;
		private string fileversion;
		private string internalname;
		private string language;
		private string legalcopyright;
		private string legaltrademarks;
		private string originalfilename;
		private string privatebuild;
		private string productname;
		private string productversion;
		private string specialbuild;
		private bool isdebug;
		private bool ispatched;
		private bool isprerelease;
		private bool isprivatebuild;
		private bool isspecialbuild;
		private int filemajorpart;
		private int fileminorpart;
		private int filebuildpart;
		private int fileprivatepart;
		private int productmajorpart;
		private int productminorpart;
		private int productbuildpart;
		private int productprivatepart;
	}

	public class	MonitoringDescriptionAttribute: DescriptionAttribute, _Attribute
	{
		public MonitoringDescriptionAttribute(string description){}
		public virtual string Description{ get	{} }
	}

	public class	Process: Component, IDisposable, IComponent
	{
		public void BeginErrorReadLine(){}
		public void CancelErrorRead(){}
		private void Process_free_internal(IntPtr handle){}
		protected virtual void Dispose(bool disposing){}
		protected virtual void Finalize(){}
		private static void CBOnExit(System.Object state, bool unused){}
		protected void OnExited(){}
		private void StartExitCallbackIfNeeded(){}
		private static int ExitCode_internal(IntPtr handle){}
		private static long ExitTime_internal(IntPtr handle){}
		private static bool GetWorkingSet_internal(IntPtr handle, out int min, out int max){}
		private static bool SetWorkingSet_internal(IntPtr handle, int min, int max, bool use_min){}
		private ProcessModule[] GetModules_internal(IntPtr handle){}
		private static long GetProcessData(int pid, int data_type, out int error){}
		private static int GetPriorityClass(IntPtr handle, out int error){}
		private static bool SetPriorityClass(IntPtr handle, int priority, out int error){}
		private static long Times(IntPtr handle, int type){}
		private static string ProcessName_internal(IntPtr handle){}
		private static long StartTime_internal(IntPtr handle){}
		public void Close(){}
		private static bool Kill_internal(IntPtr handle, int signo){}
		private bool Close(int signo){}
		public bool CloseMainWindow(){}
		public static void EnterDebugMode(){}
		private static IntPtr GetProcess_internal(int pid){}
		private static int GetPid_internal(){}
		public static Process GetCurrentProcess(){}
		public static Process GetProcessById(int processId){}
		public static Process GetProcessById(int processId, string machineName){}
		private static Int32[] GetProcesses_internal(){}
		public static Process[] GetProcesses(){}
		public static Process[] GetProcesses(string machineName){}
		public static Process[] GetProcessesByName(string processName){}
		public static Process[] GetProcessesByName(string processName, string machineName){}
		public void Kill(){}
		public static void LeaveDebugMode(){}
		public void Refresh(){}
		private static bool ShellExecuteEx_internal(ProcessStartInfo startInfo, ref ProcInfo proc_info){}
		private static bool CreateProcess_internal(ProcessStartInfo startInfo, IntPtr stdin, IntPtr stdout, IntPtr stderr, ref ProcInfo proc_info){}
		private static bool Start_shell(ProcessStartInfo startInfo, Process process){}
		private static bool Start_noshell(ProcessStartInfo startInfo, Process process){}
		private static void FillUserInfo(ProcessStartInfo startInfo, ref ProcInfo proc_info){}
		private static bool Start_common(ProcessStartInfo startInfo, Process process){}
		public bool Start(){}
		public static Process Start(ProcessStartInfo startInfo){}
		public static Process Start(string fileName){}
		public static Process Start(string fileName, string arguments){}
		public static Process Start(string fileName, string username, SecureString password, string domain){}
		public static Process Start(string fileName, string arguments, string username, SecureString password, string domain){}
		public virtual string ToString(){}
		private bool WaitForExit_internal(IntPtr handle, int ms){}
		public void WaitForExit(){}
		public bool WaitForExit(int milliseconds){}
		private bool WaitForInputIdle_internal(IntPtr handle, int ms){}
		public bool WaitForInputIdle(){}
		public bool WaitForInputIdle(int milliseconds){}
		private static bool IsLocalMachine(string machineName){}
		private void OnOutputDataReceived(string str){}
		private void OnErrorDataReceived(string str){}
		public void BeginOutputReadLine(){}
		public void CancelOutputRead(){}
		private Process(IntPtr handle, int id){}
		public Process(){}
		public int BasePriority{ get	{} }
		public bool EnableRaisingEvents{ get	{} set	{} }
		public int ExitCode{ get	{} }
		public DateTime ExitTime{ get	{} }
		public IntPtr Handle{ get	{} }
		public int HandleCount{ get	{} }
		public bool HasExited{ get	{} }
		public int Id{ get	{} }
		public string MachineName{ get	{} }
		public ProcessModule MainModule{ get	{} }
		public IntPtr MainWindowHandle{ get	{} }
		public string MainWindowTitle{ get	{} }
		public IntPtr MaxWorkingSet{ get	{} set	{} }
		public IntPtr MinWorkingSet{ get	{} set	{} }
		public ProcessModuleCollection Modules{ get	{} }
		public int NonpagedSystemMemorySize{ get	{} }
		public int PagedMemorySize{ get	{} }
		public int PagedSystemMemorySize{ get	{} }
		public int PeakPagedMemorySize{ get	{} }
		public int PeakVirtualMemorySize{ get	{} }
		public int PeakWorkingSet{ get	{} }
		public long NonpagedSystemMemorySize64{ get	{} }
		public long PagedMemorySize64{ get	{} }
		public long PagedSystemMemorySize64{ get	{} }
		public long PeakPagedMemorySize64{ get	{} }
		public long PeakVirtualMemorySize64{ get	{} }
		public long PeakWorkingSet64{ get	{} }
		public bool PriorityBoostEnabled{ get	{} set	{} }
		public ProcessPriorityClass PriorityClass{ get	{} set	{} }
		public int PrivateMemorySize{ get	{} }
		public int SessionId{ get	{} }
		public TimeSpan PrivilegedProcessorTime{ get	{} }
		public string ProcessName{ get	{} }
		public IntPtr ProcessorAffinity{ get	{} set	{} }
		public bool Responding{ get	{} }
		public StreamReader StandardError{ get	{} }
		public StreamWriter StandardInput{ get	{} }
		public StreamReader StandardOutput{ get	{} }
		public ProcessStartInfo StartInfo{ get	{} set	{} }
		public DateTime StartTime{ get	{} }
		public ISynchronizeInvoke SynchronizingObject{ get	{} set	{} }
		public ProcessThreadCollection Threads{ get	{} }
		public TimeSpan TotalProcessorTime{ get	{} }
		public TimeSpan UserProcessorTime{ get	{} }
		public int VirtualMemorySize{ get	{} }
		public int WorkingSet{ get	{} }
		public long PrivateMemorySize64{ get	{} }
		public long VirtualMemorySize64{ get	{} }
		public long WorkingSet64{ get	{} }
		bool IsWindows{ get	{} }
		public event	DataReceivedEventHandler OutputDataReceived;
		public event	DataReceivedEventHandler ErrorDataReceived;
		public event	EventHandler Exited;
		private IntPtr process_handle;
		private int pid;
		private bool enableRaisingEvents;
		private bool already_waiting;
		private ISynchronizeInvoke synchronizingObject;
		private EventHandler exited_event;
		private IntPtr stdout_rd;
		private IntPtr stderr_rd;
		private ProcessModuleCollection module_collection;
		private string process_name;
		private StreamReader error_stream;
		private StreamWriter input_stream;
		private StreamReader output_stream;
		private ProcessStartInfo start_info;
		private AsyncModes async_mode;
		private bool output_canceled;
		private bool error_canceled;
		private ProcessAsyncReader async_output;
		private ProcessAsyncReader async_error;
		private bool disposed;
	}

	public class	ProcessModule: Component, IDisposable, IComponent
	{
		public virtual string ToString(){}
		internal ProcessModule(IntPtr baseaddr, IntPtr entryaddr, string filename, FileVersionInfo version_info, int memory_size, string modulename){}
		public IntPtr BaseAddress{ get	{} }
		public IntPtr EntryPointAddress{ get	{} }
		public string FileName{ get	{} }
		public FileVersionInfo FileVersionInfo{ get	{} }
		public int ModuleMemorySize{ get	{} }
		public string ModuleName{ get	{} }
		private IntPtr baseaddr;
		private IntPtr entryaddr;
		private string filename;
		private FileVersionInfo version_info;
		private int memory_size;
		private string modulename;
	}

	public class	ProcessModuleCollectionBase: List<ProcessModule>, IList<ProcessModule>, ICollection<ProcessModule>, IEnumerable<ProcessModule>, IEnumerable, IList, ICollection
	{
		public ProcessModuleCollectionBase(){}
		ProcessModuleCollectionBase InnerList{ get	{} }
	}

	public class	ProcessModuleCollection: ProcessModuleCollectionBase, IList<ProcessModule>, ICollection<ProcessModule>, IEnumerable<ProcessModule>, IEnumerable, IList, ICollection
	{
		public bool Contains(ProcessModule module){}
		public void CopyTo(ProcessModule[] array, int index){}
		public int IndexOf(ProcessModule module){}
		protected ProcessModuleCollection(){}
		public ProcessModuleCollection(ProcessModule[] processModules){}
		public ProcessModule this[int index] { get	{} }
	}

	public sealed class	ProcessStartInfo: Object
	{
		public ProcessStartInfo(){}
		public ProcessStartInfo(string filename){}
		public ProcessStartInfo(string filename, string arguments){}
		private static ProcessStartInfo(){}
		public string Arguments{ get	{} set	{} }
		public bool CreateNoWindow{ get	{} set	{} }
		public StringDictionary EnvironmentVariables{ get	{} }
		bool HaveEnvVars{ get	{} }
		public bool ErrorDialog{ get	{} set	{} }
		public IntPtr ErrorDialogParentHandle{ get	{} set	{} }
		public string FileName{ get	{} set	{} }
		public bool RedirectStandardError{ get	{} set	{} }
		public bool RedirectStandardInput{ get	{} set	{} }
		public bool RedirectStandardOutput{ get	{} set	{} }
		public Encoding StandardErrorEncoding{ get	{} set	{} }
		public Encoding StandardOutputEncoding{ get	{} set	{} }
		public bool UseShellExecute{ get	{} set	{} }
		public string Verb{ get	{} set	{} }
		public String[] Verbs{ get	{} }
		public ProcessWindowStyle WindowStyle{ get	{} set	{} }
		public string WorkingDirectory{ get	{} set	{} }
		public bool LoadUserProfile{ get	{} set	{} }
		public string UserName{ get	{} set	{} }
		public string Domain{ get	{} set	{} }
		public SecureString Password{ get	{} set	{} }
		private string arguments;
		private IntPtr error_dialog_parent_handle;
		private string filename;
		private string verb;
		private string working_directory;
		private ProcessStringDictionary envVars;
		private bool create_no_window;
		private bool error_dialog;
		private bool redirect_standard_error;
		private bool redirect_standard_input;
		private bool redirect_standard_output;
		private bool use_shell_execute;
		private ProcessWindowStyle window_style;
		private Encoding encoding_stderr;
		private Encoding encoding_stdout;
		private string username;
		private string domain;
		private SecureString password;
		private bool load_user_profile;
		private readonly static String[] empty;
	}

	public class	ProcessThread: Component, IDisposable, IComponent
	{
		public void ResetIdealProcessor(){}
		internal ProcessThread(){}
		public int BasePriority{ get	{} }
		public int CurrentPriority{ get	{} }
		public int Id{ get	{} }
		public int IdealProcessor{ set	{} }
		public bool PriorityBoostEnabled{ get	{} set	{} }
		public ThreadPriorityLevel PriorityLevel{ get	{} set	{} }
		public TimeSpan PrivilegedProcessorTime{ get	{} }
		public IntPtr ProcessorAffinity{ set	{} }
		public IntPtr StartAddress{ get	{} }
		public DateTime StartTime{ get	{} }
		public ThreadState ThreadState{ get	{} }
		public TimeSpan TotalProcessorTime{ get	{} }
		public TimeSpan UserProcessorTime{ get	{} }
		public ThreadWaitReason WaitReason{ get	{} }
	}

	public class	ProcessThreadCollectionBase: List<ProcessThread>, IList<ProcessThread>, ICollection<ProcessThread>, IEnumerable<ProcessThread>, IEnumerable, IList, ICollection
	{
		public int Add(ProcessThread thread){}
		public ProcessThreadCollectionBase(){}
		ProcessThreadCollectionBase InnerList{ get	{} }
	}

	public class	ProcessThreadCollection: ProcessThreadCollectionBase, IList<ProcessThread>, ICollection<ProcessThread>, IEnumerable<ProcessThread>, IEnumerable, IList, ICollection
	{
		internal static ProcessThreadCollection GetEmpty(){}
		public int Add(ProcessThread thread){}
		public bool Contains(ProcessThread thread){}
		public void CopyTo(ProcessThread[] array, int index){}
		public int IndexOf(ProcessThread thread){}
		public void Insert(int index, ProcessThread thread){}
		public void Remove(ProcessThread thread){}
		protected ProcessThreadCollection(){}
		public ProcessThreadCollection(ProcessThread[] processThreads){}
		public ProcessThread this[int index] { get	{} }
	}

	public class	SourceFilter: TraceFilter
	{
		public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, System.Object data1, Object[] data){}
		public SourceFilter(string source){}
		public string Source{ get	{} set	{} }
		private string source;
	}

	public class	SourceSwitch: Switch
	{
		public bool ShouldTrace(TraceEventType eventType){}
		protected virtual void OnValueChanged(){}
		public SourceSwitch(string displayName){}
		public SourceSwitch(string displayName, string defaultSwitchValue){}
		public SourceLevels Level{ get	{} set	{} }
		private const string description = null;
	}

	public class	Stopwatch: Object
	{
		public static long GetTimestamp(){}
		public static Stopwatch StartNew(){}
		public void Reset(){}
		public void Start(){}
		public void Stop(){}
		public Stopwatch(){}
		private static Stopwatch(){}
		public TimeSpan Elapsed{ get	{} }
		public long ElapsedMilliseconds{ get	{} }
		public long ElapsedTicks{ get	{} }
		public bool IsRunning{ get	{} }
		private long elapsed;
		private long started;
		private bool is_running;
		public readonly static long Frequency;
		public readonly static bool IsHighResolution;
	}

	public abstract	class	Switch: Object
	{
		protected virtual String[] GetSupportedAttributes(){}
		protected virtual void OnValueChanged(){}
		private void GetConfigFileSetting(){}
		protected virtual void OnSwitchSettingChanged(){}
		protected Switch(string displayName, string description){}
		protected Switch(string displayName, string description, string defaultSwitchValue){}
		public string Description{ get	{} }
		public string DisplayName{ get	{} }
		int SwitchSetting{ get	{} set	{} }
		public StringDictionary Attributes{ get	{} }
		string Value{ get	{} set	{} }
		private string name;
		private string description;
		private int switchSetting;
		private string value;
		private string defaultSwitchValue;
		private bool initialized;
		private StringDictionary attributes;
	}

	public sealed class	SwitchLevelAttribute: Attribute, _Attribute
	{
		public SwitchLevelAttribute(Type switchLevelType){}
		public Type SwitchLevelType{ get	{} set	{} }
		private Type type;
	}

	public class	TextWriterTraceListener: TraceListener, IDisposable
	{
		public virtual void Close(){}
		protected virtual void Dispose(bool disposing){}
		public virtual void Flush(){}
		public virtual void Write(string message){}
		public virtual void WriteLine(string message){}
		public TextWriterTraceListener(){}
		public TextWriterTraceListener(Stream stream){}
		public TextWriterTraceListener(string fileName){}
		public TextWriterTraceListener(TextWriter writer){}
		public TextWriterTraceListener(Stream stream, string name){}
		public TextWriterTraceListener(string fileName, string name){}
		public TextWriterTraceListener(TextWriter writer, string name){}
		public TextWriter Writer{ get	{} set	{} }
		private TextWriter writer;
	}

	public sealed class	Trace: Object
	{
		public static void Refresh(){}
		public static void Assert(bool condition){}
		public static void Assert(bool condition, string message){}
		public static void Assert(bool condition, string message, string detailMessage){}
		public static void Close(){}
		public static void Fail(string message){}
		public static void Fail(string message, string detailMessage){}
		public static void Flush(){}
		public static void Indent(){}
		public static void Unindent(){}
		public static void Write(System.Object value){}
		public static void Write(string message){}
		public static void Write(System.Object value, string category){}
		public static void Write(string message, string category){}
		public static void WriteIf(bool condition, System.Object value){}
		public static void WriteIf(bool condition, string message){}
		public static void WriteIf(bool condition, System.Object value, string category){}
		public static void WriteIf(bool condition, string message, string category){}
		public static void WriteLine(System.Object value){}
		public static void WriteLine(string message){}
		public static void WriteLine(System.Object value, string category){}
		public static void WriteLine(string message, string category){}
		public static void WriteLineIf(bool condition, System.Object value){}
		public static void WriteLineIf(bool condition, string message){}
		public static void WriteLineIf(bool condition, System.Object value, string category){}
		public static void WriteLineIf(bool condition, string message, string category){}
		private static void DoTrace(string kind, Assembly report, string message){}
		public static void TraceError(string message){}
		public static void TraceError(string message, Object[] args){}
		public static void TraceInformation(string message){}
		public static void TraceInformation(string message, Object[] args){}
		public static void TraceWarning(string message){}
		public static void TraceWarning(string message, Object[] args){}
		private Trace(){}
		public static bool AutoFlush{ get	{} set	{} }
		public static int IndentLevel{ get	{} set	{} }
		public static int IndentSize{ get	{} set	{} }
		public static TraceListenerCollection Listeners{ get	{} }
		public static CorrelationManager CorrelationManager{ get	{} }
		public static bool UseGlobalLock{ get	{} set	{} }
	}

	public class	TraceEventCache: Object
	{
		public TraceEventCache(){}
		public string Callstack{ get	{} }
		public DateTime DateTime{ get	{} }
		public Stack LogicalOperationStack{ get	{} }
		public int ProcessId{ get	{} }
		public string ThreadId{ get	{} }
		public long Timestamp{ get	{} }
		private DateTime started;
		private CorrelationManager manager;
		private string callstack;
		private string thread;
		private int process;
		private long timestamp;
	}

	public abstract	class	TraceFilter: Object
	{
		public abstract virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, System.Object data1, Object[] data);
		protected TraceFilter(){}
	}

	public abstract	class	TraceListener: MarshalByRefObject, IDisposable
	{
		public virtual void Close(){}
		public sealed virtual void Dispose(){}
		protected virtual void Dispose(bool disposing){}
		public virtual void Fail(string message){}
		public virtual void Fail(string message, string detailMessage){}
		public virtual void Flush(){}
		public virtual void Write(System.Object o){}
		public abstract virtual void Write(string message);
		public virtual void Write(System.Object o, string category){}
		public virtual void Write(string message, string category){}
		protected virtual void WriteIndent(){}
		public virtual void WriteLine(System.Object o){}
		public abstract virtual void WriteLine(string message);
		public virtual void WriteLine(System.Object o, string category){}
		public virtual void WriteLine(string message, string category){}
		internal static string FormatArray(ICollection list, string joiner){}
		public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, System.Object data){}
		public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data){}
		public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id){}
		public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message){}
		public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args){}
		public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId){}
		protected virtual String[] GetSupportedAttributes(){}
		protected TraceListener(){}
		protected TraceListener(string name){}
		public int IndentLevel{ get	{} set	{} }
		public int IndentSize{ get	{} set	{} }
		public virtual string Name{ get	{} set	{} }
		bool NeedIndent{ get	{} set	{} }
		public virtual bool IsThreadSafe{ get	{} }
		public StringDictionary Attributes{ get	{} }
		public TraceFilter Filter{ get	{} set	{} }
		public TraceOptions TraceOutputOptions{ get	{} set	{} }
		private int indentLevel;
		private int indentSize;
		private StringDictionary attributes;
		private TraceFilter filter;
		private TraceOptions options;
		private string name;
		private bool needIndent;
	}

	public class	TraceListenerCollection: Object, ICollection, IEnumerable, IList
	{
		private sealed virtual System.Object System.Collections.IList.get_Item(int index){}
		private sealed virtual void System.Collections.IList.set_Item(int index, System.Object value){}
		private sealed virtual bool System.Collections.ICollection.get_IsSynchronized(){}
		private sealed virtual System.Object System.Collections.ICollection.get_SyncRoot(){}
		private sealed virtual bool System.Collections.IList.get_IsFixedSize(){}
		private sealed virtual bool System.Collections.IList.get_IsReadOnly(){}
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual int System.Collections.IList.Add(System.Object value){}
		private sealed virtual bool System.Collections.IList.Contains(System.Object value){}
		private sealed virtual int System.Collections.IList.IndexOf(System.Object value){}
		private sealed virtual void System.Collections.IList.Insert(int index, System.Object value){}
		private sealed virtual void System.Collections.IList.Remove(System.Object value){}
		public int Add(TraceListener listener){}
		internal void Add(TraceListener listener, TraceImplSettings settings){}
		private void InitializeListener(TraceListener listener){}
		private void InitializeRange(IList listeners){}
		public void AddRange(TraceListener[] value){}
		public void AddRange(TraceListenerCollection value){}
		public sealed virtual void Clear(){}
		public bool Contains(TraceListener listener){}
		public void CopyTo(TraceListener[] listeners, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		public int IndexOf(TraceListener listener){}
		public void Insert(int index, TraceListener listener){}
		public void Remove(string name){}
		public void Remove(TraceListener listener){}
		public sealed virtual void RemoveAt(int index){}
		internal TraceListenerCollection(){}
		internal TraceListenerCollection(bool addDefault){}
		System.Object this[int index] { get	{} set	{} }
		bool System.Collections.ICollection.IsSynchronized{ get	{} }
		System.Object System.Collections.ICollection.SyncRoot{ get	{} }
		bool System.Collections.IList.IsFixedSize{ get	{} }
		bool System.Collections.IList.IsReadOnly{ get	{} }
		public sealed virtual int Count{ get	{} }
		public TraceListener this[string name] { get	{} }
		public TraceListener this[int index] { get	{} set	{} }
		private ArrayList listeners;
	}

	public class	TraceSource: Object
	{
		public void Close(){}
		public void Flush(){}
		public void TraceData(TraceEventType eventType, int id, System.Object data){}
		public void TraceData(TraceEventType eventType, int id, Object[] data){}
		public void TraceEvent(TraceEventType eventType, int id){}
		public void TraceEvent(TraceEventType eventType, int id, string message){}
		public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args){}
		public void TraceInformation(string format){}
		public void TraceInformation(string format, Object[] args){}
		public void TraceTransfer(int id, string message, Guid relatedActivityId){}
		protected virtual String[] GetSupportedAttributes(){}
		public TraceSource(string name){}
		public TraceSource(string name, SourceLevels sourceLevels){}
		public StringDictionary Attributes{ get	{} }
		public TraceListenerCollection Listeners{ get	{} }
		public string Name{ get	{} }
		public SourceSwitch Switch{ get	{} set	{} }
		private SourceSwitch source_switch;
		private TraceListenerCollection listeners;
	}

	public class	TraceSwitch: Switch
	{
		protected virtual void OnSwitchSettingChanged(){}
		protected virtual void OnValueChanged(){}
		public TraceSwitch(string displayName, string description){}
		public TraceSwitch(string displayName, string description, string defaultSwitchValue){}
		public TraceLevel Level{ get	{} set	{} }
		public bool TraceError{ get	{} }
		public bool TraceWarning{ get	{} }
		public bool TraceInfo{ get	{} }
		public bool TraceVerbose{ get	{} }
	}

	delegate void AsyncReadHandler();

	delegate void DataReceivedEventHandler(System.Object sender, DataReceivedEventArgs e);

}

namespace System.IO.Compression {
	public class	DeflateStream: Stream, IDisposable
	{
		protected virtual void Dispose(bool disposing){}
		private static int UnmanagedRead(IntPtr buffer, int length, IntPtr data){}
		private int UnmanagedRead(IntPtr buffer, int length){}
		private static int UnmanagedWrite(IntPtr buffer, int length, IntPtr data){}
		private int UnmanagedWrite(IntPtr buffer, int length){}
		private int ReadInternal(Byte[] array, int offset, int count){}
		public virtual int Read(Byte[] dest, int dest_offset, int count){}
		private void WriteInternal(Byte[] array, int offset, int count){}
		public virtual void Write(Byte[] src, int src_offset, int count){}
		private static void CheckResult(int result, string where){}
		public virtual void Flush(){}
		public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, System.Object state){}
		public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, System.Object state){}
		public virtual int EndRead(IAsyncResult async_result){}
		public virtual void EndWrite(IAsyncResult async_result){}
		public virtual long Seek(long offset, SeekOrigin origin){}
		public virtual void SetLength(long value){}
		private static IntPtr CreateZStream(CompressionMode compress, bool gzip, UnmanagedReadOrWrite feeder, IntPtr data){}
		private static int CloseZStream(IntPtr stream){}
		private static int Flush(IntPtr stream){}
		private static int ReadZStream(IntPtr stream, IntPtr buffer, int length){}
		private static int WriteZStream(IntPtr stream, IntPtr buffer, int length){}
		public DeflateStream(Stream compressedStream, CompressionMode mode){}
		public DeflateStream(Stream compressedStream, CompressionMode mode, bool leaveOpen){}
		internal DeflateStream(Stream compressedStream, CompressionMode mode, bool leaveOpen, bool gzip){}
		public Stream BaseStream{ get	{} }
		public virtual bool CanRead{ get	{} }
		public virtual bool CanSeek{ get	{} }
		public virtual bool CanWrite{ get	{} }
		public virtual long Length{ get	{} }
		public virtual long Position{ get	{} set	{} }
		private Stream base_stream;
		private CompressionMode mode;
		private bool leaveOpen;
		private bool disposed;
		private UnmanagedReadOrWrite feeder;
		private IntPtr z_stream;
		private Byte[] io_buffer;
		private GCHandle data;
		private const int BufferSize = null;
		private const string LIBNAME = null;
	}

	public class	GZipStream: Stream, IDisposable
	{
		protected virtual void Dispose(bool disposing){}
		public virtual int Read(Byte[] dest, int dest_offset, int count){}
		public virtual void Write(Byte[] src, int src_offset, int count){}
		public virtual void Flush(){}
		public virtual long Seek(long offset, SeekOrigin origin){}
		public virtual void SetLength(long value){}
		public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, System.Object state){}
		public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, System.Object state){}
		public virtual int EndRead(IAsyncResult async_result){}
		public virtual void EndWrite(IAsyncResult async_result){}
		public GZipStream(Stream compressedStream, CompressionMode mode){}
		public GZipStream(Stream compressedStream, CompressionMode mode, bool leaveOpen){}
		public Stream BaseStream{ get	{} }
		public virtual bool CanRead{ get	{} }
		public virtual bool CanSeek{ get	{} }
		public virtual bool CanWrite{ get	{} }
		public virtual long Length{ get	{} }
		public virtual long Position{ get	{} set	{} }
		private DeflateStream deflateStream;
	}

	delegate int UnmanagedReadOrWrite(IntPtr buffer, int length, IntPtr data);

	delegate int ReadMethod(Byte[] array, int offset, int count);

	delegate void WriteMethod(Byte[] array, int offset, int count);

}

namespace System.IO {
	public class	ErrorEventArgs: EventArgs
	{
		public virtual Exception GetException(){}
		public ErrorEventArgs(Exception exception){}
		private Exception exception;
	}

	public class	FileSystemEventArgs: EventArgs
	{
		internal void SetName(string name){}
		public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name){}
		public WatcherChangeTypes ChangeType{ get	{} }
		public string FullPath{ get	{} }
		public string Name{ get	{} }
		private WatcherChangeTypes changeType;
		private string directory;
		private string name;
	}

	public class	FileSystemWatcher: Component, IDisposable, IComponent, ISupportInitialize
	{
		private void InitWatcher(){}
		private void ShowWatcherInfo(){}
		public sealed virtual void BeginInit(){}
		protected virtual void Dispose(bool disposing){}
		protected virtual void Finalize(){}
		public sealed virtual void EndInit(){}
		private void RaiseEvent(Delegate ev, EventArgs arg, EventType evtype){}
		protected void OnChanged(FileSystemEventArgs e){}
		protected void OnCreated(FileSystemEventArgs e){}
		protected void OnDeleted(FileSystemEventArgs e){}
		protected void OnError(ErrorEventArgs e){}
		protected void OnRenamed(RenamedEventArgs e){}
		public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType){}
		public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout){}
		internal void DispatchEvents(FileAction act, string filename, ref RenamedEventArgs renamed){}
		private void Start(){}
		private void Stop(){}
		private static int InternalSupportsFSW(){}
		public FileSystemWatcher(){}
		public FileSystemWatcher(string path){}
		public FileSystemWatcher(string path, string filter){}
		private static FileSystemWatcher(){}
		bool Waiting{ get	{} set	{} }
		string MangledFilter{ get	{} }
		SearchPattern2 Pattern{ get	{} }
		string FullPath{ get	{} }
		public bool EnableRaisingEvents{ get	{} set	{} }
		public string Filter{ get	{} set	{} }
		public bool IncludeSubdirectories{ get	{} set	{} }
		public int InternalBufferSize{ get	{} set	{} }
		public NotifyFilters NotifyFilter{ get	{} set	{} }
		public string Path{ get	{} set	{} }
		public virtual ISite Site{ get	{} set	{} }
		public ISynchronizeInvoke SynchronizingObject{ get	{} set	{} }
		public event	FileSystemEventHandler Changed;
		public event	FileSystemEventHandler Created;
		public event	FileSystemEventHandler Deleted;
		public event	ErrorEventHandler Error;
		public event	RenamedEventHandler Renamed;
		private bool enableRaisingEvents;
		private string filter;
		private bool includeSubdirectories;
		private int internalBufferSize;
		private NotifyFilters notifyFilter;
		private string path;
		private string fullpath;
		private ISynchronizeInvoke synchronizingObject;
		private WaitForChangedResult lastData;
		private bool waiting;
		private SearchPattern2 pattern;
		private bool disposed;
		private string mangledFilter;
		private static IFileWatcher watcher;
		private static System.Object lockobj;
	}

	public class	IODescriptionAttribute: DescriptionAttribute, _Attribute
	{
		public IODescriptionAttribute(string description){}
		public virtual string Description{ get	{} }
	}

	public class	RenamedEventArgs: FileSystemEventArgs
	{
		public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName){}
		public string OldFullPath{ get	{} }
		public string OldName{ get	{} }
		private string oldName;
		private string oldFullPath;
	}

	delegate void WriteDelegate(Byte[] buffer, int offset, int count);

	delegate int ReadDelegate(Byte[] buffer, int offset, int count);

	delegate void ErrorEventHandler(System.Object sender, ErrorEventArgs e);

	delegate void FileSystemEventHandler(System.Object sender, FileSystemEventArgs e);

	delegate void RenamedEventHandler(System.Object sender, RenamedEventArgs e);

}

namespace System.Net.Cache {
	public class	HttpRequestCachePolicy: RequestCachePolicy
	{
		public virtual string ToString(){}
		public HttpRequestCachePolicy(){}
		public HttpRequestCachePolicy(DateTime cacheSyncDate){}
		public HttpRequestCachePolicy(HttpRequestCacheLevel level){}
		public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale){}
		public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale){}
		public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate){}
		public DateTime CacheSyncDate{ get	{} }
		public HttpRequestCacheLevel Level{ get	{} }
		public TimeSpan MaxAge{ get	{} }
		public TimeSpan MaxStale{ get	{} }
		public TimeSpan MinFresh{ get	{} }
		private DateTime cacheSyncDate;
		private HttpRequestCacheLevel level;
		private TimeSpan maxAge;
		private TimeSpan maxStale;
		private TimeSpan minFresh;
	}

	public class	RequestCachePolicy: Object
	{
		public virtual string ToString(){}
		public RequestCachePolicy(){}
		public RequestCachePolicy(RequestCacheLevel level){}
		public RequestCacheLevel Level{ get	{} }
		private RequestCacheLevel level;
	}

}

namespace System.Net.Mail {
	public class	AlternateView: AttachmentBase, IDisposable
	{
		public static AlternateView CreateAlternateViewFromString(string content){}
		public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType){}
		public static AlternateView CreateAlternateViewFromString(string content, Encoding encoding, string mediaType){}
		protected virtual void Dispose(bool disposing){}
		public AlternateView(string fileName){}
		public AlternateView(string fileName, ContentType contentType){}
		public AlternateView(string fileName, string mediaType){}
		public AlternateView(Stream contentStream){}
		public AlternateView(Stream contentStream, string mediaType){}
		public AlternateView(Stream contentStream, ContentType contentType){}
		public Uri BaseUri{ get	{} set	{} }
		public LinkedResourceCollection LinkedResources{ get	{} }
		private Uri baseUri;
		private LinkedResourceCollection linkedResources;
	}

	public sealed class	AlternateViewCollection: Collection<AlternateView>, IList<AlternateView>, ICollection<AlternateView>, IEnumerable<AlternateView>, IEnumerable, IList, ICollection, IDisposable
	{
		public sealed virtual void Dispose(){}
		protected virtual void ClearItems(){}
		protected virtual void InsertItem(int index, AlternateView item){}
		protected virtual void RemoveItem(int index){}
		protected virtual void SetItem(int index, AlternateView item){}
		internal AlternateViewCollection(){}
	}

	public class	Attachment: AttachmentBase, IDisposable
	{
		public static Attachment CreateAttachmentFromString(string content, ContentType contentType){}
		public static Attachment CreateAttachmentFromString(string content, string name){}
		public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType){}
		private void InitName(string fileName){}
		public Attachment(string fileName){}
		public Attachment(string fileName, string mediaType){}
		public Attachment(string fileName, ContentType contentType){}
		public Attachment(Stream contentStream, ContentType contentType){}
		public Attachment(Stream contentStream, string name){}
		public Attachment(Stream contentStream, string name, string mediaType){}
		public ContentDisposition ContentDisposition{ get	{} }
		public string Name{ get	{} set	{} }
		public Encoding NameEncoding{ get	{} set	{} }
		private ContentDisposition contentDisposition;
		private Encoding nameEncoding;
	}

	public abstract	class	AttachmentBase: Object, IDisposable
	{
		public sealed virtual void Dispose(){}
		protected virtual void Dispose(bool disposing){}
		protected AttachmentBase(Stream contentStream){}
		protected AttachmentBase(Stream contentStream, ContentType contentType){}
		protected AttachmentBase(Stream contentStream, string mediaType){}
		protected AttachmentBase(string fileName){}
		protected AttachmentBase(string fileName, ContentType contentType){}
		protected AttachmentBase(string fileName, string mediaType){}
		public string ContentId{ get	{} set	{} }
		public Stream ContentStream{ get	{} }
		public ContentType ContentType{ get	{} set	{} }
		public TransferEncoding TransferEncoding{ get	{} set	{} }
		private string id;
		private ContentType contentType;
		private Stream contentStream;
		private TransferEncoding transferEncoding;
	}

	public sealed class	AttachmentCollection: Collection<Attachment>, IList<Attachment>, ICollection<Attachment>, IEnumerable<Attachment>, IEnumerable, IList, ICollection, IDisposable
	{
		public sealed virtual void Dispose(){}
		protected virtual void ClearItems(){}
		protected virtual void InsertItem(int index, Attachment item){}
		protected virtual void RemoveItem(int index){}
		protected virtual void SetItem(int index, Attachment item){}
		internal AttachmentCollection(){}
	}

	public class	LinkedResource: AttachmentBase, IDisposable
	{
		public static LinkedResource CreateLinkedResourceFromString(string content){}
		public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType){}
		public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType){}
		public LinkedResource(string fileName){}
		public LinkedResource(string fileName, ContentType contentType){}
		public LinkedResource(string fileName, string mediaType){}
		public LinkedResource(Stream contentStream){}
		public LinkedResource(Stream contentStream, ContentType contentType){}
		public LinkedResource(Stream contentStream, string mediaType){}
		public Uri ContentLink{ get	{} set	{} }
		private Uri contentLink;
	}

	public sealed class	LinkedResourceCollection: Collection<LinkedResource>, IList<LinkedResource>, ICollection<LinkedResource>, IEnumerable<LinkedResource>, IEnumerable, IList, ICollection, IDisposable
	{
		public sealed virtual void Dispose(){}
		private void Dispose(bool disposing){}
		protected virtual void ClearItems(){}
		protected virtual void InsertItem(int index, LinkedResource item){}
		protected virtual void RemoveItem(int index){}
		protected virtual void SetItem(int index, LinkedResource item){}
		internal LinkedResourceCollection(){}
	}

	public class	MailAddress: Object
	{
		public virtual bool Equals(System.Object obj){}
		private bool Equals(MailAddress other){}
		public virtual int GetHashCode(){}
		public virtual string ToString(){}
		private static FormatException CreateFormatException(){}
		public MailAddress(string address){}
		public MailAddress(string address, string displayName){}
		public MailAddress(string address, string displayName, Encoding displayNameEncoding){}
		public string Address{ get	{} }
		public string DisplayName{ get	{} }
		public string Host{ get	{} }
		public string User{ get	{} }
		private string address;
		private string displayName;
	}

	public class	MailAddressCollection: Collection<MailAddress>, IList<MailAddress>, ICollection<MailAddress>, IEnumerable<MailAddress>, IEnumerable, IList, ICollection
	{
		public void Add(string addresses){}
		protected virtual void InsertItem(int index, MailAddress item){}
		protected virtual void SetItem(int index, MailAddress item){}
		public virtual string ToString(){}
		public MailAddressCollection(){}
	}

	public class	MailMessage: Object, IDisposable
	{
		public sealed virtual void Dispose(){}
		protected virtual void Dispose(bool disposing){}
		private Encoding GuessEncoding(string s){}
		public MailMessage(){}
		public MailMessage(MailAddress from, MailAddress to){}
		public MailMessage(string from, string to){}
		public MailMessage(string from, string to, string subject, string body){}
		public AlternateViewCollection AlternateViews{ get	{} }
		public AttachmentCollection Attachments{ get	{} }
		public MailAddressCollection Bcc{ get	{} }
		public string Body{ get	{} set	{} }
		ContentType BodyContentType{ get	{} }
		TransferEncoding ContentTransferEncoding{ get	{} }
		public Encoding BodyEncoding{ get	{} set	{} }
		public MailAddressCollection CC{ get	{} }
		public DeliveryNotificationOptions DeliveryNotificationOptions{ get	{} set	{} }
		public MailAddress From{ get	{} set	{} }
		public NameValueCollection Headers{ get	{} }
		public bool IsBodyHtml{ get	{} set	{} }
		public MailPriority Priority{ get	{} set	{} }
		Encoding HeadersEncoding{ get	{} set	{} }
		MailAddressCollection ReplyToList{ get	{} }
		public MailAddress ReplyTo{ get	{} set	{} }
		public MailAddress Sender{ get	{} set	{} }
		public string Subject{ get	{} set	{} }
		public Encoding SubjectEncoding{ get	{} set	{} }
		public MailAddressCollection To{ get	{} }
		private AlternateViewCollection alternateViews;
		private AttachmentCollection attachments;
		private MailAddressCollection bcc;
		private MailAddressCollection replyTo;
		private string body;
		private MailPriority priority;
		private MailAddress sender;
		private DeliveryNotificationOptions deliveryNotificationOptions;
		private MailAddressCollection cc;
		private MailAddress from;
		private NameValueCollection headers;
		private MailAddressCollection to;
		private string subject;
		private Encoding subjectEncoding;
		private Encoding bodyEncoding;
		private Encoding headersEncoding;
		private bool isHtml;
	}

	public class	SmtpClient: Object
	{
		private void CheckState(){}
		private static string EncodeAddress(MailAddress address){}
		private static string EncodeAddresses(MailAddressCollection addresses){}
		private string EncodeSubjectRFC2047(MailMessage message){}
		private string EncodeBody(MailMessage message){}
		private string EncodeBody(AlternateView av){}
		private void EndSection(string section){}
		private string GenerateBoundary(){}
		private static string GenerateBoundary(int index){}
		private bool IsError(SmtpResponse status){}
		protected void OnSendCompleted(AsyncCompletedEventArgs e){}
		private void CheckCancellation(){}
		private SmtpResponse Read(){}
		private void ResetExtensions(){}
		private void ParseExtensions(string extens){}
		public void Send(MailMessage message){}
		private void SendInternal(MailMessage message){}
		private void SendToFile(MailMessage message){}
		private void SendCore(MailMessage message){}
		public void Send(string from, string to, string subject, string body){}
		private void SendDot(){}
		private void SendData(string data){}
		public void SendAsync(MailMessage message, System.Object userToken){}
		public void SendAsync(string from, string to, string subject, string body, System.Object userToken){}
		public void SendAsyncCancel(){}
		private void AddPriorityHeader(MailMessage message){}
		private void SendSimpleBody(MailMessage message){}
		private void SendBodylessSingleAlternate(AlternateView av){}
		private void SendWithoutAttachments(MailMessage message, string boundary, bool attachmentExists){}
		private void SendWithAttachments(MailMessage message){}
		private void SendBodyWithAlternateViews(MailMessage message, string boundary, bool attachmentExists){}
		private void SendLinkedResources(MailMessage message, LinkedResourceCollection resources, string boundary){}
		private void SendAttachments(MailMessage message, Attachment body, string boundary){}
		private SmtpResponse SendCommand(string command){}
		private void SendHeader(string name, string value){}
		private void StartSection(string section, ContentType sectionContentType){}
		private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding){}
		private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding, LinkedResource lr){}
		private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding, ContentDisposition contentDisposition){}
		private string ToQuotedPrintable(string input, Encoding enc){}
		private string ToQuotedPrintable(Byte[] bytes){}
		private static string GetTransferEncodingName(TransferEncoding encoding){}
		private void InitiateSecureConnection(){}
		private void Authenticate(){}
		private void Authenticate(string Username, string Password){}
		private static bool <callback>m__2(System.Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors){}
		public SmtpClient(){}
		public SmtpClient(string host){}
		public SmtpClient(string host, int port){}
		public X509CertificateCollection ClientCertificates{ get	{} }
		string TargetName{ get	{} set	{} }
		public ICredentialsByHost Credentials{ get	{} set	{} }
		public SmtpDeliveryMethod DeliveryMethod{ get	{} set	{} }
		public bool EnableSsl{ get	{} set	{} }
		public string Host{ get	{} set	{} }
		public string PickupDirectoryLocation{ get	{} set	{} }
		public int Port{ get	{} set	{} }
		public ServicePoint ServicePoint{ get	{} }
		public int Timeout{ get	{} set	{} }
		public bool UseDefaultCredentials{ get	{} set	{} }
		public event	SendCompletedEventHandler SendCompleted;
		private string host;
		private int port;
		private int timeout;
		private ICredentialsByHost credentials;
		private string pickupDirectoryLocation;
		private SmtpDeliveryMethod deliveryMethod;
		private bool enableSsl;
		private X509CertificateCollection clientCertificates;
		private TcpClient client;
		private Stream stream;
		private StreamWriter writer;
		private StreamReader reader;
		private int boundaryIndex;
		private MailAddress defaultFrom;
		private MailMessage messageInProcess;
		private BackgroundWorker worker;
		private System.Object user_async_state;
		private AuthMechs authMechs;
		private Mutex mutex;
		private RemoteCertificateValidationCallback callback;
		private string <TargetName>k__BackingField;
		private static RemoteCertificateValidationCallback <>f__am$cache16;
		private static Dictionary<String, Int32> <>f__switch$map2;
	}

	public class	SmtpException: Exception, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public SmtpException(){}
		public SmtpException(SmtpStatusCode statusCode){}
		public SmtpException(string message){}
		protected SmtpException(SerializationInfo info, StreamingContext context){}
		public SmtpException(SmtpStatusCode statusCode, string message){}
		public SmtpException(string message, Exception innerException){}
		public SmtpStatusCode StatusCode{ get	{} set	{} }
		private SmtpStatusCode statusCode;
	}

	public class	SmtpFailedRecipientException: SmtpException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public SmtpFailedRecipientException(){}
		public SmtpFailedRecipientException(string message){}
		protected SmtpFailedRecipientException(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient){}
		public SmtpFailedRecipientException(string message, Exception innerException){}
		public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException){}
		public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse){}
		public string FailedRecipient{ get	{} }
		private string failedRecipient;
	}

	public class	SmtpFailedRecipientsException: SmtpFailedRecipientException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context){}
		public SmtpFailedRecipientsException(){}
		public SmtpFailedRecipientsException(string message){}
		public SmtpFailedRecipientsException(string message, Exception innerException){}
		public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions){}
		protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context){}
		public SmtpFailedRecipientException[] InnerExceptions{ get	{} }
		private SmtpFailedRecipientException[] innerExceptions;
	}

	delegate void SendCompletedEventHandler(System.Object sender, AsyncCompletedEventArgs e);

}

namespace System.Net.Mime {
	public class	ContentDisposition: Object
	{
		private void Parse(string pair){}
		public virtual bool Equals(System.Object obj){}
		private bool Equals(ContentDisposition other){}
		public virtual int GetHashCode(){}
		public virtual string ToString(){}
		public ContentDisposition(){}
		public ContentDisposition(string disposition){}
		public DateTime CreationDate{ get	{} set	{} }
		public string DispositionType{ get	{} set	{} }
		public string FileName{ get	{} set	{} }
		public bool Inline{ get	{} set	{} }
		public DateTime ModificationDate{ get	{} set	{} }
		public StringDictionary Parameters{ get	{} }
		public DateTime ReadDate{ get	{} set	{} }
		public long Size{ get	{} set	{} }
		private string dispositionType;
		private StringDictionary parameters;
		private const string rfc822 = null;
	}

	public class	ContentType: Object
	{
		private void Parse(string pair){}
		public virtual bool Equals(System.Object obj){}
		private bool Equals(ContentType other){}
		public virtual int GetHashCode(){}
		public virtual string ToString(){}
		private static string WrapIfEspecialsExist(string s){}
		internal static Encoding GuessEncoding(string s){}
		internal static TransferEncoding GuessTransferEncoding(Encoding enc){}
		internal static string To2047(Byte[] bytes){}
		internal static string EncodeSubjectRFC2047(string s, Encoding enc){}
		public ContentType(){}
		public ContentType(string contentType){}
		private static ContentType(){}
		Encoding UTF8Unmarked{ get	{} }
		public string Boundary{ get	{} set	{} }
		public string CharSet{ get	{} set	{} }
		public string MediaType{ get	{} set	{} }
		public string Name{ get	{} set	{} }
		public StringDictionary Parameters{ get	{} }
		private string mediaType;
		private StringDictionary parameters;
		private static Encoding utf8unmarked;
		private readonly static Char[] especials;
	}

	public sealed abstract	class	DispositionTypeNames: Object
	{
		public const string Attachment = null;
		public const string Inline = null;
	}

	public sealed abstract	class	MediaTypeNames: Object
	{
	}

}

namespace System.Net.NetworkInformation {
	public abstract	class	GatewayIPAddressInformation: Object
	{
		protected GatewayIPAddressInformation(){}
		public abstract virtual IPAddress Address{ get	{} }
	}

	public class	GatewayIPAddressInformationCollection: Object, IEnumerable, IEnumerable<GatewayIPAddressInformation>, ICollection<GatewayIPAddressInformation>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public virtual void Add(GatewayIPAddressInformation address){}
		public virtual void Clear(){}
		public virtual bool Contains(GatewayIPAddressInformation address){}
		public virtual void CopyTo(GatewayIPAddressInformation[] array, int offset){}
		public virtual IEnumerator<GatewayIPAddressInformation> GetEnumerator(){}
		public virtual bool Remove(GatewayIPAddressInformation address){}
		protected GatewayIPAddressInformationCollection(){}
		public virtual int Count{ get	{} }
		public virtual bool IsReadOnly{ get	{} }
		public virtual GatewayIPAddressInformation this[int index] { get	{} }
		private List<GatewayIPAddressInformation> list;
	}

	public class	IPAddressCollection: Object, IEnumerable, ICollection<IPAddress>, IEnumerable<IPAddress>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		internal void SetReadOnly(){}
		public virtual void Add(IPAddress address){}
		public virtual void Clear(){}
		public virtual bool Contains(IPAddress address){}
		public virtual void CopyTo(IPAddress[] array, int offset){}
		public virtual IEnumerator<IPAddress> GetEnumerator(){}
		public virtual bool Remove(IPAddress address){}
		protected IPAddressCollection(){}
		public virtual int Count{ get	{} }
		public virtual bool IsReadOnly{ get	{} }
		public virtual IPAddress this[int index] { get	{} }
		private IList<IPAddress> list;
	}

	public abstract	class	IPAddressInformation: Object
	{
		protected IPAddressInformation(){}
		public abstract virtual IPAddress Address{ get	{} }
		public abstract virtual bool IsDnsEligible{ get	{} }
		public abstract virtual bool IsTransient{ get	{} }
	}

	public class	IPAddressInformationCollection: Object, IEnumerable, IEnumerable<IPAddressInformation>, ICollection<IPAddressInformation>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public virtual void Add(IPAddressInformation address){}
		public virtual void Clear(){}
		public virtual bool Contains(IPAddressInformation address){}
		public virtual void CopyTo(IPAddressInformation[] array, int offset){}
		public virtual IEnumerator<IPAddressInformation> GetEnumerator(){}
		public virtual bool Remove(IPAddressInformation address){}
		internal IPAddressInformationCollection(){}
		public virtual int Count{ get	{} }
		public virtual bool IsReadOnly{ get	{} }
		public virtual IPAddressInformation this[int index] { get	{} }
		private List<IPAddressInformation> list;
	}

	public abstract	class	IPGlobalProperties: Object
	{
		public static IPGlobalProperties GetIPGlobalProperties(){}
		public abstract virtual TcpConnectionInformation[] GetActiveTcpConnections();
		public abstract virtual IPEndPoint[] GetActiveTcpListeners();
		public abstract virtual IPEndPoint[] GetActiveUdpListeners();
		public abstract virtual IcmpV4Statistics GetIcmpV4Statistics();
		public abstract virtual IcmpV6Statistics GetIcmpV6Statistics();
		public abstract virtual IPGlobalStatistics GetIPv4GlobalStatistics();
		public abstract virtual IPGlobalStatistics GetIPv6GlobalStatistics();
		public abstract virtual TcpStatistics GetTcpIPv4Statistics();
		public abstract virtual TcpStatistics GetTcpIPv6Statistics();
		public abstract virtual UdpStatistics GetUdpIPv4Statistics();
		public abstract virtual UdpStatistics GetUdpIPv6Statistics();
		protected IPGlobalProperties(){}
		public abstract virtual string DhcpScopeName{ get	{} }
		public abstract virtual string DomainName{ get	{} }
		public abstract virtual string HostName{ get	{} }
		public abstract virtual bool IsWinsProxy{ get	{} }
		public abstract virtual NetBiosNodeType NodeType{ get	{} }
	}

	public abstract	class	IPGlobalStatistics: Object
	{
		protected IPGlobalStatistics(){}
		public abstract virtual int DefaultTtl{ get	{} }
		public abstract virtual bool ForwardingEnabled{ get	{} }
		public abstract virtual int NumberOfInterfaces{ get	{} }
		public abstract virtual int NumberOfIPAddresses{ get	{} }
		public abstract virtual int NumberOfRoutes{ get	{} }
		public abstract virtual long OutputPacketRequests{ get	{} }
		public abstract virtual long OutputPacketRoutingDiscards{ get	{} }
		public abstract virtual long OutputPacketsDiscarded{ get	{} }
		public abstract virtual long OutputPacketsWithNoRoute{ get	{} }
		public abstract virtual long PacketFragmentFailures{ get	{} }
		public abstract virtual long PacketReassembliesRequired{ get	{} }
		public abstract virtual long PacketReassemblyFailures{ get	{} }
		public abstract virtual long PacketReassemblyTimeout{ get	{} }
		public abstract virtual long PacketsFragmented{ get	{} }
		public abstract virtual long PacketsReassembled{ get	{} }
		public abstract virtual long ReceivedPackets{ get	{} }
		public abstract virtual long ReceivedPacketsDelivered{ get	{} }
		public abstract virtual long ReceivedPacketsDiscarded{ get	{} }
		public abstract virtual long ReceivedPacketsForwarded{ get	{} }
		public abstract virtual long ReceivedPacketsWithAddressErrors{ get	{} }
		public abstract virtual long ReceivedPacketsWithHeadersErrors{ get	{} }
		public abstract virtual long ReceivedPacketsWithUnknownProtocol{ get	{} }
	}

	public abstract	class	IPInterfaceProperties: Object
	{
		public abstract virtual IPv4InterfaceProperties GetIPv4Properties();
		public abstract virtual IPv6InterfaceProperties GetIPv6Properties();
		protected IPInterfaceProperties(){}
		public abstract virtual IPAddressInformationCollection AnycastAddresses{ get	{} }
		public abstract virtual IPAddressCollection DhcpServerAddresses{ get	{} }
		public abstract virtual IPAddressCollection DnsAddresses{ get	{} }
		public abstract virtual string DnsSuffix{ get	{} }
		public abstract virtual GatewayIPAddressInformationCollection GatewayAddresses{ get	{} }
		public abstract virtual bool IsDnsEnabled{ get	{} }
		public abstract virtual bool IsDynamicDnsEnabled{ get	{} }
		public abstract virtual MulticastIPAddressInformationCollection MulticastAddresses{ get	{} }
		public abstract virtual UnicastIPAddressInformationCollection UnicastAddresses{ get	{} }
		public abstract virtual IPAddressCollection WinsServersAddresses{ get	{} }
	}

	public abstract	class	IPv4InterfaceProperties: Object
	{
		protected IPv4InterfaceProperties(){}
		public abstract virtual int Index{ get	{} }
		public abstract virtual bool IsAutomaticPrivateAddressingActive{ get	{} }
		public abstract virtual bool IsAutomaticPrivateAddressingEnabled{ get	{} }
		public abstract virtual bool IsDhcpEnabled{ get	{} }
		public abstract virtual bool IsForwardingEnabled{ get	{} }
		public abstract virtual int Mtu{ get	{} }
		public abstract virtual bool UsesWins{ get	{} }
	}

	public abstract	class	IPv4InterfaceStatistics: Object
	{
		protected IPv4InterfaceStatistics(){}
		public abstract virtual long BytesReceived{ get	{} }
		public abstract virtual long BytesSent{ get	{} }
		public abstract virtual long IncomingPacketsDiscarded{ get	{} }
		public abstract virtual long IncomingPacketsWithErrors{ get	{} }
		public abstract virtual long IncomingUnknownProtocolPackets{ get	{} }
		public abstract virtual long NonUnicastPacketsReceived{ get	{} }
		public abstract virtual long NonUnicastPacketsSent{ get	{} }
		public abstract virtual long OutgoingPacketsDiscarded{ get	{} }
		public abstract virtual long OutgoingPacketsWithErrors{ get	{} }
		public abstract virtual long OutputQueueLength{ get	{} }
		public abstract virtual long UnicastPacketsReceived{ get	{} }
		public abstract virtual long UnicastPacketsSent{ get	{} }
	}

	public abstract	class	IPv6InterfaceProperties: Object
	{
		protected IPv6InterfaceProperties(){}
		public abstract virtual int Index{ get	{} }
		public abstract virtual int Mtu{ get	{} }
	}

	public abstract	class	IcmpV4Statistics: Object
	{
		protected IcmpV4Statistics(){}
		public abstract virtual long AddressMaskRepliesReceived{ get	{} }
		public abstract virtual long AddressMaskRepliesSent{ get	{} }
		public abstract virtual long AddressMaskRequestsReceived{ get	{} }
		public abstract virtual long AddressMaskRequestsSent{ get	{} }
		public abstract virtual long DestinationUnreachableMessagesReceived{ get	{} }
		public abstract virtual long DestinationUnreachableMessagesSent{ get	{} }
		public abstract virtual long EchoRepliesReceived{ get	{} }
		public abstract virtual long EchoRepliesSent{ get	{} }
		public abstract virtual long EchoRequestsReceived{ get	{} }
		public abstract virtual long EchoRequestsSent{ get	{} }
		public abstract virtual long ErrorsReceived{ get	{} }
		public abstract virtual long ErrorsSent{ get	{} }
		public abstract virtual long MessagesReceived{ get	{} }
		public abstract virtual long MessagesSent{ get	{} }
		public abstract virtual long ParameterProblemsReceived{ get	{} }
		public abstract virtual long ParameterProblemsSent{ get	{} }
		public abstract virtual long RedirectsReceived{ get	{} }
		public abstract virtual long RedirectsSent{ get	{} }
		public abstract virtual long SourceQuenchesReceived{ get	{} }
		public abstract virtual long SourceQuenchesSent{ get	{} }
		public abstract virtual long TimeExceededMessagesReceived{ get	{} }
		public abstract virtual long TimeExceededMessagesSent{ get	{} }
		public abstract virtual long TimestampRepliesReceived{ get	{} }
		public abstract virtual long TimestampRepliesSent{ get	{} }
		public abstract virtual long TimestampRequestsReceived{ get	{} }
		public abstract virtual long TimestampRequestsSent{ get	{} }
	}

	public abstract	class	IcmpV6Statistics: Object
	{
		protected IcmpV6Statistics(){}
		public abstract virtual long DestinationUnreachableMessagesReceived{ get	{} }
		public abstract virtual long DestinationUnreachableMessagesSent{ get	{} }
		public abstract virtual long EchoRepliesReceived{ get	{} }
		public abstract virtual long EchoRepliesSent{ get	{} }
		public abstract virtual long EchoRequestsReceived{ get	{} }
		public abstract virtual long EchoRequestsSent{ get	{} }
		public abstract virtual long ErrorsReceived{ get	{} }
		public abstract virtual long ErrorsSent{ get	{} }
		public abstract virtual long MembershipQueriesReceived{ get	{} }
		public abstract virtual long MembershipQueriesSent{ get	{} }
		public abstract virtual long MembershipReductionsReceived{ get	{} }
		public abstract virtual long MembershipReductionsSent{ get	{} }
		public abstract virtual long MembershipReportsReceived{ get	{} }
		public abstract virtual long MembershipReportsSent{ get	{} }
		public abstract virtual long MessagesReceived{ get	{} }
		public abstract virtual long MessagesSent{ get	{} }
		public abstract virtual long NeighborAdvertisementsReceived{ get	{} }
		public abstract virtual long NeighborAdvertisementsSent{ get	{} }
		public abstract virtual long NeighborSolicitsReceived{ get	{} }
		public abstract virtual long NeighborSolicitsSent{ get	{} }
		public abstract virtual long PacketTooBigMessagesReceived{ get	{} }
		public abstract virtual long PacketTooBigMessagesSent{ get	{} }
		public abstract virtual long ParameterProblemsReceived{ get	{} }
		public abstract virtual long ParameterProblemsSent{ get	{} }
		public abstract virtual long RedirectsReceived{ get	{} }
		public abstract virtual long RedirectsSent{ get	{} }
		public abstract virtual long RouterAdvertisementsReceived{ get	{} }
		public abstract virtual long RouterAdvertisementsSent{ get	{} }
		public abstract virtual long RouterSolicitsReceived{ get	{} }
		public abstract virtual long RouterSolicitsSent{ get	{} }
		public abstract virtual long TimeExceededMessagesReceived{ get	{} }
		public abstract virtual long TimeExceededMessagesSent{ get	{} }
	}

	public abstract	class	MulticastIPAddressInformation: IPAddressInformation
	{
		protected MulticastIPAddressInformation(){}
		public abstract virtual long AddressPreferredLifetime{ get	{} }
		public abstract virtual long AddressValidLifetime{ get	{} }
		public abstract virtual long DhcpLeaseLifetime{ get	{} }
		public abstract virtual DuplicateAddressDetectionState DuplicateAddressDetectionState{ get	{} }
		public abstract virtual PrefixOrigin PrefixOrigin{ get	{} }
		public abstract virtual SuffixOrigin SuffixOrigin{ get	{} }
	}

	public class	MulticastIPAddressInformationCollection: Object, IEnumerable, IEnumerable<MulticastIPAddressInformation>, ICollection<MulticastIPAddressInformation>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public virtual void Add(MulticastIPAddressInformation address){}
		public virtual void Clear(){}
		public virtual bool Contains(MulticastIPAddressInformation address){}
		public virtual void CopyTo(MulticastIPAddressInformation[] array, int offset){}
		public virtual IEnumerator<MulticastIPAddressInformation> GetEnumerator(){}
		public virtual bool Remove(MulticastIPAddressInformation address){}
		protected MulticastIPAddressInformationCollection(){}
		public virtual int Count{ get	{} }
		public virtual bool IsReadOnly{ get	{} }
		public virtual MulticastIPAddressInformation this[int index] { get	{} }
		private List<MulticastIPAddressInformation> list;
	}

	public class	NetworkAvailabilityEventArgs: EventArgs
	{
		internal NetworkAvailabilityEventArgs(bool available){}
		public bool IsAvailable{ get	{} }
		private bool available;
	}

	public sealed class	NetworkChange: Object
	{
		private NetworkChange(){}
		public static event	NetworkAddressChangedEventHandler NetworkAddressChanged;
		public static event	NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged;
	}

	public class	NetworkInformationException: Exception, ISerializable, _Exception
	{
		public NetworkInformationException(){}
		public NetworkInformationException(int errorCode){}
		public int ErrorCode{ get	{} }
		private int error_code;
	}

	public abstract	class	NetworkInterface: Object
	{
		private static int uname(IntPtr buf){}
		public static NetworkInterface[] GetAllNetworkInterfaces(){}
		public static bool GetIsNetworkAvailable(){}
		internal static string ReadLine(string path){}
		public abstract virtual IPInterfaceProperties GetIPProperties();
		public abstract virtual IPv4InterfaceStatistics GetIPv4Statistics();
		public abstract virtual PhysicalAddress GetPhysicalAddress();
		public abstract virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
		protected NetworkInterface(){}
		private static NetworkInterface(){}
		public static int LoopbackInterfaceIndex{ get	{} }
		public abstract virtual string Description{ get	{} }
		public abstract virtual string Id{ get	{} }
		public abstract virtual bool IsReceiveOnly{ get	{} }
		public abstract virtual string Name{ get	{} }
		public abstract virtual NetworkInterfaceType NetworkInterfaceType{ get	{} }
		public abstract virtual OperationalStatus OperationalStatus{ get	{} }
		public abstract virtual long Speed{ get	{} }
		public abstract virtual bool SupportsMulticast{ get	{} }
		private static Version windowsVer51;
		internal readonly static bool runningOnUnix;
	}

	public class	PhysicalAddress: Object
	{
		internal static PhysicalAddress ParseEthernet(string address){}
		public static PhysicalAddress Parse(string address){}
		private static byte GetValue(char c){}
		public virtual bool Equals(System.Object comparand){}
		public virtual int GetHashCode(){}
		public Byte[] GetAddressBytes(){}
		public virtual string ToString(){}
		public PhysicalAddress(Byte[] address){}
		private static PhysicalAddress(){}
		private Byte[] bytes;
		public readonly static PhysicalAddress None;
		private const int numberOfBytes = null;
	}

	public class	Ping: Component, IDisposable, IComponent
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		private static int capget(ref cap_user_header_t header, ref cap_user_data_t data){}
		private static void CheckLinuxCapabilities(){}
		protected void OnPingCompleted(PingCompletedEventArgs e){}
		public PingReply Send(IPAddress address){}
		public PingReply Send(IPAddress address, int timeout){}
		public PingReply Send(IPAddress address, int timeout, Byte[] buffer){}
		public PingReply Send(string hostNameOrAddress){}
		public PingReply Send(string hostNameOrAddress, int timeout){}
		public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer){}
		public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options){}
		private static IPAddress GetNonLoopbackIP(){}
		public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options){}
		private PingReply SendPrivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options){}
		private PingReply SendUnprivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options){}
		public void SendAsync(IPAddress address, int timeout, Byte[] buffer, System.Object userToken){}
		public void SendAsync(IPAddress address, int timeout, System.Object userToken){}
		public void SendAsync(IPAddress address, System.Object userToken){}
		public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, System.Object userToken){}
		public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, System.Object userToken){}
		public void SendAsync(string hostNameOrAddress, int timeout, System.Object userToken){}
		public void SendAsync(string hostNameOrAddress, System.Object userToken){}
		public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, System.Object userToken){}
		public void SendAsyncCancel(){}
		private string BuildPingArgs(IPAddress address, int timeout, PingOptions options){}
		public Ping(){}
		private static Ping(){}
		public event	PingCompletedEventHandler PingCompleted;
		private BackgroundWorker worker;
		private System.Object user_async_state;
		private readonly static Byte[] default_buffer;
		private static bool canSendPrivileged;
		private const int DefaultCount = null;
		private const string PingBinPath = null;
		private const int default_timeout = null;
		private const int identifier = null;
		private const uint linux_cap_version = null;
	}

	public class	PingCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal PingCompletedEventArgs(Exception ex, bool cancelled, System.Object userState, PingReply reply){}
		public PingReply Reply{ get	{} }
		private PingReply reply;
	}

	public class	PingException: InvalidOperationException, ISerializable, _Exception
	{
		public PingException(string message){}
		public PingException(string message, Exception innerException){}
		protected PingException(SerializationInfo serializationInfo, StreamingContext streamingContext){}
	}

	public class	PingOptions: Object
	{
		public PingOptions(){}
		public PingOptions(int ttl, bool dontFragment){}
		public bool DontFragment{ get	{} set	{} }
		public int Ttl{ get	{} set	{} }
		private int ttl;
		private bool dont_fragment;
	}

	public class	PingReply: Object
	{
		internal PingReply(IPAddress address, Byte[] buffer, PingOptions options, long roundtripTime, IPStatus status){}
		public IPAddress Address{ get	{} }
		public Byte[] Buffer{ get	{} }
		public PingOptions Options{ get	{} }
		public long RoundtripTime{ get	{} }
		public IPStatus Status{ get	{} }
		private IPAddress address;
		private Byte[] buffer;
		private PingOptions options;
		private long rtt;
		private IPStatus status;
	}

	public abstract	class	TcpConnectionInformation: Object
	{
		protected TcpConnectionInformation(){}
		public abstract virtual IPEndPoint LocalEndPoint{ get	{} }
		public abstract virtual IPEndPoint RemoteEndPoint{ get	{} }
		public abstract virtual TcpState State{ get	{} }
	}

	public abstract	class	TcpStatistics: Object
	{
		protected TcpStatistics(){}
		public abstract virtual long ConnectionsAccepted{ get	{} }
		public abstract virtual long ConnectionsInitiated{ get	{} }
		public abstract virtual long CumulativeConnections{ get	{} }
		public abstract virtual long CurrentConnections{ get	{} }
		public abstract virtual long ErrorsReceived{ get	{} }
		public abstract virtual long FailedConnectionAttempts{ get	{} }
		public abstract virtual long MaximumConnections{ get	{} }
		public abstract virtual long MaximumTransmissionTimeout{ get	{} }
		public abstract virtual long MinimumTransmissionTimeout{ get	{} }
		public abstract virtual long ResetConnections{ get	{} }
		public abstract virtual long ResetsSent{ get	{} }
		public abstract virtual long SegmentsReceived{ get	{} }
		public abstract virtual long SegmentsResent{ get	{} }
		public abstract virtual long SegmentsSent{ get	{} }
	}

	public abstract	class	UdpStatistics: Object
	{
		protected UdpStatistics(){}
		public abstract virtual long DatagramsReceived{ get	{} }
		public abstract virtual long DatagramsSent{ get	{} }
		public abstract virtual long IncomingDatagramsDiscarded{ get	{} }
		public abstract virtual long IncomingDatagramsWithErrors{ get	{} }
		public abstract virtual int UdpListeners{ get	{} }
	}

	public abstract	class	UnicastIPAddressInformation: IPAddressInformation
	{
		protected UnicastIPAddressInformation(){}
		public abstract virtual long AddressPreferredLifetime{ get	{} }
		public abstract virtual long AddressValidLifetime{ get	{} }
		public abstract virtual long DhcpLeaseLifetime{ get	{} }
		public abstract virtual DuplicateAddressDetectionState DuplicateAddressDetectionState{ get	{} }
		public abstract virtual IPAddress IPv4Mask{ get	{} }
		public abstract virtual PrefixOrigin PrefixOrigin{ get	{} }
		public abstract virtual SuffixOrigin SuffixOrigin{ get	{} }
	}

	public class	UnicastIPAddressInformationCollection: Object, IEnumerable, IEnumerable<UnicastIPAddressInformation>, ICollection<UnicastIPAddressInformation>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public virtual void Add(UnicastIPAddressInformation address){}
		public virtual void Clear(){}
		public virtual bool Contains(UnicastIPAddressInformation address){}
		public virtual void CopyTo(UnicastIPAddressInformation[] array, int offset){}
		public virtual IEnumerator<UnicastIPAddressInformation> GetEnumerator(){}
		public virtual bool Remove(UnicastIPAddressInformation address){}
		protected UnicastIPAddressInformationCollection(){}
		public virtual int Count{ get	{} }
		public virtual bool IsReadOnly{ get	{} }
		public virtual UnicastIPAddressInformation this[int index] { get	{} }
		private List<UnicastIPAddressInformation> list;
	}

	delegate void NetworkAddressChangedEventHandler(System.Object sender, EventArgs e);

	delegate void NetworkAvailabilityChangedEventHandler(System.Object sender, NetworkAvailabilityEventArgs e);

	delegate void PingCompletedEventHandler(System.Object sender, PingCompletedEventArgs e);

}

namespace System.Net.Security {
	public abstract	class	AuthenticatedStream: Stream, IDisposable
	{
		protected virtual void Dispose(bool disposing){}
		protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen){}
		Stream InnerStream{ get	{} }
		public abstract virtual bool IsAuthenticated{ get	{} }
		public abstract virtual bool IsEncrypted{ get	{} }
		public abstract virtual bool IsMutuallyAuthenticated{ get	{} }
		public abstract virtual bool IsServer{ get	{} }
		public abstract virtual bool IsSigned{ get	{} }
		public bool LeaveInnerStreamOpen{ get	{} }
		private Stream innerStream;
		private bool leaveStreamOpen;
	}

	public class	NegotiateStream: AuthenticatedStream, IDisposable
	{
		public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback callback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback callback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual void AuthenticateAsClient(){}
		public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName){}
		public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel){}
		public virtual void AuthenticateAsServer(){}
		public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel){}
		protected virtual void Dispose(bool disposing){}
		public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult){}
		public virtual int EndRead(IAsyncResult asyncResult){}
		public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult){}
		public virtual void EndWrite(IAsyncResult asyncResult){}
		public virtual void Flush(){}
		public virtual int Read(Byte[] buffer, int offset, int count){}
		public virtual long Seek(long offset, SeekOrigin origin){}
		public virtual void SetLength(long value){}
		public virtual void Write(Byte[] buffer, int offset, int count){}
		public NegotiateStream(Stream innerStream){}
		public NegotiateStream(Stream innerStream, bool leaveStreamOpen){}
		public virtual bool CanRead{ get	{} }
		public virtual bool CanSeek{ get	{} }
		public virtual bool CanTimeout{ get	{} }
		public virtual bool CanWrite{ get	{} }
		public virtual TokenImpersonationLevel ImpersonationLevel{ get	{} }
		public virtual bool IsAuthenticated{ get	{} }
		public virtual bool IsEncrypted{ get	{} }
		public virtual bool IsMutuallyAuthenticated{ get	{} }
		public virtual bool IsServer{ get	{} }
		public virtual bool IsSigned{ get	{} }
		public virtual long Length{ get	{} }
		public virtual long Position{ get	{} set	{} }
		public virtual int ReadTimeout{ get	{} set	{} }
		public virtual IIdentity RemoteIdentity{ get	{} }
		public virtual int WriteTimeout{ get	{} set	{} }
		private int readTimeout;
		private int writeTimeout;
	}

	public class	SslStream: AuthenticatedStream, IDisposable
	{
		private X509Certificate OnCertificateSelection(X509CertificateCollection clientCerts, X509Certificate serverCert, string targetHost, X509CertificateCollection serverRequestedCerts){}
		public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback callback, System.Object asyncState){}
		public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback callback, System.Object asyncState){}
		private SecurityProtocolType GetMonoSslProtocol(SslProtocols ms){}
		public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, System.Object asyncState){}
		public virtual void AuthenticateAsClient(string targetHost){}
		public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation){}
		public virtual void AuthenticateAsServer(X509Certificate serverCertificate){}
		public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation){}
		protected virtual void Dispose(bool disposing){}
		public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult){}
		public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult){}
		public virtual int EndRead(IAsyncResult asyncResult){}
		public virtual void EndWrite(IAsyncResult asyncResult){}
		public virtual void Flush(){}
		public virtual int Read(Byte[] buffer, int offset, int count){}
		public virtual long Seek(long offset, SeekOrigin origin){}
		public virtual void SetLength(long value){}
		public virtual void Write(Byte[] buffer, int offset, int count){}
		public void Write(Byte[] buffer){}
		private void CheckConnectionAuthenticated(){}
		public SslStream(Stream innerStream){}
		public SslStream(Stream innerStream, bool leaveStreamOpen){}
		public SslStream(Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback){}
		public SslStream(Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback, LocalCertificateSelectionCallback certSelectionCallback){}
		public virtual bool CanRead{ get	{} }
		public virtual bool CanSeek{ get	{} }
		public virtual bool CanTimeout{ get	{} }
		public virtual bool CanWrite{ get	{} }
		public virtual long Length{ get	{} }
		public virtual long Position{ get	{} set	{} }
		public virtual bool IsAuthenticated{ get	{} }
		public virtual bool IsEncrypted{ get	{} }
		public virtual bool IsMutuallyAuthenticated{ get	{} }
		public virtual bool IsServer{ get	{} }
		public virtual bool IsSigned{ get	{} }
		public virtual int ReadTimeout{ get	{} set	{} }
		public virtual int WriteTimeout{ get	{} set	{} }
		public virtual bool CheckCertRevocationStatus{ get	{} }
		public virtual CipherAlgorithmType CipherAlgorithm{ get	{} }
		public virtual int CipherStrength{ get	{} }
		public virtual HashAlgorithmType HashAlgorithm{ get	{} }
		public virtual int HashStrength{ get	{} }
		public virtual ExchangeAlgorithmType KeyExchangeAlgorithm{ get	{} }
		public virtual int KeyExchangeStrength{ get	{} }
		public virtual X509Certificate LocalCertificate{ get	{} }
		public virtual X509Certificate RemoteCertificate{ get	{} }
		public virtual SslProtocols SslProtocol{ get	{} }
		private SslStreamBase ssl_stream;
		private RemoteCertificateValidationCallback validation_callback;
		private LocalCertificateSelectionCallback selection_callback;
	}

	delegate X509Certificate LocalCertificateSelectionCallback(System.Object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);

	delegate bool RemoteCertificateValidationCallback(System.Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);

}

namespace System.Net.Sockets {
	public class	IPv6MulticastOption: Object
	{
		public IPv6MulticastOption(IPAddress group){}
		public IPv6MulticastOption(IPAddress group, long ifindex){}
		public IPAddress Group{ get	{} set	{} }
		public long InterfaceIndex{ get	{} set	{} }
		private IPAddress group;
		private long ifIndex;
	}

	public class	LingerOption: Object
	{
		public LingerOption(bool enable, int secs){}
		public bool Enabled{ get	{} set	{} }
		public int LingerTime{ get	{} set	{} }
		private bool enabled;
		private int seconds;
	}

	public class	MulticastOption: Object
	{
		public MulticastOption(IPAddress group){}
		public MulticastOption(IPAddress group, int interfaceIndex){}
		public MulticastOption(IPAddress group, IPAddress mcint){}
		public IPAddress Group{ get	{} set	{} }
		public IPAddress LocalAddress{ get	{} set	{} }
		public int InterfaceIndex{ get	{} set	{} }
		private IPAddress group;
		private IPAddress local;
		private int iface_index;
	}

	public class	NetworkStream: Stream, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, System.Object state){}
		public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, System.Object state){}
		protected virtual void Finalize(){}
		protected virtual void Dispose(bool disposing){}
		public virtual int EndRead(IAsyncResult ar){}
		public virtual void EndWrite(IAsyncResult ar){}
		public virtual void Flush(){}
		public virtual int Read(Byte[] buffer, int offset, int size){}
		public virtual long Seek(long offset, SeekOrigin origin){}
		public virtual void SetLength(long value){}
		public virtual void Write(Byte[] buffer, int offset, int size){}
		private void CheckDisposed(){}
		public NetworkStream(Socket socket){}
		public NetworkStream(Socket socket, bool owns_socket){}
		public NetworkStream(Socket socket, FileAccess access){}
		public NetworkStream(Socket socket, FileAccess access, bool owns_socket){}
		public virtual bool CanRead{ get	{} }
		public virtual bool CanSeek{ get	{} }
		public virtual bool CanTimeout{ get	{} }
		public virtual bool CanWrite{ get	{} }
		public virtual bool DataAvailable{ get	{} }
		public virtual long Length{ get	{} }
		public virtual long Position{ get	{} set	{} }
		bool Readable{ get	{} set	{} }
		public virtual int ReadTimeout{ get	{} set	{} }
		Socket Socket{ get	{} }
		bool Writeable{ get	{} set	{} }
		public virtual int WriteTimeout{ get	{} set	{} }
		private FileAccess access;
		private Socket socket;
		private bool owns_socket;
		private bool readable;
		private bool writeable;
		private bool disposed;
	}

	public class	SendPacketsElement: Object
	{
		public SendPacketsElement(Byte[] buffer){}
		public SendPacketsElement(Byte[] buffer, int offset, int count){}
		public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket){}
		public SendPacketsElement(string filepath){}
		public SendPacketsElement(string filepath, int offset, int count){}
		public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket){}
		public Byte[] Buffer{ get	{} set	{} }
		public int Count{ get	{} set	{} }
		public bool EndOfPacket{ get	{} set	{} }
		public string FilePath{ get	{} set	{} }
		public int Offset{ get	{} set	{} }
		private Byte[] <Buffer>k__BackingField;
		private int <Count>k__BackingField;
		private bool <EndOfPacket>k__BackingField;
		private string <FilePath>k__BackingField;
		private int <Offset>k__BackingField;
	}

	public class	Socket: Object, IDisposable
	{
		public bool SendToAsync(SocketAsyncEventArgs e){}
		public int SendTo(Byte[] buffer, EndPoint remote_end){}
		public int SendTo(Byte[] buffer, SocketFlags flags, EndPoint remote_end){}
		public int SendTo(Byte[] buffer, int size, SocketFlags flags, EndPoint remote_end){}
		private static int SendTo_internal_real(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, SocketAddress sa, out int error){}
		private static int SendTo_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, SocketAddress sa, out int error){}
		public int SendTo(Byte[] buffer, int offset, int size, SocketFlags flags, EndPoint remote_end){}
		internal int SendTo_nochecks(Byte[] buffer, int offset, int size, SocketFlags flags, EndPoint remote_end){}
		public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue){}
		public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, System.Object optionValue){}
		public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue){}
		internal static void CheckProtocolSupport(){}
		private IntPtr Socket_internal(AddressFamily family, SocketType type, ProtocolType proto, out int error){}
		protected virtual void Finalize(){}
		private static void Blocking_internal(IntPtr socket, bool block, out int error){}
		private static SocketAddress RemoteEndPoint_internal(IntPtr socket, out int error){}
		private void Linger(IntPtr handle){}
		protected virtual void Dispose(bool explicitDisposing){}
		public sealed virtual void Dispose(){}
		private static void Close_internal(IntPtr socket, out int error){}
		public void Close(){}
		public void Close(int timeout){}
		private static void Connect_internal_real(IntPtr sock, SocketAddress sa, out int error){}
		private static void Connect_internal(IntPtr sock, SocketAddress sa, out int error){}
		private static void Connect_internal(IntPtr sock, SocketAddress sa, out int error, bool requireSocketPolicyFile){}
		internal static bool CheckEndPoint(SocketAddress sa){}
		private static MethodInfo GetUnityCrossDomainHelperMethod(string methodname){}
		public void Connect(EndPoint remoteEP){}
		internal void Connect(EndPoint remoteEP, bool requireSocketPolicy){}
		public bool ReceiveAsync(SocketAsyncEventArgs e){}
		public bool SendAsync(SocketAsyncEventArgs e){}
		private static bool Poll_internal(IntPtr socket, SelectMode mode, int timeout, out int error){}
		internal bool Poll(int time_us, SelectMode mode, out int socket_error){}
		private static int Receive_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, out int error){}
		internal int Receive_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, out SocketError error){}
		private static void GetSocketOption_obj_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, out System.Object obj_val, out int error){}
		private static int Send_internal(IntPtr sock, Byte[] buf, int offset, int count, SocketFlags flags, out int error){}
		internal int Send_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, out SocketError error){}
		public System.Object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName){}
		private static void Shutdown_internal(IntPtr socket, SocketShutdown how, out int error){}
		public void Shutdown(SocketShutdown how){}
		private static void SetSocketOption_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, System.Object obj_val, Byte[] byte_val, int int_val, out int error){}
		public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue){}
		private void ThrowIfUpd(){}
		private static void AddSockets(ArrayList sockets, IList list, string name){}
		private static void Select_internal(ref Socket[] sockets, int microSeconds, out int error){}
		public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds){}
		private void SocketDefaults(){}
		private static int Available_internal(IntPtr socket, out int error){}
		private static SocketAddress LocalEndPoint_internal(IntPtr socket, out int error){}
		public bool AcceptAsync(SocketAsyncEventArgs e){}
		private static IntPtr Accept_internal(IntPtr sock, out int error, bool blocking){}
		public Socket Accept(){}
		internal void Accept(Socket acceptSocket){}
		public IAsyncResult BeginAccept(AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginConnect(EndPoint end_point, AsyncCallback callback, System.Object state){}
		internal IAsyncResult BeginConnect(EndPoint end_point, AsyncCallback callback, System.Object state, bool bypassSocketSecurity){}
		public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socket_flags, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags flags, out SocketError error, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceive(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceive(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socket_flags, ref EndPoint remote_end, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socket_flags, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSend(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSend(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socket_flags, EndPoint remote_end, AsyncCallback callback, System.Object state){}
		private static void Bind_internal(IntPtr sock, SocketAddress sa, out int error){}
		public void Bind(EndPoint local_end){}
		public bool ConnectAsync(SocketAsyncEventArgs e){}
		public void Connect(IPAddress address, int port){}
		public void Connect(IPAddress[] addresses, int port){}
		public void Connect(string host, int port){}
		public bool DisconnectAsync(SocketAsyncEventArgs e){}
		private static void Disconnect_internal(IntPtr sock, bool reuse, out int error){}
		public void Disconnect(bool reuseSocket){}
		public SocketInformation DuplicateAndClose(int targetProcessId){}
		public Socket EndAccept(IAsyncResult result){}
		public Socket EndAccept(out Byte[] buffer, IAsyncResult asyncResult){}
		public Socket EndAccept(out Byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult){}
		public void EndConnect(IAsyncResult result){}
		public void EndDisconnect(IAsyncResult asyncResult){}
		public int EndReceive(IAsyncResult result){}
		public int EndReceive(IAsyncResult asyncResult, out SocketError errorCode){}
		public int EndReceiveFrom(IAsyncResult result, ref EndPoint end_point){}
		public int EndReceiveMessageFrom(IAsyncResult asyncResult, ref SocketFlags socketFlags, ref EndPoint endPoint, out IPPacketInformation ipPacketInformation){}
		public int EndSend(IAsyncResult result){}
		public int EndSend(IAsyncResult asyncResult, out SocketError errorCode){}
		public void EndSendFile(IAsyncResult asyncResult){}
		private Exception InvalidAsyncOp(string method){}
		public int EndSendTo(IAsyncResult result){}
		private static void GetSocketOption_arr_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, ref Byte[] byte_val, out int error){}
		public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue){}
		public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int length){}
		private static int WSAIoctl(IntPtr sock, int ioctl_code, Byte[] input, Byte[] output, out int error){}
		public int IOControl(int ioctl_code, Byte[] in_value, Byte[] out_value){}
		public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue){}
		private static void Listen_internal(IntPtr sock, int backlog, out int error){}
		public void Listen(int backlog){}
		public bool Poll(int time_us, SelectMode mode){}
		public int Receive(Byte[] buffer){}
		public int Receive(Byte[] buffer, SocketFlags flags){}
		public int Receive(Byte[] buffer, int size, SocketFlags flags){}
		public int Receive(Byte[] buffer, int offset, int size, SocketFlags flags){}
		public int Receive(Byte[] buffer, int offset, int size, SocketFlags flags, out SocketError error){}
		private static int Receive_internal(IntPtr sock, WSABUF[] bufarray, SocketFlags flags, out int error){}
		public int Receive(IList<ArraySegment<Byte>> buffers){}
		public int Receive(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags){}
		public int Receive(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, out SocketError errorCode){}
		public bool ReceiveFromAsync(SocketAsyncEventArgs e){}
		public int ReceiveFrom(Byte[] buffer, ref EndPoint remoteEP){}
		public int ReceiveFrom(Byte[] buffer, SocketFlags flags, ref EndPoint remoteEP){}
		public int ReceiveFrom(Byte[] buffer, int size, SocketFlags flags, ref EndPoint remoteEP){}
		private static int RecvFrom_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, ref SocketAddress sockaddr, out int error){}
		public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags flags, ref EndPoint remoteEP){}
		internal int ReceiveFrom_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, ref EndPoint remote_end){}
		internal int ReceiveFrom_nochecks_exc(Byte[] buf, int offset, int size, SocketFlags flags, ref EndPoint remote_end, bool throwOnError, out int error){}
		public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e){}
		public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, ref SocketFlags socketFlags, ref EndPoint remoteEP, out IPPacketInformation ipPacketInformation){}
		public bool SendPacketsAsync(SocketAsyncEventArgs e){}
		public int Send(Byte[] buf){}
		public int Send(Byte[] buf, SocketFlags flags){}
		public int Send(Byte[] buf, int size, SocketFlags flags){}
		public int Send(Byte[] buf, int offset, int size, SocketFlags flags){}
		public int Send(Byte[] buf, int offset, int size, SocketFlags flags, out SocketError error){}
		private static int Send_internal(IntPtr sock, WSABUF[] bufarray, SocketFlags flags, out int error){}
		public int Send(IList<ArraySegment<Byte>> buffers){}
		public int Send(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags){}
		public int Send(IList<ArraySegment<Byte>> buffers, SocketFlags socketFlags, out SocketError errorCode){}
		private static bool SendFile(IntPtr sock, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags){}
		public void SendFile(string fileName){}
		public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags){}
		private Socket(AddressFamily family, SocketType type, ProtocolType proto, IntPtr sock){}
		public Socket(SocketInformation socketInformation){}
		public Socket(AddressFamily family, SocketType type, ProtocolType proto){}
		private static Socket(){}
		public int Available{ get	{} }
		public bool DontFragment{ get	{} set	{} }
		public bool EnableBroadcast{ get	{} set	{} }
		public bool ExclusiveAddressUse{ get	{} set	{} }
		public bool IsBound{ get	{} }
		public LingerOption LingerState{ get	{} set	{} }
		public bool MulticastLoopback{ get	{} set	{} }
		public bool UseOnlyOverlappedIO{ get	{} set	{} }
		public IntPtr Handle{ get	{} }
		public EndPoint LocalEndPoint{ get	{} }
		public SocketType SocketType{ get	{} }
		public int SendTimeout{ get	{} set	{} }
		public int ReceiveTimeout{ get	{} set	{} }
		public static bool SupportsIPv4{ get	{} }
		public static bool SupportsIPv6{ get	{} }
		public static bool OSSupportsIPv4{ get	{} }
		public static bool OSSupportsIPv6{ get	{} }
		public AddressFamily AddressFamily{ get	{} }
		public bool Blocking{ get	{} set	{} }
		public bool Connected{ get	{} set	{} }
		public ProtocolType ProtocolType{ get	{} }
		public bool NoDelay{ get	{} set	{} }
		public int ReceiveBufferSize{ get	{} set	{} }
		public int SendBufferSize{ get	{} set	{} }
		public short Ttl{ get	{} set	{} }
		public EndPoint RemoteEndPoint{ get	{} }
		private Queue readQ;
		private Queue writeQ;
		private bool islistening;
		private bool useoverlappedIO;
		private readonly int MinListenPort;
		private readonly int MaxListenPort;
		private int linger_timeout;
		private IntPtr socket;
		private AddressFamily address_family;
		private SocketType socket_type;
		private ProtocolType protocol_type;
		internal bool blocking;
		private Thread blocking_thread;
		private bool isbound;
		private readonly int max_bind_count;
		private bool connected;
		private bool closed;
		internal bool disposed;
		internal EndPoint seed_endpoint;
		private static int ipv4Supported;
		private static int ipv6Supported;
		private static int current_bind_count;
		private static MethodInfo check_socket_policy;
	}

	public class	SocketAsyncEventArgs: EventArgs, IDisposable
	{
		protected virtual void Finalize(){}
		private void Dispose(bool disposing){}
		public sealed virtual void Dispose(){}
		protected virtual void OnCompleted(SocketAsyncEventArgs e){}
		public void SetBuffer(int offset, int count){}
		public void SetBuffer(Byte[] buffer, int offset, int count){}
		private void SetBufferInternal(Byte[] buffer, int offset, int count){}
		private void ReceiveCallback(){}
		private void ConnectCallback(){}
		private SocketError TryConnect(EndPoint endpoint){}
		private void SendCallback(){}
		internal void DoOperation(SocketAsyncOperation operation, Socket socket){}
		internal SocketAsyncEventArgs(bool policy){}
		public SocketAsyncEventArgs(){}
		public Socket AcceptSocket{ get	{} set	{} }
		public Byte[] Buffer{ get	{} set	{} }
		public IList<ArraySegment<Byte>> BufferList{ get	{} set	{} }
		public int BytesTransferred{ get	{} set	{} }
		public int Count{ get	{} set	{} }
		public bool DisconnectReuseSocket{ get	{} set	{} }
		public SocketAsyncOperation LastOperation{ get	{} set	{} }
		public int Offset{ get	{} set	{} }
		public EndPoint RemoteEndPoint{ get	{} set	{} }
		public int SendPacketsSendSize{ get	{} set	{} }
		public SocketError SocketError{ get	{} set	{} }
		public SocketFlags SocketFlags{ get	{} set	{} }
		public System.Object UserToken{ get	{} set	{} }
		public Socket ConnectSocket{ get	{} }
		bool PolicyRestricted{ get	{} set	{} }
		public event	EventHandler<SocketAsyncEventArgs> Completed;
		private IList<ArraySegment<Byte>> _bufferList;
		private Socket curSocket;
		private Socket <AcceptSocket>k__BackingField;
		private Byte[] <Buffer>k__BackingField;
		private int <BytesTransferred>k__BackingField;
		private int <Count>k__BackingField;
		private bool <DisconnectReuseSocket>k__BackingField;
		private SocketAsyncOperation <LastOperation>k__BackingField;
		private int <Offset>k__BackingField;
		private EndPoint <RemoteEndPoint>k__BackingField;
		private int <SendPacketsSendSize>k__BackingField;
		private SocketError <SocketError>k__BackingField;
		private SocketFlags <SocketFlags>k__BackingField;
		private System.Object <UserToken>k__BackingField;
		private bool <PolicyRestricted>k__BackingField;
	}

	public class	SocketException: Win32Exception, ISerializable, _Exception
	{
		private static int WSAGetLastError_internal(){}
		public SocketException(){}
		public SocketException(int error){}
		protected SocketException(SerializationInfo info, StreamingContext context){}
		internal SocketException(int error, string message){}
		public virtual int ErrorCode{ get	{} }
		public SocketError SocketErrorCode{ get	{} }
		public virtual string Message{ get	{} }
	}

	public class	TcpClient: Object, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		private void Init(AddressFamily family){}
		internal void SetTcpClient(Socket s){}
		public void Close(){}
		public void Connect(IPEndPoint remote_end_point){}
		public void Connect(IPAddress address, int port){}
		private void SetOptions(){}
		public void Connect(string hostname, int port){}
		public void Connect(IPAddress[] ipAddresses, int port){}
		public void EndConnect(IAsyncResult asyncResult){}
		public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, System.Object state){}
		protected virtual void Dispose(bool disposing){}
		protected virtual void Finalize(){}
		public NetworkStream GetStream(){}
		private void CheckDisposed(){}
		public TcpClient(){}
		public TcpClient(AddressFamily family){}
		public TcpClient(IPEndPoint local_end_point){}
		public TcpClient(string hostname, int port){}
		bool Active{ get	{} set	{} }
		public Socket Client{ get	{} set	{} }
		public int Available{ get	{} }
		public bool Connected{ get	{} }
		public bool ExclusiveAddressUse{ get	{} set	{} }
		public LingerOption LingerState{ get	{} set	{} }
		public bool NoDelay{ get	{} set	{} }
		public int ReceiveBufferSize{ get	{} set	{} }
		public int ReceiveTimeout{ get	{} set	{} }
		public int SendBufferSize{ get	{} set	{} }
		public int SendTimeout{ get	{} set	{} }
		private NetworkStream stream;
		private bool active;
		private Socket client;
		private bool disposed;
		private Properties values;
		private int recv_timeout;
		private int send_timeout;
		private int recv_buffer_size;
		private int send_buffer_size;
		private LingerOption linger_state;
		private bool no_delay;
	}

	public class	TcpListener: Object
	{
		private void Init(AddressFamily family, EndPoint ep){}
		public Socket AcceptSocket(){}
		public TcpClient AcceptTcpClient(){}
		protected virtual void Finalize(){}
		public bool Pending(){}
		public void Start(){}
		public void Start(int backlog){}
		public IAsyncResult BeginAcceptSocket(AsyncCallback callback, System.Object state){}
		public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, System.Object state){}
		public Socket EndAcceptSocket(IAsyncResult asyncResult){}
		public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult){}
		public void Stop(){}
		public TcpListener(int port){}
		public TcpListener(IPEndPoint local_end_point){}
		public TcpListener(IPAddress listen_ip, int port){}
		bool Active{ get	{} }
		public EndPoint LocalEndpoint{ get	{} }
		public Socket Server{ get	{} }
		public bool ExclusiveAddressUse{ get	{} set	{} }
		private bool active;
		private Socket server;
		private EndPoint savedEP;
	}

	public class	UdpClient: Object, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		private void InitSocket(EndPoint localEP){}
		public void Close(){}
		private void DoConnect(IPEndPoint endPoint){}
		public void Connect(IPEndPoint endPoint){}
		public void Connect(IPAddress addr, int port){}
		public void Connect(string hostname, int port){}
		public void DropMulticastGroup(IPAddress multicastAddr){}
		public void DropMulticastGroup(IPAddress multicastAddr, int ifindex){}
		public void JoinMulticastGroup(IPAddress multicastAddr){}
		public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr){}
		public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive){}
		public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress){}
		public Byte[] Receive(ref IPEndPoint remoteEP){}
		private int DoSend(Byte[] dgram, int bytes, IPEndPoint endPoint){}
		public int Send(Byte[] dgram, int bytes){}
		public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint){}
		public int Send(Byte[] dgram, int bytes, string hostname, int port){}
		private Byte[] CutArray(Byte[] orig, int length){}
		private IAsyncResult DoBeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, System.Object state){}
		public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, System.Object state){}
		public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, System.Object state){}
		public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, System.Object state){}
		public int EndSend(IAsyncResult asyncResult){}
		public IAsyncResult BeginReceive(AsyncCallback callback, System.Object state){}
		public Byte[] EndReceive(IAsyncResult asyncResult, ref IPEndPoint remoteEP){}
		protected virtual void Dispose(bool disposing){}
		protected virtual void Finalize(){}
		private void CheckDisposed(){}
		public UdpClient(){}
		public UdpClient(AddressFamily family){}
		public UdpClient(int port){}
		public UdpClient(IPEndPoint localEP){}
		public UdpClient(int port, AddressFamily family){}
		public UdpClient(string hostname, int port){}
		bool Active{ get	{} set	{} }
		public Socket Client{ get	{} set	{} }
		public int Available{ get	{} }
		public bool DontFragment{ get	{} set	{} }
		public bool EnableBroadcast{ get	{} set	{} }
		public bool ExclusiveAddressUse{ get	{} set	{} }
		public bool MulticastLoopback{ get	{} set	{} }
		public short Ttl{ get	{} set	{} }
		private bool disposed;
		private bool active;
		private Socket socket;
		private AddressFamily family;
		private Byte[] recvbuffer;
	}

	delegate void SocketAsyncCall();

	delegate void SendFileHandler(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags);

}

namespace System.Net {
	public class	AuthenticationManager: Object
	{
		private static void EnsureModules(){}
		private static Exception GetMustImplement(){}
		internal static void Clear(){}
		public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials){}
		private static Authorization DoAuthenticate(string challenge, WebRequest request, ICredentials credentials){}
		public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials){}
		public static void Register(IAuthenticationModule authenticationModule){}
		public static void Unregister(IAuthenticationModule authenticationModule){}
		public static void Unregister(string authenticationScheme){}
		private static void DoUnregister(string authenticationScheme, bool throwEx){}
		private AuthenticationManager(){}
		private static AuthenticationManager(){}
		public static ICredentialPolicy CredentialPolicy{ get	{} set	{} }
		public static StringDictionary CustomTargetNameDictionary{ get	{} }
		public static IEnumerator RegisteredModules{ get	{} }
		private static ArrayList modules;
		private static System.Object locker;
		private static ICredentialPolicy credential_policy;
	}

	public class	Authorization: Object
	{
		private static Exception GetMustImplement(){}
		public Authorization(string token){}
		public Authorization(string token, bool complete){}
		public Authorization(string token, bool complete, string connectionGroupId){}
		public string Message{ get	{} }
		public bool Complete{ get	{} }
		public string ConnectionGroupId{ get	{} }
		public String[] ProtectionRealm{ get	{} set	{} }
		IAuthenticationModule Module{ get	{} set	{} }
		public bool MutuallyAuthenticated{ get	{} set	{} }
		private string token;
		private bool complete;
		private string connectionGroupId;
		private String[] protectionRealm;
		private IAuthenticationModule module;
	}

	public sealed class	Cookie: Object
	{
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		private static int hash(int i, int j, int k, int l, int m){}
		public virtual string ToString(){}
		internal string ToString(Uri uri){}
		internal string ToClientString(){}
		private string QuotedString(string value){}
		private bool IsToken(string value){}
		private static bool IsNullOrEmpty(string s){}
		public Cookie(){}
		public Cookie(string name, string value){}
		public Cookie(string name, string value, string path){}
		public Cookie(string name, string value, string path, string domain){}
		private static Cookie(){}
		public string Comment{ get	{} set	{} }
		public Uri CommentUri{ get	{} set	{} }
		public bool Discard{ get	{} set	{} }
		public string Domain{ get	{} set	{} }
		bool ExactDomain{ get	{} set	{} }
		public bool Expired{ get	{} set	{} }
		public DateTime Expires{ get	{} set	{} }
		public bool HttpOnly{ get	{} set	{} }
		public string Name{ get	{} set	{} }
		public string Path{ get	{} set	{} }
		public string Port{ get	{} set	{} }
		Int32[] Ports{ get	{} }
		public bool Secure{ get	{} set	{} }
		public DateTime TimeStamp{ get	{} }
		public string Value{ get	{} set	{} }
		public int Version{ get	{} set	{} }
		private string comment;
		private Uri commentUri;
		private bool discard;
		private string domain;
		private DateTime expires;
		private bool httpOnly;
		private string name;
		private string path;
		private string port;
		private Int32[] ports;
		private bool secure;
		private DateTime timestamp;
		private string val;
		private int version;
		private bool exact_domain;
		private static Char[] reservedCharsName;
		private static Char[] portSeparators;
		private static string tspecials;
	}

	public sealed class	CookieCollection: Object, ICollection, IEnumerable
	{
		public sealed virtual void CopyTo(Array array, int index){}
		public void CopyTo(Cookie[] array, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		public void Add(Cookie cookie){}
		internal void Sort(){}
		private int SearchCookie(Cookie cookie){}
		public void Add(CookieCollection cookies){}
		public CookieCollection(){}
		private static CookieCollection(){}
		IList<Cookie> List{ get	{} }
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		public bool IsReadOnly{ get	{} }
		public Cookie this[int index] { get	{} }
		public Cookie this[string name] { get	{} }
		private List<Cookie> list;
		private static CookieCollectionComparer Comparer;
	}

	public sealed class	CookieContainer: Object
	{
		public void Add(Cookie cookie){}
		private void AddCookie(Cookie cookie){}
		private int CountDomain(string domain){}
		private void RemoveOldest(string domain){}
		private void CheckExpiration(){}
		public void Add(CookieCollection cookies){}
		private void Cook(Uri uri, Cookie cookie){}
		public void Add(Uri uri, Cookie cookie){}
		public void Add(Uri uri, CookieCollection cookies){}
		public string GetCookieHeader(Uri uri){}
		private static bool CheckDomain(string domain, string host, bool exact){}
		public CookieCollection GetCookies(Uri uri){}
		public void SetCookies(Uri uri, string cookieHeader){}
		private static Cookie Parse(string s){}
		private static bool IsNullOrEmpty(string s){}
		public CookieContainer(){}
		public CookieContainer(int capacity){}
		public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize){}
		public int Count{ get	{} }
		public int Capacity{ get	{} set	{} }
		public int MaxCookieSize{ get	{} set	{} }
		public int PerDomainCapacity{ get	{} set	{} }
		private int capacity;
		private int perDomainCapacity;
		private int maxCookieSize;
		private CookieCollection cookies;
		private static Dictionary<String, Int32> <>f__switch$map4;
		public const int DefaultCookieLengthLimit = null;
		public const int DefaultCookieLimit = null;
		public const int DefaultPerDomainCookieLimit = null;
	}

	public class	CookieException: FormatException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public CookieException(){}
		internal CookieException(string msg){}
		internal CookieException(string msg, Exception e){}
		protected CookieException(SerializationInfo info, StreamingContext context){}
	}

	public class	CredentialCache: Object, IEnumerable, ICredentials, ICredentialsByHost
	{
		public sealed virtual NetworkCredential GetCredential(Uri uriPrefix, string authType){}
		public sealed virtual IEnumerator GetEnumerator(){}
		public void Add(Uri uriPrefix, string authType, NetworkCredential cred){}
		public void Remove(Uri uriPrefix, string authType){}
		public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType){}
		public void Add(string host, int port, string authenticationType, NetworkCredential credential){}
		public void Remove(string host, int port, string authenticationType){}
		public CredentialCache(){}
		private static CredentialCache(){}
		public static ICredentials DefaultCredentials{ get	{} }
		public static NetworkCredential DefaultNetworkCredentials{ get	{} }
		private Hashtable cache;
		private Hashtable cacheForHost;
		private static NetworkCredential empty;
	}

	public sealed abstract	class	Dns: Object
	{
		public static IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, System.Object stateObject){}
		public static IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, System.Object stateObject){}
		public static IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, System.Object stateObject){}
		public static IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, System.Object stateObject){}
		public static IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, System.Object stateObject){}
		public static IPHostEntry EndGetHostByName(IAsyncResult asyncResult){}
		public static IPHostEntry EndResolve(IAsyncResult asyncResult){}
		public static IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult){}
		public static IPHostEntry EndGetHostEntry(IAsyncResult asyncResult){}
		private static bool GetHostByName_internal(string host, out string h_name, out String[] h_aliases, out String[] h_addr_list){}
		private static bool GetHostByAddr_internal(string addr, out string h_name, out String[] h_aliases, out String[] h_addr_list){}
		private static bool GetHostName_internal(out string h_name){}
		private static IPHostEntry hostent_to_IPHostEntry(string h_name, String[] h_aliases, String[] h_addrlist){}
		public static IPHostEntry GetHostByAddress(IPAddress address){}
		public static IPHostEntry GetHostByAddress(string address){}
		private static IPHostEntry GetHostByAddressFromString(string address, bool parse){}
		public static IPHostEntry GetHostEntry(string hostNameOrAddress){}
		public static IPHostEntry GetHostEntry(IPAddress address){}
		public static IPAddress[] GetHostAddresses(string hostNameOrAddress){}
		public static IPHostEntry GetHostByName(string hostName){}
		public static string GetHostName(){}
		public static IPHostEntry Resolve(string hostName){}
		private static Dns(){}
	}

	public class	DownloadDataCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal DownloadDataCompletedEventArgs(Byte[] result, Exception error, bool cancelled, System.Object userState){}
		public Byte[] Result{ get	{} }
		private Byte[] result;
	}

	public class	DownloadProgressChangedEventArgs: ProgressChangedEventArgs
	{
		internal DownloadProgressChangedEventArgs(long bytesReceived, long totalBytesToReceive, System.Object userState){}
		public long BytesReceived{ get	{} }
		public long TotalBytesToReceive{ get	{} }
		private long received;
		private long total;
	}

	public class	DownloadStringCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal DownloadStringCompletedEventArgs(string result, Exception error, bool cancelled, System.Object userState){}
		public string Result{ get	{} }
		private string result;
	}

	public abstract	class	EndPoint: Object
	{
		public virtual EndPoint Create(SocketAddress address){}
		public virtual SocketAddress Serialize(){}
		private static Exception NotImplemented(){}
		protected EndPoint(){}
		public virtual AddressFamily AddressFamily{ get	{} }
	}

	public class	FileWebRequest: WebRequest, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static Exception GetMustImplement(){}
		public virtual void Abort(){}
		public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, System.Object state){}
		public virtual Stream EndGetRequestStream(IAsyncResult asyncResult){}
		public virtual Stream GetRequestStream(){}
		internal Stream GetRequestStreamInternal(){}
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, System.Object state){}
		public virtual WebResponse EndGetResponse(IAsyncResult asyncResult){}
		public virtual WebResponse GetResponse(){}
		private WebResponse GetResponseInternal(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		internal void Close(){}
		internal FileWebRequest(Uri uri){}
		protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual string ConnectionGroupName{ get	{} set	{} }
		public virtual long ContentLength{ get	{} set	{} }
		public virtual string ContentType{ get	{} set	{} }
		public virtual ICredentials Credentials{ get	{} set	{} }
		public virtual WebHeaderCollection Headers{ get	{} }
		public virtual string Method{ get	{} set	{} }
		public virtual bool PreAuthenticate{ get	{} set	{} }
		public virtual IWebProxy Proxy{ get	{} set	{} }
		public virtual Uri RequestUri{ get	{} }
		public virtual int Timeout{ get	{} set	{} }
		public virtual bool UseDefaultCredentials{ get	{} set	{} }
		private Uri uri;
		private WebHeaderCollection webHeaders;
		private ICredentials credentials;
		private string connectionGroup;
		private long contentLength;
		private FileAccess fileAccess;
		private string method;
		private IWebProxy proxy;
		private bool preAuthenticate;
		private int timeout;
		private Stream requestStream;
		private FileWebResponse webResponse;
		private AutoResetEvent requestEndEvent;
		private bool requesting;
		private bool asyncResponding;
	}

	public class	FileWebResponse: WebResponse, IDisposable, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private sealed virtual void System.IDisposable.Dispose(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual Stream GetResponseStream(){}
		protected virtual void Finalize(){}
		public virtual void Close(){}
		private void Dispose(bool disposing){}
		private void CheckDisposed(){}
		internal FileWebResponse(Uri responseUri, FileStream fileStream){}
		protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual long ContentLength{ get	{} }
		public virtual string ContentType{ get	{} }
		public virtual WebHeaderCollection Headers{ get	{} }
		public virtual Uri ResponseUri{ get	{} }
		private Uri responseUri;
		private FileStream fileStream;
		private long contentLength;
		private WebHeaderCollection webHeaders;
		private bool disposed;
	}

	public sealed class	FtpWebRequest: WebRequest, ISerializable
	{
		private static Exception GetMustImplement(){}
		public virtual void Abort(){}
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, System.Object state){}
		public virtual WebResponse EndGetResponse(IAsyncResult asyncResult){}
		public virtual WebResponse GetResponse(){}
		public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, System.Object state){}
		public virtual Stream EndGetRequestStream(IAsyncResult asyncResult){}
		public virtual Stream GetRequestStream(){}
		private ServicePoint GetServicePoint(){}
		private void ResolveHost(){}
		private void ProcessRequest(){}
		private void SetType(){}
		private string GetRemoteFolderPath(Uri uri){}
		private void CWDAndSetFileName(Uri uri){}
		private void ProcessMethod(){}
		private void CloseControlConnection(){}
		internal void CloseDataConnection(){}
		private void CloseConnection(){}
		private void ProcessSimpleMethod(){}
		private void UploadData(){}
		private void DownloadData(){}
		private void CheckRequestStarted(){}
		private void OpenControlConnection(){}
		private static string GetInitialPath(FtpStatus status){}
		private Socket SetupPassiveConnection(string statusDescription){}
		private Exception CreateExceptionFromResponse(FtpStatus status){}
		internal void SetTransferCompleted(){}
		internal void OperationCompleted(){}
		private void SetCompleteWithError(Exception exc){}
		private Socket InitDataConnection(){}
		private void OpenDataConnection(){}
		private void Authenticate(){}
		private FtpStatus SendCommand(string command, String[] parameters){}
		private FtpStatus SendCommand(bool waitResponse, string command, String[] parameters){}
		internal static FtpStatus ServiceNotAvailable(){}
		internal FtpStatus GetResponseStatus(){}
		private void InitiateSecureConnection(ref Stream stream){}
		internal bool ChangeToSSLSocket(ref Stream stream){}
		private bool InFinalState(){}
		private bool InProgress(){}
		internal void CheckIfAborted(){}
		private void CheckFinalState(){}
		private static bool <callback>m__B(System.Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors){}
		internal FtpWebRequest(Uri uri){}
		private static FtpWebRequest(){}
		public X509CertificateCollection ClientCertificates{ get	{} set	{} }
		public virtual string ConnectionGroupName{ get	{} set	{} }
		public virtual string ContentType{ get	{} set	{} }
		public virtual long ContentLength{ get	{} set	{} }
		public long ContentOffset{ get	{} set	{} }
		public virtual ICredentials Credentials{ get	{} set	{} }
		public static RequestCachePolicy DefaultCachePolicy{ get	{} set	{} }
		public bool EnableSsl{ get	{} set	{} }
		public virtual WebHeaderCollection Headers{ get	{} set	{} }
		public bool KeepAlive{ get	{} set	{} }
		public virtual string Method{ get	{} set	{} }
		public virtual bool PreAuthenticate{ get	{} set	{} }
		public virtual IWebProxy Proxy{ get	{} set	{} }
		public int ReadWriteTimeout{ get	{} set	{} }
		public string RenameTo{ get	{} set	{} }
		public virtual Uri RequestUri{ get	{} }
		public ServicePoint ServicePoint{ get	{} }
		public bool UsePassive{ get	{} set	{} }
		public virtual bool UseDefaultCredentials{ get	{} set	{} }
		public bool UseBinary{ get	{} set	{} }
		public virtual int Timeout{ get	{} set	{} }
		string DataType{ get	{} }
		RequestState State{ get	{} set	{} }
		private Uri requestUri;
		private string file_name;
		private ServicePoint servicePoint;
		private Stream origDataStream;
		private Stream dataStream;
		private Stream controlStream;
		private StreamReader controlReader;
		private NetworkCredential credentials;
		private IPHostEntry hostEntry;
		private IPEndPoint localEndPoint;
		private IWebProxy proxy;
		private int timeout;
		private int rwTimeout;
		private long offset;
		private bool binary;
		private bool enableSsl;
		private bool usePassive;
		private bool keepAlive;
		private string method;
		private string renameTo;
		private System.Object locker;
		private RequestState requestState;
		private FtpAsyncResult asyncResult;
		private FtpWebResponse ftpResponse;
		private Stream requestStream;
		private string initial_path;
		private RemoteCertificateValidationCallback callback;
		private readonly static String[] supportedCommands;
		private static RemoteCertificateValidationCallback <>f__am$cache1C;
		private static Dictionary<String, Int32> <>f__switch$map5;
		private static Dictionary<String, Int32> <>f__switch$map6;
		private const string ChangeDir = null;
		private const string UserCommand = null;
		private const string PasswordCommand = null;
		private const string TypeCommand = null;
		private const string PassiveCommand = null;
		private const string PortCommand = null;
		private const string AbortCommand = null;
		private const string AuthCommand = null;
		private const string RestCommand = null;
		private const string RenameFromCommand = null;
		private const string RenameToCommand = null;
		private const string QuitCommand = null;
		private const string EOL = null;
	}

	public class	FtpWebResponse: WebResponse, IDisposable, ISerializable
	{
		public virtual void Close(){}
		public virtual Stream GetResponseStream(){}
		internal void UpdateStatus(FtpStatus status){}
		private void CheckDisposed(){}
		internal bool IsFinal(){}
		internal FtpWebResponse(FtpWebRequest request, Uri uri, string method, bool keepAlive){}
		internal FtpWebResponse(FtpWebRequest request, Uri uri, string method, FtpStatusCode statusCode, string statusDescription){}
		internal FtpWebResponse(FtpWebRequest request, Uri uri, string method, FtpStatus status){}
		public virtual long ContentLength{ get	{} }
		public virtual WebHeaderCollection Headers{ get	{} }
		public virtual Uri ResponseUri{ get	{} }
		public DateTime LastModified{ get	{} set	{} }
		public string BannerMessage{ get	{} set	{} }
		public string WelcomeMessage{ get	{} set	{} }
		public string ExitMessage{ get	{} set	{} }
		public FtpStatusCode StatusCode{ get	{} set	{} }
		public string StatusDescription{ get	{} set	{} }
		Stream Stream{ get	{} set	{} }
		private Stream stream;
		private Uri uri;
		private FtpStatusCode statusCode;
		private DateTime lastModified;
		private string bannerMessage;
		private string welcomeMessage;
		private string exitMessage;
		private string statusDescription;
		private string method;
		private bool disposed;
		private FtpWebRequest request;
		internal long contentLength;
	}

	public class	GlobalProxySelection: Object
	{
		public static IWebProxy GetEmptyWebProxy(){}
		public GlobalProxySelection(){}
		public static IWebProxy Select{ get	{} set	{} }
	}

	public sealed class	HttpListener: Object, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		public void Abort(){}
		public void Close(){}
		private void Close(bool force){}
		private void Cleanup(bool close_existing){}
		public IAsyncResult BeginGetContext(AsyncCallback callback, System.Object state){}
		public HttpListenerContext EndGetContext(IAsyncResult asyncResult){}
		internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context){}
		public HttpListenerContext GetContext(){}
		public void Start(){}
		public void Stop(){}
		internal void CheckDisposed(){}
		private HttpListenerContext GetContextFromQueue(){}
		internal void RegisterContext(HttpListenerContext context){}
		internal void UnregisterContext(HttpListenerContext context){}
		public HttpListener(){}
		public AuthenticationSchemes AuthenticationSchemes{ get	{} set	{} }
		public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate{ get	{} set	{} }
		public bool IgnoreWriteExceptions{ get	{} set	{} }
		public bool IsListening{ get	{} }
		public static bool IsSupported{ get	{} }
		public HttpListenerPrefixCollection Prefixes{ get	{} }
		public string Realm{ get	{} set	{} }
		public bool UnsafeConnectionNtlmAuthentication{ get	{} set	{} }
		private AuthenticationSchemes auth_schemes;
		private HttpListenerPrefixCollection prefixes;
		private AuthenticationSchemeSelector auth_selector;
		private string realm;
		private bool ignore_write_exceptions;
		private bool unsafe_ntlm_auth;
		private bool listening;
		private bool disposed;
		private Hashtable registry;
		private ArrayList ctx_queue;
		private ArrayList wait_queue;
	}

	public class	HttpListenerBasicIdentity: GenericIdentity, IIdentity
	{
		public HttpListenerBasicIdentity(string username, string password){}
		public virtual string Password{ get	{} }
		private string password;
	}

	public sealed class	HttpListenerContext: Object
	{
		internal void ParseAuthentication(AuthenticationSchemes expectedSchemes){}
		internal IPrincipal ParseBasicAuthentication(string authData){}
		internal HttpListenerContext(HttpConnection cnc){}
		int ErrorStatus{ get	{} set	{} }
		string ErrorMessage{ get	{} set	{} }
		bool HaveError{ get	{} }
		HttpConnection Connection{ get	{} }
		public HttpListenerRequest Request{ get	{} }
		public HttpListenerResponse Response{ get	{} }
		public IPrincipal User{ get	{} }
		private HttpListenerRequest request;
		private HttpListenerResponse response;
		private IPrincipal user;
		private HttpConnection cnc;
		private string error;
		private int err_status;
		internal HttpListener Listener;
	}

	public class	HttpListenerException: Win32Exception, ISerializable, _Exception
	{
		public HttpListenerException(){}
		public HttpListenerException(int errorCode){}
		public HttpListenerException(int errorCode, string message){}
		protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual int ErrorCode{ get	{} }
	}

	public class	HttpListenerPrefixCollection: Object, IEnumerable, ICollection<String>, IEnumerable<String>
	{
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public sealed virtual void Add(string uriPrefix){}
		public sealed virtual void Clear(){}
		public sealed virtual bool Contains(string uriPrefix){}
		public sealed virtual void CopyTo(String[] array, int offset){}
		public void CopyTo(Array array, int offset){}
		public sealed virtual IEnumerator<String> GetEnumerator(){}
		public sealed virtual bool Remove(string uriPrefix){}
		internal HttpListenerPrefixCollection(HttpListener listener){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsReadOnly{ get	{} }
		public bool IsSynchronized{ get	{} }
		private List<String> prefixes;
		private HttpListener listener;
	}

	public sealed class	HttpListenerRequest: Object
	{
		internal void SetRequestLine(string req){}
		private void CreateQueryString(string query){}
		internal void FinishInitialization(){}
		internal static string Unquote(string str){}
		internal void AddHeader(string header){}
		internal bool FlushInput(){}
		public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, System.Object state){}
		public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult){}
		public X509Certificate2 GetClientCertificate(){}
		internal HttpListenerRequest(HttpListenerContext context){}
		private static HttpListenerRequest(){}
		public String[] AcceptTypes{ get	{} }
		public int ClientCertificateError{ get	{} }
		public Encoding ContentEncoding{ get	{} }
		public long ContentLength64{ get	{} }
		public string ContentType{ get	{} }
		public CookieCollection Cookies{ get	{} }
		public bool HasEntityBody{ get	{} }
		public NameValueCollection Headers{ get	{} }
		public string HttpMethod{ get	{} }
		public Stream InputStream{ get	{} }
		public bool IsAuthenticated{ get	{} }
		public bool IsLocal{ get	{} }
		public bool IsSecureConnection{ get	{} }
		public bool KeepAlive{ get	{} }
		public IPEndPoint LocalEndPoint{ get	{} }
		public Version ProtocolVersion{ get	{} }
		public NameValueCollection QueryString{ get	{} }
		public string RawUrl{ get	{} }
		public IPEndPoint RemoteEndPoint{ get	{} }
		public Guid RequestTraceIdentifier{ get	{} }
		public Uri Url{ get	{} }
		public Uri UrlReferrer{ get	{} }
		public string UserAgent{ get	{} }
		public string UserHostAddress{ get	{} }
		public string UserHostName{ get	{} }
		public String[] UserLanguages{ get	{} }
		private String[] accept_types;
		private Encoding content_encoding;
		private long content_length;
		private bool cl_set;
		private CookieCollection cookies;
		private WebHeaderCollection headers;
		private string method;
		private Stream input_stream;
		private Version version;
		private NameValueCollection query_string;
		private string raw_url;
		private Guid identifier;
		private Uri url;
		private Uri referrer;
		private String[] user_languages;
		private HttpListenerContext context;
		private bool is_chunked;
		private static Byte[] _100continue;
		private readonly static String[] no_body_methods;
		private static Char[] separators;
		private static Dictionary<String, Int32> <>f__switch$map7;
	}

	public sealed class	HttpListenerResponse: Object, IDisposable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		internal static string GetStatusDescription(int code){}
		public void Abort(){}
		public void AddHeader(string name, string value){}
		public void AppendCookie(Cookie cookie){}
		public void AppendHeader(string name, string value){}
		private void Close(bool force){}
		public void Close(){}
		public void Close(Byte[] responseEntity, bool willBlock){}
		public void CopyFrom(HttpListenerResponse templateResponse){}
		public void Redirect(string url){}
		private bool FindCookie(Cookie cookie){}
		internal void SendHeaders(bool closing, MemoryStream ms){}
		public void SetCookie(Cookie cookie){}
		internal HttpListenerResponse(HttpListenerContext context){}
		bool ForceCloseChunked{ get	{} }
		public Encoding ContentEncoding{ get	{} set	{} }
		public long ContentLength64{ get	{} set	{} }
		public string ContentType{ get	{} set	{} }
		public CookieCollection Cookies{ get	{} set	{} }
		public WebHeaderCollection Headers{ get	{} set	{} }
		public bool KeepAlive{ get	{} set	{} }
		public Stream OutputStream{ get	{} }
		public Version ProtocolVersion{ get	{} set	{} }
		public string RedirectLocation{ get	{} set	{} }
		public bool SendChunked{ get	{} set	{} }
		public int StatusCode{ get	{} set	{} }
		public string StatusDescription{ get	{} set	{} }
		private bool disposed;
		private Encoding content_encoding;
		private long content_length;
		private bool cl_set;
		private string content_type;
		private CookieCollection cookies;
		private WebHeaderCollection headers;
		private bool keep_alive;
		private ResponseStream output_stream;
		private Version version;
		private string location;
		private int status_code;
		private string status_description;
		private bool chunked;
		private HttpListenerContext context;
		internal bool HeadersSent;
		private bool force_close_chunked;
	}

	public class	HttpVersion: Object
	{
		public HttpVersion(){}
		private static HttpVersion(){}
		public readonly static Version Version10;
		public readonly static Version Version11;
	}

	public class	HttpWebRequest: WebRequest, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static Exception GetMustImplement(){}
		internal ServicePoint GetServicePoint(){}
		public void AddRange(int range){}
		public void AddRange(int from, int to){}
		public void AddRange(string rangeSpecifier, int range){}
		public void AddRange(string rangeSpecifier, int from, int to){}
		public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, System.Object state){}
		public virtual Stream EndGetRequestStream(IAsyncResult asyncResult){}
		public virtual Stream GetRequestStream(){}
		private void CheckIfForceWrite(){}
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, System.Object state){}
		public virtual WebResponse EndGetResponse(IAsyncResult asyncResult){}
		public virtual WebResponse GetResponse(){}
		public virtual void Abort(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private void CheckRequestStarted(){}
		internal void DoContinueDelegate(int statusCode, WebHeaderCollection headers){}
		private bool Redirect(WebAsyncResult result, HttpStatusCode code){}
		private string GetHeaders(){}
		private void DoPreAuthenticate(){}
		internal void SetWriteStreamError(WebExceptionStatus status, Exception exc){}
		internal void SendRequestHeaders(bool propagate_error){}
		internal void SetWriteStream(WebConnectionStream stream){}
		internal void SetResponseError(WebExceptionStatus status, Exception e, string where){}
		private void CheckSendError(WebConnectionData data){}
		private void HandleNtlmAuth(WebAsyncResult r){}
		internal void SetResponseData(WebConnectionData data){}
		private bool CheckAuthorization(WebResponse response, HttpStatusCode code){}
		private bool CheckFinalStatus(WebAsyncResult result){}
		public HttpWebRequest(Uri uri){}
		protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static HttpWebRequest(){}
		bool UsesNtlmAuthentication{ get	{} }
		public string Accept{ get	{} set	{} }
		public Uri Address{ get	{} }
		public bool AllowAutoRedirect{ get	{} set	{} }
		public bool AllowWriteStreamBuffering{ get	{} set	{} }
		public DecompressionMethods AutomaticDecompression{ get	{} set	{} }
		bool InternalAllowBuffering{ get	{} }
		public X509CertificateCollection ClientCertificates{ get	{} set	{} }
		public string Connection{ get	{} set	{} }
		public virtual string ConnectionGroupName{ get	{} set	{} }
		public virtual long ContentLength{ get	{} set	{} }
		long InternalContentLength{ set	{} }
		public virtual string ContentType{ get	{} set	{} }
		public HttpContinueDelegate ContinueDelegate{ get	{} set	{} }
		public CookieContainer CookieContainer{ get	{} set	{} }
		public virtual ICredentials Credentials{ get	{} set	{} }
		public static RequestCachePolicy DefaultCachePolicy{ get	{} set	{} }
		public static int DefaultMaximumErrorResponseLength{ get	{} set	{} }
		public string Expect{ get	{} set	{} }
		public bool HaveResponse{ get	{} }
		public virtual WebHeaderCollection Headers{ get	{} set	{} }
		public DateTime IfModifiedSince{ get	{} set	{} }
		public bool KeepAlive{ get	{} set	{} }
		public int MaximumAutomaticRedirections{ get	{} set	{} }
		public int MaximumResponseHeadersLength{ get	{} set	{} }
		public static int DefaultMaximumResponseHeadersLength{ get	{} set	{} }
		public int ReadWriteTimeout{ get	{} set	{} }
		public string MediaType{ get	{} set	{} }
		public virtual string Method{ get	{} set	{} }
		public bool Pipelined{ get	{} set	{} }
		public virtual bool PreAuthenticate{ get	{} set	{} }
		public Version ProtocolVersion{ get	{} set	{} }
		public virtual IWebProxy Proxy{ get	{} set	{} }
		public string Referer{ get	{} set	{} }
		public virtual Uri RequestUri{ get	{} }
		public bool SendChunked{ get	{} set	{} }
		public ServicePoint ServicePoint{ get	{} }
		public virtual int Timeout{ get	{} set	{} }
		public string TransferEncoding{ get	{} set	{} }
		public virtual bool UseDefaultCredentials{ get	{} set	{} }
		public string UserAgent{ get	{} set	{} }
		public bool UnsafeAuthenticatedConnectionSharing{ get	{} set	{} }
		bool GotRequestStream{ get	{} }
		bool ExpectContinue{ get	{} set	{} }
		Uri AuthUri{ get	{} }
		bool ProxyQuery{ get	{} }
		bool FinishedReading{ get	{} set	{} }
		bool Aborted{ get	{} }
		private Uri requestUri;
		private Uri actualUri;
		private bool hostChanged;
		private bool allowAutoRedirect;
		private bool allowBuffering;
		private X509CertificateCollection certificates;
		private string connectionGroup;
		private long contentLength;
		private HttpContinueDelegate continueDelegate;
		private CookieContainer cookieContainer;
		private ICredentials credentials;
		private bool haveResponse;
		private bool haveRequest;
		private bool requestSent;
		private WebHeaderCollection webHeaders;
		private bool keepAlive;
		private int maxAutoRedirect;
		private string mediaType;
		private string method;
		private string initialMethod;
		private bool pipelined;
		private bool preAuthenticate;
		private bool usedPreAuth;
		private Version version;
		private Version actualVersion;
		private IWebProxy proxy;
		private bool sendChunked;
		private ServicePoint servicePoint;
		private int timeout;
		private WebConnectionStream writeStream;
		private HttpWebResponse webResponse;
		private WebAsyncResult asyncWrite;
		private WebAsyncResult asyncRead;
		private EventHandler abortHandler;
		private int aborted;
		private bool gotRequestStream;
		private int redirects;
		private bool expectContinue;
		private bool authCompleted;
		private Byte[] bodyBuffer;
		private int bodyBufferLength;
		private bool getResponseCalled;
		private Exception saved_exc;
		private System.Object locker;
		private bool is_ntlm_auth;
		private bool finished_reading;
		internal WebConnection WebConnection;
		private DecompressionMethods auto_decomp;
		private int maxResponseHeadersLength;
		private int readWriteTimeout;
		private bool unsafe_auth_blah;
		private static int defaultMaxResponseHeadersLength;
	}

	public class	HttpWebResponse: WebResponse, IDisposable, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private sealed virtual void System.IDisposable.Dispose(){}
		private static Exception GetMustImplement(){}
		public string GetResponseHeader(string headerName){}
		internal void ReadAll(){}
		public virtual Stream GetResponseStream(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual void Close(){}
		private void Dispose(bool disposing){}
		private void CheckDisposed(){}
		private void FillCookies(){}
		private void SetCookie(string header){}
		private void SetCookie2(string cookies_str){}
		private DateTime TryParseCookieExpires(string value){}
		internal HttpWebResponse(Uri uri, string method, WebConnectionData data, CookieContainer container){}
		protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public string CharacterSet{ get	{} }
		public string ContentEncoding{ get	{} }
		public virtual long ContentLength{ get	{} }
		public virtual string ContentType{ get	{} }
		public CookieCollection Cookies{ get	{} set	{} }
		public virtual WebHeaderCollection Headers{ get	{} }
		public virtual bool IsMutuallyAuthenticated{ get	{} }
		public DateTime LastModified{ get	{} }
		public string Method{ get	{} }
		public Version ProtocolVersion{ get	{} }
		public virtual Uri ResponseUri{ get	{} }
		public string Server{ get	{} }
		public HttpStatusCode StatusCode{ get	{} }
		public string StatusDescription{ get	{} }
		private Uri uri;
		private WebHeaderCollection webHeaders;
		private CookieCollection cookieCollection;
		private string method;
		private Version version;
		private HttpStatusCode statusCode;
		private string statusDescription;
		private long contentLength;
		private string contentType;
		private CookieContainer cookie_container;
		private bool disposed;
		private Stream stream;
		private String[] cookieExpiresFormats;
		private static Dictionary<String, Int32> <>f__switch$map8;
	}

	public interface IAuthenticationModule	{
		Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
		Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
		string AuthenticationType{ get; }
		bool CanPreAuthenticate{ get; }
	}

	public interface ICertificatePolicy	{
		bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem);
	}

	public interface ICredentials	{
		NetworkCredential GetCredential(Uri uri, string authType);
	}

	public interface ICredentialPolicy	{
		bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
	}

	public interface ICredentialsByHost	{
		NetworkCredential GetCredential(string host, int port, string authType);
	}

	public class	IPAddress: Object
	{
		private static short SwapShort(short number){}
		private static int SwapInt(int number){}
		private static long SwapLong(long number){}
		public static short HostToNetworkOrder(short host){}
		public static int HostToNetworkOrder(int host){}
		public static long HostToNetworkOrder(long host){}
		public static short NetworkToHostOrder(short network){}
		public static int NetworkToHostOrder(int network){}
		public static long NetworkToHostOrder(long network){}
		public static IPAddress Parse(string ipString){}
		public static bool TryParse(string ipString, out IPAddress address){}
		private static IPAddress ParseIPV4(string ip){}
		private static IPAddress ParseIPV6(string ip){}
		public Byte[] GetAddressBytes(){}
		public static bool IsLoopback(IPAddress addr){}
		public virtual string ToString(){}
		private static string ToString(long addr){}
		public virtual bool Equals(System.Object other){}
		public virtual int GetHashCode(){}
		private static int Hash(int i, int j, int k, int l){}
		public IPAddress(long addr){}
		public IPAddress(Byte[] address){}
		public IPAddress(Byte[] address, long scopeId){}
		internal IPAddress(UInt16[] address, long scopeId){}
		private static IPAddress(){}
		public long Address{ get	{} set	{} }
		long InternalIPv4Address{ get	{} }
		public bool IsIPv6LinkLocal{ get	{} }
		public bool IsIPv6SiteLocal{ get	{} }
		public bool IsIPv6Multicast{ get	{} }
		public long ScopeId{ get	{} set	{} }
		public AddressFamily AddressFamily{ get	{} }
		private long m_Address;
		private AddressFamily m_Family;
		private UInt16[] m_Numbers;
		private long m_ScopeId;
		private int m_HashCode;
		public readonly static IPAddress Any;
		public readonly static IPAddress Broadcast;
		public readonly static IPAddress Loopback;
		public readonly static IPAddress None;
		public readonly static IPAddress IPv6Any;
		public readonly static IPAddress IPv6Loopback;
		public readonly static IPAddress IPv6None;
	}

	public class	IPEndPoint: EndPoint
	{
		public virtual EndPoint Create(SocketAddress socketAddress){}
		public virtual SocketAddress Serialize(){}
		public virtual string ToString(){}
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public IPEndPoint(IPAddress address, int port){}
		public IPEndPoint(long iaddr, int port){}
		public IPAddress Address{ get	{} set	{} }
		public virtual AddressFamily AddressFamily{ get	{} }
		public int Port{ get	{} set	{} }
		private IPAddress address;
		private int port;
		public const int MaxPort = null;
		public const int MinPort = null;
	}

	public class	IPHostEntry: Object
	{
		public IPHostEntry(){}
		public IPAddress[] AddressList{ get	{} set	{} }
		public String[] Aliases{ get	{} set	{} }
		public string HostName{ get	{} set	{} }
		private IPAddress[] addressList;
		private String[] aliases;
		private string hostName;
	}

	public interface IWebProxy	{
		Uri GetProxy(Uri destination);
		bool IsBypassed(Uri host);
		ICredentials Credentials{ get; set; }
	}

	public interface IWebProxyScript	{
		void Close();
		bool Load(Uri scriptLocation, string Script, Type helperType);
		string Run(string url, string host);
	}

	public interface IWebRequestCreate	{
		WebRequest Create(Uri uri);
	}

	public class	NetworkCredential: Object, ICredentials
	{
		public sealed virtual NetworkCredential GetCredential(Uri uri, string authType){}
		public NetworkCredential(){}
		public NetworkCredential(string userName, string password){}
		public NetworkCredential(string userName, string password, string domain){}
		public string Domain{ get	{} set	{} }
		public string UserName{ get	{} set	{} }
		public string Password{ get	{} set	{} }
		private string userName;
		private string password;
		private string domain;
	}

	public class	OpenReadCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal OpenReadCompletedEventArgs(Stream result, Exception error, bool cancelled, System.Object userState){}
		public Stream Result{ get	{} }
		private Stream result;
	}

	public class	OpenWriteCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal OpenWriteCompletedEventArgs(Stream result, Exception error, bool cancelled, System.Object userState){}
		public Stream Result{ get	{} }
		private Stream result;
	}

	public class	ProtocolViolationException: InvalidOperationException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public ProtocolViolationException(){}
		public ProtocolViolationException(string message){}
		protected ProtocolViolationException(SerializationInfo info, StreamingContext context){}
	}

	public class	ServicePoint: Object
	{
		private static Exception GetMustImplement(){}
		internal void SetVersion(Version version){}
		private WebConnectionGroup GetConnectionGroup(string name){}
		internal EventHandler SendRequest(HttpWebRequest request, string groupName){}
		public bool CloseConnectionGroup(string connectionGroupName){}
		internal void IncrementConnection(){}
		internal void DecrementConnection(){}
		internal void SetCertificates(X509Certificate client, X509Certificate server){}
		internal bool CallEndPointDelegate(Socket sock, IPEndPoint remote){}
		internal ServicePoint(Uri uri, int connectionLimit, int maxIdleTime){}
		public Uri Address{ get	{} }
		public BindIPEndPoint BindIPEndPointDelegate{ get	{} set	{} }
		public X509Certificate Certificate{ get	{} }
		public X509Certificate ClientCertificate{ get	{} }
		public int ConnectionLeaseTimeout{ get	{} set	{} }
		public int ConnectionLimit{ get	{} set	{} }
		public string ConnectionName{ get	{} }
		public int CurrentConnections{ get	{} }
		public DateTime IdleSince{ get	{} set	{} }
		public int MaxIdleTime{ get	{} set	{} }
		public virtual Version ProtocolVersion{ get	{} }
		public int ReceiveBufferSize{ get	{} set	{} }
		public bool SupportsPipelining{ get	{} }
		public bool Expect100Continue{ get	{} set	{} }
		public bool UseNagleAlgorithm{ get	{} set	{} }
		bool SendContinue{ get	{} set	{} }
		bool UsesProxy{ get	{} set	{} }
		bool UseConnect{ get	{} set	{} }
		bool AvailableForRecycling{ get	{} }
		Hashtable Groups{ get	{} }
		IPHostEntry HostEntry{ get	{} }
		private Uri uri;
		private int connectionLimit;
		private int maxIdleTime;
		private int currentConnections;
		private DateTime idleSince;
		private Version protocolVersion;
		private X509Certificate certificate;
		private X509Certificate clientCertificate;
		private IPHostEntry host;
		private bool usesProxy;
		private Hashtable groups;
		private bool sendContinue;
		private bool useConnect;
		private System.Object locker;
		private System.Object hostE;
		private bool useNagle;
		private BindIPEndPoint endPointCallback;
	}

	public class	ServicePointManager: Object
	{
		private static Exception GetMustImplement(){}
		public static ServicePoint FindServicePoint(Uri address){}
		public static ServicePoint FindServicePoint(string uriString, IWebProxy proxy){}
		public static ServicePoint FindServicePoint(Uri address, IWebProxy proxy){}
		internal static void RecycleServicePoints(){}
		private ServicePointManager(){}
		private static ServicePointManager(){}
		public static ICertificatePolicy CertificatePolicy{ get	{} set	{} }
		public static bool CheckCertificateRevocationList{ get	{} set	{} }
		public static int DefaultConnectionLimit{ get	{} set	{} }
		public static int DnsRefreshTimeout{ get	{} set	{} }
		public static bool EnableDnsRoundRobin{ get	{} set	{} }
		public static int MaxServicePointIdleTime{ get	{} set	{} }
		public static int MaxServicePoints{ get	{} set	{} }
		public static SecurityProtocolType SecurityProtocol{ get	{} set	{} }
		public static RemoteCertificateValidationCallback ServerCertificateValidationCallback{ get	{} set	{} }
		public static bool Expect100Continue{ get	{} set	{} }
		public static bool UseNagleAlgorithm{ get	{} set	{} }
		private static HybridDictionary servicePoints;
		private static ICertificatePolicy policy;
		private static int defaultConnectionLimit;
		private static int maxServicePointIdleTime;
		private static int maxServicePoints;
		private static bool _checkCRL;
		private static SecurityProtocolType _securityProtocol;
		private static bool expectContinue;
		private static bool useNagle;
		private static RemoteCertificateValidationCallback server_cert_cb;
		public const int DefaultNonPersistentConnectionLimit = null;
		public const int DefaultPersistentConnectionLimit = null;
	}

	public class	SocketAddress: Object
	{
		public virtual string ToString(){}
		public virtual bool Equals(System.Object obj){}
		public virtual int GetHashCode(){}
		public SocketAddress(AddressFamily family, int size){}
		public SocketAddress(AddressFamily family){}
		public AddressFamily Family{ get	{} }
		public int Size{ get	{} }
		public byte this[int offset] { get	{} set	{} }
		private Byte[] data;
	}

	public class	UploadDataCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal UploadDataCompletedEventArgs(Byte[] result, Exception error, bool cancelled, System.Object userState){}
		public Byte[] Result{ get	{} }
		private Byte[] result;
	}

	public class	UploadFileCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal UploadFileCompletedEventArgs(Byte[] result, Exception error, bool cancelled, System.Object userState){}
		public Byte[] Result{ get	{} }
		private Byte[] result;
	}

	public class	UploadProgressChangedEventArgs: ProgressChangedEventArgs
	{
		internal UploadProgressChangedEventArgs(long bytesReceived, long totalBytesToReceive, long bytesSent, long totalBytesToSend, int progressPercentage, System.Object userState){}
		public long BytesReceived{ get	{} }
		public long TotalBytesToReceive{ get	{} }
		public long BytesSent{ get	{} }
		public long TotalBytesToSend{ get	{} }
		private long received;
		private long sent;
		private long total_recv;
		private long total_send;
	}

	public class	UploadStringCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal UploadStringCompletedEventArgs(string result, Exception error, bool cancelled, System.Object userState){}
		public string Result{ get	{} }
		private string result;
	}

	public class	UploadValuesCompletedEventArgs: AsyncCompletedEventArgs
	{
		internal UploadValuesCompletedEventArgs(Byte[] result, Exception error, bool cancelled, System.Object userState){}
		public Byte[] Result{ get	{} }
		private Byte[] result;
	}

	public class	WebClient: Component, IDisposable, IComponent
	{
		private void <UploadValuesAsync>m__14(System.Object state){}
		private static Exception GetMustImplement(){}
		private void CheckBusy(){}
		private void SetBusy(){}
		public Byte[] DownloadData(string address){}
		public Byte[] DownloadData(Uri address){}
		private Byte[] DownloadDataCore(Uri address, System.Object userToken){}
		public void DownloadFile(string address, string fileName){}
		public void DownloadFile(Uri address, string fileName){}
		private void DownloadFileCore(Uri address, string fileName, System.Object userToken){}
		public Stream OpenRead(string address){}
		public Stream OpenRead(Uri address){}
		public Stream OpenWrite(string address){}
		public Stream OpenWrite(string address, string method){}
		public Stream OpenWrite(Uri address){}
		public Stream OpenWrite(Uri address, string method){}
		private string DetermineMethod(Uri address, string method, bool is_upload){}
		public Byte[] UploadData(string address, Byte[] data){}
		public Byte[] UploadData(string address, string method, Byte[] data){}
		public Byte[] UploadData(Uri address, Byte[] data){}
		public Byte[] UploadData(Uri address, string method, Byte[] data){}
		private Byte[] UploadDataCore(Uri address, string method, Byte[] data, System.Object userToken){}
		public Byte[] UploadFile(string address, string fileName){}
		public Byte[] UploadFile(Uri address, string fileName){}
		public Byte[] UploadFile(string address, string method, string fileName){}
		public Byte[] UploadFile(Uri address, string method, string fileName){}
		private Byte[] UploadFileCore(Uri address, string method, string fileName, System.Object userToken){}
		public Byte[] UploadValues(string address, NameValueCollection data){}
		public Byte[] UploadValues(string address, string method, NameValueCollection data){}
		public Byte[] UploadValues(Uri address, NameValueCollection data){}
		public Byte[] UploadValues(Uri address, string method, NameValueCollection data){}
		private Byte[] UploadValuesCore(Uri uri, string method, NameValueCollection data, System.Object userToken){}
		public string DownloadString(string address){}
		public string DownloadString(Uri address){}
		public string UploadString(string address, string data){}
		public string UploadString(string address, string method, string data){}
		public string UploadString(Uri address, string data){}
		public string UploadString(Uri address, string method, string data){}
		private Uri CreateUri(string address){}
		private Uri CreateUri(Uri address){}
		private string GetQueryString(bool add_qmark){}
		private Uri MakeUri(string path){}
		private WebRequest SetupRequest(Uri uri){}
		private WebRequest SetupRequest(Uri uri, string method, bool is_upload){}
		private Byte[] ReadAll(Stream stream, int length, System.Object userToken){}
		private string UrlEncode(string str){}
		private static void UrlEncodeAndWrite(Stream stream, Byte[] bytes){}
		public void CancelAsync(){}
		private void CompleteAsync(){}
		public void DownloadDataAsync(Uri address){}
		public void DownloadDataAsync(Uri address, System.Object userToken){}
		public void DownloadFileAsync(Uri address, string fileName){}
		public void DownloadFileAsync(Uri address, string fileName, System.Object userToken){}
		public void DownloadStringAsync(Uri address){}
		public void DownloadStringAsync(Uri address, System.Object userToken){}
		public void OpenReadAsync(Uri address){}
		public void OpenReadAsync(Uri address, System.Object userToken){}
		public void OpenWriteAsync(Uri address){}
		public void OpenWriteAsync(Uri address, string method){}
		public void OpenWriteAsync(Uri address, string method, System.Object userToken){}
		public void UploadDataAsync(Uri address, Byte[] data){}
		public void UploadDataAsync(Uri address, string method, Byte[] data){}
		public void UploadDataAsync(Uri address, string method, Byte[] data, System.Object userToken){}
		public void UploadFileAsync(Uri address, string fileName){}
		public void UploadFileAsync(Uri address, string method, string fileName){}
		public void UploadFileAsync(Uri address, string method, string fileName, System.Object userToken){}
		public void UploadStringAsync(Uri address, string data){}
		public void UploadStringAsync(Uri address, string method, string data){}
		public void UploadStringAsync(Uri address, string method, string data, System.Object userToken){}
		public void UploadValuesAsync(Uri address, NameValueCollection values){}
		public void UploadValuesAsync(Uri address, string method, NameValueCollection values){}
		public void UploadValuesAsync(Uri address, string method, NameValueCollection values, System.Object userToken){}
		protected virtual void OnDownloadDataCompleted(DownloadDataCompletedEventArgs args){}
		protected virtual void OnDownloadFileCompleted(AsyncCompletedEventArgs args){}
		protected virtual void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e){}
		protected virtual void OnDownloadStringCompleted(DownloadStringCompletedEventArgs args){}
		protected virtual void OnOpenReadCompleted(OpenReadCompletedEventArgs args){}
		protected virtual void OnOpenWriteCompleted(OpenWriteCompletedEventArgs args){}
		protected virtual void OnUploadDataCompleted(UploadDataCompletedEventArgs args){}
		protected virtual void OnUploadFileCompleted(UploadFileCompletedEventArgs args){}
		protected virtual void OnUploadProgressChanged(UploadProgressChangedEventArgs e){}
		protected virtual void OnUploadStringCompleted(UploadStringCompletedEventArgs args){}
		protected virtual void OnUploadValuesCompleted(UploadValuesCompletedEventArgs args){}
		protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result){}
		protected virtual WebRequest GetWebRequest(Uri address){}
		protected virtual WebResponse GetWebResponse(WebRequest request){}
		private void <DownloadDataAsync>m__C(System.Object state){}
		private void <DownloadFileAsync>m__D(System.Object state){}
		private void <DownloadStringAsync>m__E(System.Object state){}
		private void <OpenReadAsync>m__F(System.Object state){}
		private void <OpenWriteAsync>m__10(System.Object state){}
		private void <UploadDataAsync>m__11(System.Object state){}
		private void <UploadFileAsync>m__12(System.Object state){}
		private void <UploadStringAsync>m__13(System.Object state){}
		public WebClient(){}
		private static WebClient(){}
		public string BaseAddress{ get	{} set	{} }
		public RequestCachePolicy CachePolicy{ get	{} set	{} }
		public bool UseDefaultCredentials{ get	{} set	{} }
		public ICredentials Credentials{ get	{} set	{} }
		public WebHeaderCollection Headers{ get	{} set	{} }
		public NameValueCollection QueryString{ get	{} set	{} }
		public WebHeaderCollection ResponseHeaders{ get	{} }
		public Encoding Encoding{ get	{} set	{} }
		public IWebProxy Proxy{ get	{} set	{} }
		public bool IsBusy{ get	{} }
		public event	DownloadDataCompletedEventHandler DownloadDataCompleted;
		public event	AsyncCompletedEventHandler DownloadFileCompleted;
		public event	DownloadProgressChangedEventHandler DownloadProgressChanged;
		public event	DownloadStringCompletedEventHandler DownloadStringCompleted;
		public event	OpenReadCompletedEventHandler OpenReadCompleted;
		public event	OpenWriteCompletedEventHandler OpenWriteCompleted;
		public event	UploadDataCompletedEventHandler UploadDataCompleted;
		public event	UploadFileCompletedEventHandler UploadFileCompleted;
		public event	UploadProgressChangedEventHandler UploadProgressChanged;
		public event	UploadStringCompletedEventHandler UploadStringCompleted;
		public event	UploadValuesCompletedEventHandler UploadValuesCompleted;
		private ICredentials credentials;
		private WebHeaderCollection headers;
		private WebHeaderCollection responseHeaders;
		private Uri baseAddress;
		private string baseString;
		private NameValueCollection queryString;
		private bool is_busy;
		private bool async;
		private Thread async_thread;
		private Encoding encoding;
		private IWebProxy proxy;
		private readonly static string urlEncodedCType;
		private static Byte[] hexBytes;
	}

	public class	WebException: InvalidOperationException, ISerializable, _Exception
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public WebException(){}
		public WebException(string message){}
		protected WebException(SerializationInfo info, StreamingContext context){}
		public WebException(string message, Exception innerException){}
		public WebException(string message, WebExceptionStatus status){}
		internal WebException(string message, Exception innerException, WebExceptionStatus status){}
		public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response){}
		public WebResponse Response{ get	{} }
		public WebExceptionStatus Status{ get	{} }
		private WebResponse response;
		private WebExceptionStatus status;
	}

	public class	WebHeaderCollection: NameValueCollection, ICollection, IEnumerable, IDeserializationCallback, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public void Add(string header){}
		public virtual void Add(string name, string value){}
		protected void AddWithoutValidate(string headerName, string headerValue){}
		public virtual String[] GetValues(string header){}
		public virtual String[] GetValues(int index){}
		public static bool IsRestricted(string headerName){}
		public static bool IsRestricted(string headerName, bool response){}
		public virtual void OnDeserialization(System.Object sender){}
		public virtual void Remove(string name){}
		public virtual void Set(string name, string value){}
		public Byte[] ToByteArray(){}
		internal string ToStringMultiValue(){}
		public virtual string ToString(){}
		public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual string Get(int index){}
		public virtual string Get(string name){}
		public virtual string GetKey(int index){}
		public void Add(HttpRequestHeader header, string value){}
		public void Remove(HttpRequestHeader header){}
		public void Set(HttpRequestHeader header, string value){}
		public void Add(HttpResponseHeader header, string value){}
		public void Remove(HttpResponseHeader header){}
		public void Set(HttpResponseHeader header, string value){}
		private string RequestHeaderToString(HttpRequestHeader value){}
		private string ResponseHeaderToString(HttpResponseHeader value){}
		public virtual void Clear(){}
		public virtual IEnumerator GetEnumerator(){}
		internal void SetInternal(string header){}
		internal void SetInternal(string name, string value){}
		internal void RemoveAndAdd(string name, string value){}
		internal void RemoveInternal(string name){}
		internal static bool IsMultiValue(string headerName){}
		internal static bool IsHeaderValue(string value){}
		internal static bool IsHeaderName(string name){}
		public WebHeaderCollection(){}
		protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		internal WebHeaderCollection(bool internallyCreated){}
		private static WebHeaderCollection(){}
		public virtual String[] AllKeys{ get	{} }
		public virtual int Count{ get	{} }
		public virtual KeysCollection Keys{ get	{} }
		public string this[HttpRequestHeader hrh] { get	{} set	{} }
		public string this[HttpResponseHeader hrh] { get	{} set	{} }
		private bool internallyCreated;
		private readonly static Hashtable restricted;
		private readonly static Hashtable multiValue;
		private readonly static Dictionary<String, Boolean> restricted_response;
		private static Boolean[] allowed_chars;
	}

	public sealed class	WebPermission: CodeAccessPermission, IPermission, ISecurityEncodable, IStackWalk, IUnrestrictedPermission
	{
		public void AddPermission(NetworkAccess access, string uriString){}
		public void AddPermission(NetworkAccess access, Regex uriRegex){}
		internal void AddPermission(NetworkAccess access, WebPermissionInfo info){}
		public virtual IPermission Copy(){}
		public virtual IPermission Intersect(IPermission target){}
		private bool IntersectEmpty(WebPermission permission){}
		private void Intersect(ArrayList list1, ArrayList list2, ArrayList result){}
		public virtual bool IsSubsetOf(IPermission target){}
		private bool IsSubsetOf(ArrayList list1, ArrayList list2){}
		public sealed virtual bool IsUnrestricted(){}
		public virtual SecurityElement ToXml(){}
		private void ToXml(SecurityElement root, string childName, IEnumerator enumerator){}
		public virtual void FromXml(SecurityElement securityElement){}
		private void FromXml(ArrayList endpoints, NetworkAccess access){}
		public virtual IPermission Union(IPermission target){}
		public WebPermission(){}
		public WebPermission(PermissionState state){}
		public WebPermission(NetworkAccess access, string uriString){}
		public WebPermission(NetworkAccess access, Regex uriRegex){}
		public IEnumerator AcceptList{ get	{} }
		public IEnumerator ConnectList{ get	{} }
		private ArrayList m_acceptList;
		private ArrayList m_connectList;
		private bool m_noRestriction;
	}

	public sealed class	WebPermissionAttribute: CodeAccessSecurityAttribute, _Attribute
	{
		public virtual IPermission CreatePermission(){}
		internal void AlreadySet(string parameter, string property){}
		public WebPermissionAttribute(SecurityAction action){}
		public string Accept{ get	{} set	{} }
		public string AcceptPattern{ get	{} set	{} }
		public string Connect{ get	{} set	{} }
		public string ConnectPattern{ get	{} set	{} }
		private System.Object m_accept;
		private System.Object m_connect;
	}

	public class	WebProxy: Object, ISerializable, IWebProxy
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public static WebProxy GetDefaultProxy(){}
		public sealed virtual Uri GetProxy(Uri destination){}
		public sealed virtual bool IsBypassed(Uri host){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private void CheckBypassList(){}
		private static Uri ToUri(string address){}
		public WebProxy(){}
		public WebProxy(string address){}
		public WebProxy(Uri address){}
		public WebProxy(string address, bool bypassOnLocal){}
		public WebProxy(string host, int port){}
		public WebProxy(Uri address, bool bypassOnLocal){}
		public WebProxy(string address, bool bypassOnLocal, String[] bypassList){}
		public WebProxy(Uri address, bool bypassOnLocal, String[] bypassList){}
		public WebProxy(string address, bool bypassOnLocal, String[] bypassList, ICredentials credentials){}
		public WebProxy(Uri address, bool bypassOnLocal, String[] bypassList, ICredentials credentials){}
		protected WebProxy(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public Uri Address{ get	{} set	{} }
		public ArrayList BypassArrayList{ get	{} }
		public String[] BypassList{ get	{} set	{} }
		public bool BypassProxyOnLocal{ get	{} set	{} }
		public sealed virtual ICredentials Credentials{ get	{} set	{} }
		public bool UseDefaultCredentials{ get	{} set	{} }
		private Uri address;
		private bool bypassOnLocal;
		private ArrayList bypassList;
		private ICredentials credentials;
		private bool useDefaultCredentials;
	}

	public abstract	class	WebRequest: MarshalByRefObject, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static void AddDynamicPrefix(string protocol, string implementor){}
		private static Exception GetMustImplement(){}
		private static IWebProxy GetDefaultWebProxy(){}
		public virtual void Abort(){}
		public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, System.Object state){}
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, System.Object state){}
		public static WebRequest Create(string requestUriString){}
		public static WebRequest Create(Uri requestUri){}
		public static WebRequest CreateDefault(Uri requestUri){}
		public virtual Stream EndGetRequestStream(IAsyncResult asyncResult){}
		public virtual WebResponse EndGetResponse(IAsyncResult asyncResult){}
		public virtual Stream GetRequestStream(){}
		public virtual WebResponse GetResponse(){}
		public static IWebProxy GetSystemWebProxy(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public static bool RegisterPrefix(string prefix, IWebRequestCreate creator){}
		private static IWebRequestCreate GetCreator(string prefix){}
		internal static void ClearPrefixes(){}
		internal static void RemovePrefix(string prefix){}
		internal static void AddPrefix(string prefix, string typeName){}
		internal static void AddPrefix(string prefix, Type type){}
		protected WebRequest(){}
		protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static WebRequest(){}
		public AuthenticationLevel AuthenticationLevel{ get	{} set	{} }
		public virtual RequestCachePolicy CachePolicy{ get	{} set	{} }
		public virtual string ConnectionGroupName{ get	{} set	{} }
		public virtual long ContentLength{ get	{} set	{} }
		public virtual string ContentType{ get	{} set	{} }
		public virtual ICredentials Credentials{ get	{} set	{} }
		public static RequestCachePolicy DefaultCachePolicy{ get	{} set	{} }
		public virtual WebHeaderCollection Headers{ get	{} set	{} }
		public TokenImpersonationLevel ImpersonationLevel{ get	{} set	{} }
		public virtual string Method{ get	{} set	{} }
		public virtual bool PreAuthenticate{ get	{} set	{} }
		public virtual IWebProxy Proxy{ get	{} set	{} }
		public virtual Uri RequestUri{ get	{} }
		public virtual int Timeout{ get	{} set	{} }
		public virtual bool UseDefaultCredentials{ get	{} set	{} }
		public static IWebProxy DefaultWebProxy{ get	{} set	{} }
		private AuthenticationLevel authentication_level;
		private static HybridDictionary prefixes;
		private static bool isDefaultWebProxySet;
		private static IWebProxy defaultWebProxy;
		private readonly static System.Object lockobj;
	}

	public sealed abstract	class	WebRequestMethods: Object
	{
	}

	public abstract	class	WebResponse: MarshalByRefObject, IDisposable, ISerializable
	{
		private sealed virtual void System.IDisposable.Dispose(){}
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		private static Exception GetMustImplement(){}
		public virtual void Close(){}
		public virtual Stream GetResponseStream(){}
		protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		protected WebResponse(){}
		protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext){}
		public virtual long ContentLength{ get	{} set	{} }
		public virtual string ContentType{ get	{} set	{} }
		public virtual WebHeaderCollection Headers{ get	{} }
		public virtual bool IsFromCache{ get	{} }
		public virtual bool IsMutuallyAuthenticated{ get	{} }
		public virtual Uri ResponseUri{ get	{} }
	}

	delegate IPHostEntry GetHostByNameCallback(string hostName);

	delegate IPHostEntry ResolveCallback(string hostName);

	delegate IPHostEntry GetHostEntryNameCallback(string hostName);

	delegate IPHostEntry GetHostEntryIPCallback(IPAddress hostAddress);

	delegate IPAddress[] GetHostAddressesCallback(string hostName);

	delegate Stream GetRequestStreamCallback();

	delegate WebResponse GetResponseCallback();

	delegate void WriteDelegate(Byte[] buffer, int offset, int size);

	delegate int ReadDelegate(Byte[] buffer, int offset, int size);

	delegate AuthenticationSchemes AuthenticationSchemeSelector(HttpListenerRequest httpRequest);

	delegate IPEndPoint BindIPEndPoint(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount);

	delegate void DownloadDataCompletedEventHandler(System.Object sender, DownloadDataCompletedEventArgs e);

	delegate void DownloadProgressChangedEventHandler(System.Object sender, DownloadProgressChangedEventArgs e);

	delegate void DownloadStringCompletedEventHandler(System.Object sender, DownloadStringCompletedEventArgs e);

	delegate void HttpContinueDelegate(int StatusCode, WebHeaderCollection httpHeaders);

	delegate void OpenReadCompletedEventHandler(System.Object sender, OpenReadCompletedEventArgs e);

	delegate void OpenWriteCompletedEventHandler(System.Object sender, OpenWriteCompletedEventArgs e);

	delegate void UploadDataCompletedEventHandler(System.Object sender, UploadDataCompletedEventArgs e);

	delegate void UploadFileCompletedEventHandler(System.Object sender, UploadFileCompletedEventArgs e);

	delegate void UploadProgressChangedEventHandler(System.Object sender, UploadProgressChangedEventArgs e);

	delegate void UploadStringCompletedEventHandler(System.Object sender, UploadStringCompletedEventArgs e);

	delegate void UploadValuesCompletedEventHandler(System.Object sender, UploadValuesCompletedEventArgs e);

}

namespace System.Security.AccessControl {
	public sealed class	SemaphoreAccessRule: AccessRule
	{
		public SemaphoreAccessRule(IdentityReference identity, SemaphoreRights semaphoreRights, AccessControlType type){}
		public SemaphoreAccessRule(string identity, SemaphoreRights semaphoreRights, AccessControlType type){}
		public SemaphoreRights SemaphoreRights{ get	{} }
		private SemaphoreRights semaphoreRights;
	}

	public sealed class	SemaphoreAuditRule: AuditRule
	{
		public SemaphoreAuditRule(IdentityReference identity, SemaphoreRights semaphoreRights, AuditFlags flags){}
		public SemaphoreRights SemaphoreRights{ get	{} }
		private SemaphoreRights semaphoreRights;
	}

	public sealed class	SemaphoreSecurity: NativeObjectSecurity
	{
		public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type){}
		public void AddAccessRule(SemaphoreAccessRule rule){}
		public void AddAuditRule(SemaphoreAuditRule rule){}
		public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags){}
		public bool RemoveAccessRule(SemaphoreAccessRule rule){}
		public void RemoveAccessRuleAll(SemaphoreAccessRule rule){}
		public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule){}
		public bool RemoveAuditRule(SemaphoreAuditRule rule){}
		public void RemoveAuditRuleAll(SemaphoreAuditRule rule){}
		public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule){}
		public void ResetAccessRule(SemaphoreAccessRule rule){}
		public void SetAccessRule(SemaphoreAccessRule rule){}
		public void SetAuditRule(SemaphoreAuditRule rule){}
		public SemaphoreSecurity(){}
		public SemaphoreSecurity(string name, AccessControlSections includesections){}
		public virtual Type AccessRightType{ get	{} }
		public virtual Type AccessRuleType{ get	{} }
		public virtual Type AuditRuleType{ get	{} }
	}

}

namespace System.Security.Authentication {
	public class	AuthenticationException: SystemException, ISerializable, _Exception
	{
		public AuthenticationException(){}
		public AuthenticationException(string message){}
		public AuthenticationException(string message, Exception innerException){}
		protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext){}
	}

	public class	InvalidCredentialException: AuthenticationException, ISerializable, _Exception
	{
		public InvalidCredentialException(){}
		public InvalidCredentialException(string message){}
		public InvalidCredentialException(string message, Exception innerException){}
		protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext){}
	}

}

namespace System.Security.Cryptography.X509Certificates {
	public sealed class	PublicKey: Object
	{
		private static Byte[] GetUnsignedBigInteger(Byte[] integer){}
		internal static DSA DecodeDSA(Byte[] rawPublicKey, Byte[] rawParameters){}
		internal static RSA DecodeRSA(Byte[] rawPublicKey){}
		public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue){}
		internal PublicKey(X509Certificate certificate){}
		public AsnEncodedData EncodedKeyValue{ get	{} }
		public AsnEncodedData EncodedParameters{ get	{} }
		public AsymmetricAlgorithm Key{ get	{} }
		public Oid Oid{ get	{} }
		private AsymmetricAlgorithm _key;
		private AsnEncodedData _keyValue;
		private AsnEncodedData _params;
		private Oid _oid;
		private static Dictionary<String, Int32> <>f__switch$map9;
		private const string rsaOid = null;
		private const string dsaOid = null;
	}

	public sealed class	X500DistinguishedName: AsnEncodedData
	{
		public string Decode(X500DistinguishedNameFlags flag){}
		public virtual string Format(bool multiLine){}
		private static string GetSeparator(X500DistinguishedNameFlags flag){}
		private void DecodeRawData(){}
		private static string Canonize(string s){}
		internal static bool AreEqual(X500DistinguishedName name1, X500DistinguishedName name2){}
		public X500DistinguishedName(AsnEncodedData encodedDistinguishedName){}
		public X500DistinguishedName(Byte[] encodedDistinguishedName){}
		public X500DistinguishedName(string distinguishedName){}
		public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag){}
		public X500DistinguishedName(X500DistinguishedName distinguishedName){}
		public string Name{ get	{} }
		private string name;
		private const X500DistinguishedNameFlags AllFlags = null;
	}

	public sealed class	X509BasicConstraintsExtension: X509Extension
	{
		public virtual void CopyFrom(AsnEncodedData asnEncodedData){}
		internal AsnDecodeStatus Decode(Byte[] extension){}
		internal Byte[] Encode(){}
		internal virtual string ToString(bool multiLine){}
		public X509BasicConstraintsExtension(){}
		public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical){}
		public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical){}
		public bool CertificateAuthority{ get	{} }
		public bool HasPathLengthConstraint{ get	{} }
		public int PathLengthConstraint{ get	{} }
		private bool _certificateAuthority;
		private bool _hasPathLengthConstraint;
		private int _pathLengthConstraint;
		private AsnDecodeStatus _status;
		internal const string oid = null;
		internal const string friendlyName = null;
	}

	public class	X509Certificate2: X509Certificate, IDeserializationCallback, ISerializable
	{
		public string GetNameInfo(X509NameType nameType, bool forIssuer){}
		private ASN1 Find(Byte[] oid, ASN1 dn){}
		private string GetValueAsString(ASN1 pair){}
		private void ImportPkcs12(Byte[] rawData, string password){}
		public virtual void Import(Byte[] rawData){}
		public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags){}
		public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags){}
		public virtual void Import(string fileName){}
		public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags){}
		public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags){}
		private static Byte[] Load(string fileName){}
		public virtual void Reset(){}
		public virtual string ToString(){}
		public virtual string ToString(bool verbose){}
		private static void AppendBuffer(StringBuilder sb, Byte[] buffer){}
		public bool Verify(){}
		public static X509ContentType GetCertContentType(Byte[] rawData){}
		public static X509ContentType GetCertContentType(string fileName){}
		public X509Certificate2(){}
		public X509Certificate2(Byte[] rawData){}
		public X509Certificate2(Byte[] rawData, string password){}
		public X509Certificate2(Byte[] rawData, SecureString password){}
		public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags){}
		public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags){}
		public X509Certificate2(string fileName){}
		public X509Certificate2(string fileName, string password){}
		public X509Certificate2(string fileName, SecureString password){}
		public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags){}
		public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags){}
		public X509Certificate2(IntPtr handle){}
		public X509Certificate2(X509Certificate certificate){}
		private static X509Certificate2(){}
		public bool Archived{ get	{} set	{} }
		public X509ExtensionCollection Extensions{ get	{} }
		public string FriendlyName{ get	{} set	{} }
		public bool HasPrivateKey{ get	{} }
		public X500DistinguishedName IssuerName{ get	{} }
		public DateTime NotAfter{ get	{} }
		public DateTime NotBefore{ get	{} }
		public AsymmetricAlgorithm PrivateKey{ get	{} set	{} }
		public PublicKey PublicKey{ get	{} }
		public Byte[] RawData{ get	{} }
		public string SerialNumber{ get	{} }
		public Oid SignatureAlgorithm{ get	{} }
		public X500DistinguishedName SubjectName{ get	{} }
		public string Thumbprint{ get	{} }
		public int Version{ get	{} }
		X509Certificate MonoCertificate{ get	{} }
		private bool _archived;
		private X509ExtensionCollection _extensions;
		private string _name;
		private string _serial;
		private PublicKey _publicKey;
		private X500DistinguishedName issuer_name;
		private X500DistinguishedName subject_name;
		private Oid signature_algorithm;
		private X509Certificate _cert;
		private static string empty_error;
		private static Byte[] commonName;
		private static Byte[] email;
		private static Byte[] signedData;
	}

	public class	X509Certificate2Collection: X509CertificateCollection, IList, ICollection, IEnumerable
	{
		public int Add(X509Certificate2 certificate){}
		public void AddRange(X509Certificate2[] certificates){}
		public void AddRange(X509Certificate2Collection certificates){}
		public bool Contains(X509Certificate2 certificate){}
		public Byte[] Export(X509ContentType contentType){}
		public Byte[] Export(X509ContentType contentType, string password){}
		public X509Certificate2Collection Find(X509FindType findType, System.Object findValue, bool validOnly){}
		public X509Certificate2Enumerator GetEnumerator(){}
		public void Import(Byte[] rawData){}
		public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags){}
		public void Import(string fileName){}
		public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags){}
		public void Insert(int index, X509Certificate2 certificate){}
		public void Remove(X509Certificate2 certificate){}
		public void RemoveRange(X509Certificate2[] certificates){}
		public void RemoveRange(X509Certificate2Collection certificates){}
		public X509Certificate2Collection(){}
		public X509Certificate2Collection(X509Certificate2Collection certificates){}
		public X509Certificate2Collection(X509Certificate2 certificate){}
		public X509Certificate2Collection(X509Certificate2[] certificates){}
		public X509Certificate2 this[int index] { get	{} set	{} }
	}

	public sealed class	X509Certificate2Enumerator: Object, IEnumerator
	{
		private sealed virtual System.Object System.Collections.IEnumerator.get_Current(){}
		private sealed virtual bool System.Collections.IEnumerator.MoveNext(){}
		private sealed virtual void System.Collections.IEnumerator.Reset(){}
		public sealed virtual bool MoveNext(){}
		public sealed virtual void Reset(){}
		internal X509Certificate2Enumerator(X509Certificate2Collection collection){}
		System.Object System.Collections.IEnumerator.Current{ get	{} }
		public X509Certificate2 Current{ get	{} }
		private IEnumerator enumerator;
	}

	public class	X509CertificateCollection: CollectionBase, IList, ICollection, IEnumerable
	{
		public int Add(X509Certificate value){}
		public void AddRange(X509Certificate[] value){}
		public void AddRange(X509CertificateCollection value){}
		public bool Contains(X509Certificate value){}
		public void CopyTo(X509Certificate[] array, int index){}
		public X509CertificateEnumerator GetEnumerator(){}
		public virtual int GetHashCode(){}
		public int IndexOf(X509Certificate value){}
		public void Insert(int index, X509Certificate value){}
		public void Remove(X509Certificate value){}
		private bool Compare(Byte[] array1, Byte[] array2){}
		public X509CertificateCollection(){}
		public X509CertificateCollection(X509Certificate[] value){}
		public X509CertificateCollection(X509CertificateCollection value){}
		public X509Certificate this[int index] { get	{} set	{} }
	}

	public class	X509Chain: Object
	{
		public bool Build(X509Certificate2 certificate){}
		public void Reset(){}
		public static X509Chain Create(){}
		private X509ChainStatusFlags BuildChainFrom(X509Certificate2 certificate){}
		private X509Certificate2 SelectBestFromCollection(X509Certificate2 child, X509Certificate2Collection c){}
		private X509Certificate2 FindParent(X509Certificate2 certificate){}
		private bool IsChainComplete(X509Certificate2 certificate){}
		private bool IsSelfIssued(X509Certificate2 certificate){}
		private void ValidateChain(X509ChainStatusFlags flag){}
		private void Process(int n){}
		private void PrepareForNextCertificate(int n){}
		private void WrapUp(){}
		private void ProcessCertificateExtensions(X509ChainElement element){}
		private bool IsSignedWith(X509Certificate2 signed, AsymmetricAlgorithm pubkey){}
		private string GetSubjectKeyIdentifier(X509Certificate2 certificate){}
		private string GetAuthorityKeyIdentifier(X509Certificate2 certificate){}
		private string GetAuthorityKeyIdentifier(X509Crl crl){}
		private string GetAuthorityKeyIdentifier(X509Extension ext){}
		private void CheckRevocationOnChain(X509ChainStatusFlags flag){}
		private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, int ca, bool online){}
		private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, X509Certificate2 ca_cert, bool online){}
		private X509Crl FindCrl(X509Certificate2 caCertificate){}
		private bool ProcessCrlExtensions(X509Crl crl){}
		private bool ProcessCrlEntryExtensions(X509CrlEntry entry){}
		public X509Chain(){}
		public X509Chain(bool useMachineContext){}
		public X509Chain(IntPtr chainContext){}
		private static X509Chain(){}
		public IntPtr ChainContext{ get	{} }
		public X509ChainElementCollection ChainElements{ get	{} }
		public X509ChainPolicy ChainPolicy{ get	{} set	{} }
		public X509ChainStatus[] ChainStatus{ get	{} }
		X509Store Roots{ get	{} }
		X509Store CertificateAuthorities{ get	{} }
		X509Certificate2Collection CertificateCollection{ get	{} }
		private StoreLocation location;
		private X509ChainElementCollection elements;
		private X509ChainPolicy policy;
		private X509ChainStatus[] status;
		private int max_path_length;
		private X500DistinguishedName working_issuer_name;
		private AsymmetricAlgorithm working_public_key;
		private X509ChainElement bce_restriction;
		private X509Store roots;
		private X509Store cas;
		private X509Certificate2Collection collection;
		private static X509ChainStatus[] Empty;
		private static Dictionary<String, Int32> <>f__switch$mapB;
		private static Dictionary<String, Int32> <>f__switch$mapC;
		private static Dictionary<String, Int32> <>f__switch$mapD;
	}

	public class	X509ChainElement: Object
	{
		private int Count(X509ChainStatusFlags flags){}
		private void Set(X509ChainStatus[] status, ref int position, X509ChainStatusFlags flags, X509ChainStatusFlags mask){}
		internal void UncompressFlags(){}
		internal X509ChainElement(X509Certificate2 certificate){}
		public X509Certificate2 Certificate{ get	{} }
		public X509ChainStatus[] ChainElementStatus{ get	{} }
		public string Information{ get	{} }
		X509ChainStatusFlags StatusFlags{ get	{} set	{} }
		private X509Certificate2 certificate;
		private X509ChainStatus[] status;
		private string info;
		private X509ChainStatusFlags compressed_status_flags;
	}

	public sealed class	X509ChainElementCollection: Object, ICollection, IEnumerable
	{
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public void CopyTo(X509ChainElement[] array, int index){}
		public X509ChainElementEnumerator GetEnumerator(){}
		internal void Add(X509Certificate2 certificate){}
		internal void Clear(){}
		internal bool Contains(X509Certificate2 certificate){}
		internal X509ChainElementCollection(){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public X509ChainElement this[int index] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		private ArrayList _list;
	}

	public sealed class	X509ChainElementEnumerator: Object, IEnumerator
	{
		private sealed virtual System.Object System.Collections.IEnumerator.get_Current(){}
		public sealed virtual bool MoveNext(){}
		public sealed virtual void Reset(){}
		internal X509ChainElementEnumerator(IEnumerable enumerable){}
		System.Object System.Collections.IEnumerator.Current{ get	{} }
		public X509ChainElement Current{ get	{} }
		private IEnumerator enumerator;
	}

	public sealed class	X509ChainPolicy: Object
	{
		public void Reset(){}
		public X509ChainPolicy(){}
		public OidCollection ApplicationPolicy{ get	{} }
		public OidCollection CertificatePolicy{ get	{} }
		public X509Certificate2Collection ExtraStore{ get	{} }
		public X509RevocationFlag RevocationFlag{ get	{} set	{} }
		public X509RevocationMode RevocationMode{ get	{} set	{} }
		public TimeSpan UrlRetrievalTimeout{ get	{} set	{} }
		public X509VerificationFlags VerificationFlags{ get	{} set	{} }
		public DateTime VerificationTime{ get	{} set	{} }
		private OidCollection apps;
		private OidCollection cert;
		private X509Certificate2Collection store;
		private X509RevocationFlag rflag;
		private X509RevocationMode mode;
		private TimeSpan timeout;
		private X509VerificationFlags vflags;
		private DateTime vtime;
	}

	public sealed class	X509EnhancedKeyUsageExtension: X509Extension
	{
		public virtual void CopyFrom(AsnEncodedData asnEncodedData){}
		internal AsnDecodeStatus Decode(Byte[] extension){}
		internal Byte[] Encode(){}
		internal virtual string ToString(bool multiLine){}
		public X509EnhancedKeyUsageExtension(){}
		public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical){}
		public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical){}
		public OidCollection EnhancedKeyUsages{ get	{} }
		private OidCollection _enhKeyUsage;
		private AsnDecodeStatus _status;
		private static Dictionary<String, Int32> <>f__switch$mapE;
		internal const string oid = null;
		internal const string friendlyName = null;
	}

	public class	X509Extension: AsnEncodedData
	{
		public virtual void CopyFrom(AsnEncodedData asnEncodedData){}
		internal string FormatUnkownData(Byte[] data){}
		protected X509Extension(){}
		public X509Extension(AsnEncodedData encodedExtension, bool critical){}
		public X509Extension(Oid oid, Byte[] rawData, bool critical){}
		public X509Extension(string oid, Byte[] rawData, bool critical){}
		public bool Critical{ get	{} set	{} }
		private bool _critical;
	}

	public sealed class	X509ExtensionCollection: Object, ICollection, IEnumerable
	{
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public int Add(X509Extension extension){}
		public void CopyTo(X509Extension[] array, int index){}
		public X509ExtensionEnumerator GetEnumerator(){}
		public X509ExtensionCollection(){}
		internal X509ExtensionCollection(X509Certificate cert){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		public X509Extension this[int index] { get	{} }
		public X509Extension this[string oid] { get	{} }
		private ArrayList _list;
	}

	public sealed class	X509ExtensionEnumerator: Object, IEnumerator
	{
		private sealed virtual System.Object System.Collections.IEnumerator.get_Current(){}
		public sealed virtual bool MoveNext(){}
		public sealed virtual void Reset(){}
		internal X509ExtensionEnumerator(ArrayList list){}
		System.Object System.Collections.IEnumerator.Current{ get	{} }
		public X509Extension Current{ get	{} }
		private IEnumerator enumerator;
	}

	public sealed class	X509KeyUsageExtension: X509Extension
	{
		public virtual void CopyFrom(AsnEncodedData encodedData){}
		internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags){}
		internal AsnDecodeStatus Decode(Byte[] extension){}
		internal Byte[] Encode(){}
		internal virtual string ToString(bool multiLine){}
		public X509KeyUsageExtension(){}
		public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical){}
		public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical){}
		public X509KeyUsageFlags KeyUsages{ get	{} }
		private X509KeyUsageFlags _keyUsages;
		private AsnDecodeStatus _status;
		internal const string oid = null;
		internal const string friendlyName = null;
		internal const X509KeyUsageFlags all = null;
	}

	public sealed class	X509Store: Object
	{
		public void Add(X509Certificate2 certificate){}
		public void AddRange(X509Certificate2Collection certificates){}
		public void Close(){}
		public void Open(OpenFlags flags){}
		public void Remove(X509Certificate2 certificate){}
		public void RemoveRange(X509Certificate2Collection certificates){}
		private bool Exists(X509Certificate2 certificate){}
		public X509Store(){}
		public X509Store(string storeName){}
		public X509Store(StoreName storeName){}
		public X509Store(StoreLocation storeLocation){}
		public X509Store(StoreName storeName, StoreLocation storeLocation){}
		public X509Store(IntPtr storeHandle){}
		public X509Store(string storeName, StoreLocation storeLocation){}
		public X509Certificate2Collection Certificates{ get	{} }
		public StoreLocation Location{ get	{} }
		public string Name{ get	{} }
		X509Stores Factory{ get	{} }
		bool IsOpen{ get	{} }
		bool IsReadOnly{ get	{} }
		X509Store Store{ get	{} }
		public IntPtr StoreHandle{ get	{} }
		private string _name;
		private StoreLocation _location;
		private X509Certificate2Collection list;
		private OpenFlags _flags;
		private X509Store store;
		private static Dictionary<String, Int32> <>f__switch$mapF;
	}

	public sealed class	X509SubjectKeyIdentifierExtension: X509Extension
	{
		public virtual void CopyFrom(AsnEncodedData encodedData){}
		internal static byte FromHexChar(char c){}
		internal static byte FromHexChars(char c1, char c2){}
		internal static Byte[] FromHex(string hex){}
		internal AsnDecodeStatus Decode(Byte[] extension){}
		internal Byte[] Encode(){}
		internal virtual string ToString(bool multiLine){}
		public X509SubjectKeyIdentifierExtension(){}
		public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical){}
		public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical){}
		public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical){}
		public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical){}
		public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical){}
		public string SubjectKeyIdentifier{ get	{} }
		private Byte[] _subjectKeyIdentifier;
		private string _ski;
		private AsnDecodeStatus _status;
		internal const string oid = null;
		internal const string friendlyName = null;
	}

}

namespace System.Security.Cryptography {
	public class	AsnEncodedData: Object
	{
		public virtual void CopyFrom(AsnEncodedData asnEncodedData){}
		public virtual string Format(bool multiLine){}
		internal virtual string ToString(bool multiLine){}
		internal string Default(bool multiLine){}
		internal string BasicConstraintsExtension(bool multiLine){}
		internal string EnhancedKeyUsageExtension(bool multiLine){}
		internal string KeyUsageExtension(bool multiLine){}
		internal string SubjectKeyIdentifierExtension(bool multiLine){}
		internal string SubjectAltName(bool multiLine){}
		internal string NetscapeCertType(bool multiLine){}
		protected AsnEncodedData(){}
		public AsnEncodedData(string oid, Byte[] rawData){}
		public AsnEncodedData(Oid oid, Byte[] rawData){}
		public AsnEncodedData(AsnEncodedData asnEncodedData){}
		public AsnEncodedData(Byte[] rawData){}
		public Oid Oid{ get	{} set	{} }
		public Byte[] RawData{ get	{} set	{} }
		internal Oid _oid;
		internal Byte[] _raw;
		private static Dictionary<String, Int32> <>f__switch$mapA;
	}

	public sealed class	AsnEncodedDataCollection: Object, ICollection, IEnumerable
	{
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public int Add(AsnEncodedData asnEncodedData){}
		public void CopyTo(AsnEncodedData[] array, int index){}
		public AsnEncodedDataEnumerator GetEnumerator(){}
		public void Remove(AsnEncodedData asnEncodedData){}
		public AsnEncodedDataCollection(){}
		public AsnEncodedDataCollection(AsnEncodedData asnEncodedData){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public AsnEncodedData this[int index] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		private ArrayList _list;
	}

	public sealed class	AsnEncodedDataEnumerator: Object, IEnumerator
	{
		private sealed virtual System.Object System.Collections.IEnumerator.get_Current(){}
		public sealed virtual bool MoveNext(){}
		public sealed virtual void Reset(){}
		internal AsnEncodedDataEnumerator(AsnEncodedDataCollection collection){}
		System.Object System.Collections.IEnumerator.Current{ get	{} }
		public AsnEncodedData Current{ get	{} }
		private AsnEncodedDataCollection _collection;
		private int _position;
	}

	public sealed class	Oid: Object
	{
		private string GetName(string oid){}
		private string GetValue(string name){}
		public Oid(){}
		public Oid(string oid){}
		public Oid(string value, string friendlyName){}
		public Oid(Oid oid){}
		public string FriendlyName{ get	{} set	{} }
		public string Value{ get	{} set	{} }
		private string _value;
		private string _name;
		private static Dictionary<String, Int32> <>f__switch$map10;
		private static Dictionary<String, Int32> <>f__switch$map11;
		internal const string oidRSA = null;
		internal const string nameRSA = null;
		internal const string oidPkcs7Data = null;
		internal const string namePkcs7Data = null;
		internal const string oidPkcs9ContentType = null;
		internal const string namePkcs9ContentType = null;
		internal const string oidPkcs9MessageDigest = null;
		internal const string namePkcs9MessageDigest = null;
		internal const string oidPkcs9SigningTime = null;
		internal const string namePkcs9SigningTime = null;
		internal const string oidMd5 = null;
		internal const string nameMd5 = null;
		internal const string oid3Des = null;
		internal const string name3Des = null;
		internal const string oidSha1 = null;
		internal const string nameSha1 = null;
		internal const string oidSubjectAltName = null;
		internal const string nameSubjectAltName = null;
		internal const string oidNetscapeCertType = null;
		internal const string nameNetscapeCertType = null;
	}

	public sealed class	OidCollection: Object, ICollection, IEnumerable
	{
		private sealed virtual void System.Collections.ICollection.CopyTo(Array array, int index){}
		private sealed virtual IEnumerator System.Collections.IEnumerable.GetEnumerator(){}
		public int Add(Oid oid){}
		public void CopyTo(Oid[] array, int index){}
		public OidEnumerator GetEnumerator(){}
		internal OidCollection ReadOnlyCopy(){}
		public OidCollection(){}
		public sealed virtual int Count{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public Oid this[int index] { get	{} }
		public Oid this[string oid] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		bool ReadOnly{ get	{} set	{} }
		private ArrayList _list;
		private bool _readOnly;
	}

	public sealed class	OidEnumerator: Object, IEnumerator
	{
		private sealed virtual System.Object System.Collections.IEnumerator.get_Current(){}
		public sealed virtual bool MoveNext(){}
		public sealed virtual void Reset(){}
		internal OidEnumerator(OidCollection collection){}
		System.Object System.Collections.IEnumerator.Current{ get	{} }
		public Oid Current{ get	{} }
		private OidCollection _collection;
		private int _position;
	}

}

namespace System.Text.RegularExpressions {
	public class	Capture: Object
	{
		public virtual string ToString(){}
		internal Capture(string text){}
		internal Capture(string text, int index, int length){}
		public int Index{ get	{} }
		public int Length{ get	{} }
		public string Value{ get	{} }
		string Text{ get	{} }
		internal int index;
		internal int length;
		internal string text;
	}

	public class	CaptureCollection: Object, ICollection, IEnumerable
	{
		internal void SetValue(Capture cap, int i){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		internal CaptureCollection(int n){}
		public sealed virtual int Count{ get	{} }
		public bool IsReadOnly{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public Capture this[int i] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		private Capture[] list;
	}

	public class	Group: Capture
	{
		public static Group Synchronized(Group inner){}
		internal Group(string text, int index, int length, int n_caps){}
		internal Group(string text, int index, int length){}
		internal Group(){}
		private static Group(){}
		public CaptureCollection Captures{ get	{} }
		public bool Success{ get	{} }
		private bool success;
		private CaptureCollection captures;
		internal static Group Fail;
	}

	public class	GroupCollection: Object, ICollection, IEnumerable
	{
		internal void SetValue(Group g, int i){}
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		internal GroupCollection(int n, int gap){}
		public sealed virtual int Count{ get	{} }
		public bool IsReadOnly{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public Group this[int i] { get	{} }
		public Group this[string groupName] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		private Group[] list;
		private int gap;
	}

	public class	Match: Group
	{
		public static Match Synchronized(Match inner){}
		public Match NextMatch(){}
		public virtual string Result(string replacement){}
		private Match(){}
		internal Match(Regex regex, IMachine machine, string text, int text_length, int n_groups, int index, int length){}
		internal Match(Regex regex, IMachine machine, string text, int text_length, int n_groups, int index, int length, int n_caps){}
		private static Match(){}
		public static Match Empty{ get	{} }
		public virtual GroupCollection Groups{ get	{} }
		Regex Regex{ get	{} }
		private Regex regex;
		private IMachine machine;
		private int text_length;
		private GroupCollection groups;
		private static Match empty;
	}

	public class	MatchCollection: Object, ICollection, IEnumerable
	{
		public sealed virtual void CopyTo(Array array, int index){}
		public sealed virtual IEnumerator GetEnumerator(){}
		private bool TryToGet(int i){}
		internal MatchCollection(Match start){}
		public sealed virtual int Count{ get	{} }
		public bool IsReadOnly{ get	{} }
		public sealed virtual bool IsSynchronized{ get	{} }
		public virtual Match this[int i] { get	{} }
		public sealed virtual System.Object SyncRoot{ get	{} }
		ICollection FullList{ get	{} }
		private Match current;
		private ArrayList list;
	}

	public class	Regex: Object, ISerializable
	{
		private sealed virtual void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context){}
		public static void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname){}
		public static void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname, CustomAttributeBuilder[] attribs){}
		public static void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname, CustomAttributeBuilder[] attribs, string resourceFile){}
		public static string Escape(string str){}
		public static string Unescape(string str){}
		public static bool IsMatch(string input, string pattern){}
		public static bool IsMatch(string input, string pattern, RegexOptions options){}
		public static Match Match(string input, string pattern){}
		public static Match Match(string input, string pattern, RegexOptions options){}
		public static MatchCollection Matches(string input, string pattern){}
		public static MatchCollection Matches(string input, string pattern, RegexOptions options){}
		public static string Replace(string input, string pattern, MatchEvaluator evaluator){}
		public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options){}
		public static string Replace(string input, string pattern, string replacement){}
		public static string Replace(string input, string pattern, string replacement, RegexOptions options){}
		public static String[] Split(string input, string pattern){}
		public static String[] Split(string input, string pattern, RegexOptions options){}
		private static void validate_options(RegexOptions options){}
		private void Init(){}
		private void InitNewRegex(){}
		private static IMachineFactory CreateMachineFactory(string pattern, RegexOptions options){}
		public String[] GetGroupNames(){}
		public Int32[] GetGroupNumbers(){}
		public string GroupNameFromNumber(int i){}
		public int GroupNumberFromName(string name){}
		internal int GetGroupIndex(int number){}
		private int default_startat(string input){}
		public bool IsMatch(string input){}
		public bool IsMatch(string input, int startat){}
		public Match Match(string input){}
		public Match Match(string input, int startat){}
		public Match Match(string input, int startat, int length){}
		public MatchCollection Matches(string input){}
		public MatchCollection Matches(string input, int startat){}
		public string Replace(string input, MatchEvaluator evaluator){}
		public string Replace(string input, MatchEvaluator evaluator, int count){}
		public string Replace(string input, MatchEvaluator evaluator, int count, int startat){}
		public string Replace(string input, string replacement){}
		public string Replace(string input, string replacement, int count){}
		public string Replace(string input, string replacement, int count, int startat){}
		public String[] Split(string input){}
		public String[] Split(string input, int count){}
		public String[] Split(string input, int count, int startat){}
		protected void InitializeReferences(){}
		protected bool UseOptionR(){}
		public virtual string ToString(){}
		private IMachine CreateMachine(){}
		private static String[] GetGroupNamesArray(int groupCount, IDictionary mapping){}
		protected Regex(){}
		public Regex(string pattern){}
		public Regex(string pattern, RegexOptions options){}
		protected Regex(SerializationInfo info, StreamingContext context){}
		private static Regex(){}
		public static int CacheSize{ get	{} set	{} }
		public RegexOptions Options{ get	{} }
		public bool RightToLeft{ get	{} }
		int GroupCount{ get	{} }
		int Gap{ get	{} }
		Int32[] GroupNumbers{ get	{} }
		private IMachineFactory machineFactory;
		private IDictionary mapping;
		private int group_count;
		private int gap;
		private bool refsInitialized;
		private String[] group_names;
		private Int32[] group_numbers;
		protected string pattern;
		protected RegexOptions roptions;
		internal Dictionary<String, Int32> capnames;
		internal Dictionary<Int32, Int32> caps;
		protected int capsize;
		protected String[] capslist;
		private static FactoryCache cache;
	}

	public class	RegexCompilationInfo: Object
	{
		public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic){}
		public bool IsPublic{ get	{} set	{} }
		public string Name{ get	{} set	{} }
		public string Namespace{ get	{} set	{} }
		public RegexOptions Options{ get	{} set	{} }
		public string Pattern{ get	{} set	{} }
		private string pattern;
		private string name;
		private string nspace;
		private RegexOptions options;
		private bool isPublic;
	}

	delegate void MatchAppendEvaluator(Match match, StringBuilder sb);

	delegate double CostDelegate(Interval i);

	delegate string MatchEvaluator(Match match);

}

namespace System.Threading {
	public sealed class	Semaphore: WaitHandle, IDisposable
	{
		private static IntPtr CreateSemaphore_internal(int initialCount, int maximumCount, string name, out bool createdNew){}
		private static int ReleaseSemaphore_internal(IntPtr handle, int releaseCount, out bool fail){}
		private static IntPtr OpenSemaphore_internal(string name, SemaphoreRights rights, out MonoIOError error){}
		public SemaphoreSecurity GetAccessControl(){}
		public int Release(){}
		public int Release(int releaseCount){}
		public void SetAccessControl(SemaphoreSecurity semaphoreSecurity){}
		public static Semaphore OpenExisting(string name){}
		public static Semaphore OpenExisting(string name, SemaphoreRights rights){}
		private Semaphore(IntPtr handle){}
		public Semaphore(int initialCount, int maximumCount){}
		public Semaphore(int initialCount, int maximumCount, string name){}
		public Semaphore(int initialCount, int maximumCount, string name, out bool createdNew){}
		public Semaphore(int initialCount, int maximumCount, string name, out bool createdNew, SemaphoreSecurity semaphoreSecurity){}
	}

	public class	SemaphoreFullException: SystemException, ISerializable, _Exception
	{
		public SemaphoreFullException(){}
		public SemaphoreFullException(string message){}
		public SemaphoreFullException(string message, Exception innerException){}
		protected SemaphoreFullException(SerializationInfo info, StreamingContext context){}
	}

	public class	ThreadExceptionEventArgs: EventArgs
	{
		public ThreadExceptionEventArgs(Exception t){}
		public Exception Exception{ get	{} }
		private Exception exception;
	}

	delegate void ThreadExceptionEventHandler(System.Object sender, ThreadExceptionEventArgs e);

}

namespace System.Timers {
	public class	ElapsedEventArgs: EventArgs
	{
		internal ElapsedEventArgs(DateTime time){}
		public DateTime SignalTime{ get	{} }
		private DateTime time;
	}

	public class	Timer: Component, IDisposable, IComponent, ISupportInitialize
	{
		public sealed virtual void BeginInit(){}
		public void Close(){}
		public sealed virtual void EndInit(){}
		public void Start(){}
		public void Stop(){}
		protected virtual void Dispose(bool disposing){}
		private static void Callback(System.Object state){}
		public Timer(){}
		public Timer(double interval){}
		public bool AutoReset{ get	{} set	{} }
		public bool Enabled{ get	{} set	{} }
		public double Interval{ get	{} set	{} }
		public virtual ISite Site{ get	{} set	{} }
		public ISynchronizeInvoke SynchronizingObject{ get	{} set	{} }
		public event	ElapsedEventHandler Elapsed;
		private double interval;
		private bool autoReset;
		private Timer timer;
		private System.Object _lock;
		private ISynchronizeInvoke so;
	}

	public class	TimersDescriptionAttribute: DescriptionAttribute, _Attribute
	{
		public TimersDescriptionAttribute(string description){}
		public virtual string Description{ get	{} }
	}

	delegate void ElapsedEventHandler(System.Object sender, ElapsedEventArgs e);

}

